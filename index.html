<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>📈Signal b🤖t 97 Trx 📈</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Styles pour la popup de notification */
        .notification-popup {
            display: none; /* Cache la popup par défaut */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .notification-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .notification-buttons button {
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .notification-buttons button:first-child {
            background-color: #28a745; /* Vert pour "Oui" */
            color: white;
        }

        .notification-buttons button:last-child {
            background-color: #dc3545; /* Rouge pour "Non" */
            color: white;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f8ff;
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            padding: 20px;
            max-width: 800px;
            width: 100%;
            height: 95vh;
            overflow-y: auto;
            position: relative;
        }

        .fas {
            font-size: 24px; /* Taille de l'icône */
            color: blue; /* Couleur de l'icône */
            margin-right: 10px; /* Espace entre l'icône et le texte */
        }

        .header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-profile {
            margin-right: 20px;
        }

        h1 {
            color: #5b5b5b;
            text-align: center;
            margin-bottom: 20px;
        }

        label {
            margin: 5px 0;
            font-weight: bold;
            display: inline-block;
            width: 180px;
        }

        .action-buttons, .right-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
        }

        button {
            padding: 10px 20px;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            font-size: 16px;
            margin-right: 10px;
        }

        .btn-predict {
            background-color: #28a745;
        }

        .btn-predict:hover {
            background-color: #218838;
        }

        .btn-clear {
            background-color: #dc3545;
        }

        .btn-clear:hover {
            background-color: #c82333;
        }

        .btn-history, .btn-undo {
            background-color: #007bff;
        }

        .btn-history:hover, .btn-undo:hover {
            background-color: #0056b3;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-failure {
            background-color: #dc3545;
        }

        .btn-failure:hover {
            background-color: #c82333;
        }

       
        .btn-copy {
         background-color: #ffc107; /* Jaune */
        
        }
        .btn-copy:hover {
          background-color: #e0a800; /* Jaune plus foncé */
         }

         .btn-export {
          background-color: #28a745; /* Vert */
          }
          .btn-export:hover {
           background-color: #218838; /* Vert plus foncé */
           }

        .color-input, .series-input, .level-selection, #colorPercentage {
            padding: 10px;
            border: 2px solid #aaa;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 150px;
            text-align: center;
            font-size: 18px;
            color: #444;
            background-color: #fff;
        }

        .color-input::placeholder, .series-input::placeholder {
            color: #888;
        }

        .input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
        }
        #haitiTime {
    font-size: 14px;
    color: #333; /* Noir */
    margin-top: 5px;
}

#currentTime {
    font-weight: bold;
    color: #000; /* Noir */
    font-family: 'Arial', sans-serif; /* Police plus lisible */
}
        .level-popup, .level-info-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 2px solid #aaa;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            width: 300px;
        }

        .level-popup h2, .level-info-popup h2 {
            margin-top: 0;
        }

        .level-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .level-buttons label {
            cursor: pointer;
        }

        .btn-confirm {
            background-color: #007bff;
        }

        .btn-confirm:hover {
            background-color: #0056b3;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 16px;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }

        th {
            background-color: #f0f0f0;
        }

        #historyContainer {
            max-height: 300px;
            overflow-y: auto; /* Ajout de la barre de défilement */
        }

        .highlight {
            background-color: yellow;
        }

        .feedback-buttons {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .feedback-buttons button {
            width: 30%;
        }

        .stats {
            margin-top: 20px;
            font-size: 18px;
            text-align: left;
        }

        .bottom-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin: 20px 0;
        }

        .history-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 20px;
    width: 100%;
}

.history-header > div {
    display: flex;
    gap: 10px;
}
        .date-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-bottom: 20px;
        }
       .patterns {
            margin-bottom: 20px;
        }

        .tips {
            margin-bottom: 20px;
        }
        .progress-bar-container {
    position: relative;
    width: 100%;
    margin: 20px 0;
}

.progress-bar {
    width: 100%;
    height: 30px;
    background-color: #e0e0e0;
    border-radius: 15px;
    overflow: hidden;
    position: relative;
}

.progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%);
    width: 0%;
    transition: width 0.5s ease;
    position: relative;
}

.progress-text {
    position: absolute;
    width: 100%;
    text-align: center;
    line-height: 30px;
    color: white;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    z-index: 1;
}

.progress-percentage {
    margin-top: 5px;
    text-align: center;
    font-weight: bold;
}


        .global-stats {
            margin-bottom: 20px;
        }

        .info-tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
            color: #007bff;
        }

        .info-tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .info-tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

      .btn-level {
    background-color: green; /* Couleur de fond */
    color: white; /* Couleur du texte */
    padding: 10px 20px; /* Taille du bouton */
    border: none; /* Pas de bordure */
    border-radius: 5px; /* Coins arrondis */
    cursor: pointer; /* Curseur en main */
    font-size: 16px; /* Taille de police */
    margin-left: 10px; /* Espacement avec le bouton "Effacer" */
}

.action-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 15px 0;
}
.action-buttons button {
    padding: 8px 12px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}
/* Couleurs des boutons */
.btn-predict { background-color: #28a745; color: white; }
.btn-clear { background-color: #dc3545; color: white; }
.btn-level { background-color: #6f42c1; color: white; }
.btn-analyze { background-color: #17a2b8; color: white; }

/* Icônes */
.action-buttons button i {
    font-size: 14px;
}

/* Effets au survol */
.action-buttons button:hover {
    opacity: 0.9;
    transform: translateY(-1px);
}

/* Version mobile */
@media (max-width: 768px) {
    .action-buttons {
        gap: 6px;
    }
    .action-buttons button {
        padding: 6px 10px;
        font-size: 13px;
    }
}

        .level-info-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 2px solid #aaa;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            width: 300px;
        }

        .level-info-popup h2 {
            margin-top: 0;
        }

        .level-info-popup .close-btn {
            position: absolute;
            top: 10px;
            right: 0px;
            background-color: red;
            border: none;
            font-size: 18px;
            cursor: pointer;
        }
        .last-six {
    margin-top: 20px;
}

.last-six h2 {
    text-align: center;
    font-size: 24px;
    margin-bottom: 10px;
}

.prediction-item {
    background-color: #f5f5f5;
    padding: 10px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
}

.prediction-item p {
    margin: 5px 0;
}

.blink {
    animation: blink-animation 0s infinite;
    background-color: #0378fd;
}
#pieChart {
    max-width: 400px;
    margin: 20px auto;
    display: block;
}
.btn-analyze {
    background-color: #17a2b8; /* Couleur turquoise */
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-left: 10px;
}

.btn-analyze:hover {
    background-color: #138496; /* Couleur turquoise plus foncée */
}
/* Animation pour la popup de pause */
@keyframes fadeIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
}

.notification-popup {
    animation: fadeIn 0.5s ease-in-out;
}

/* Barre de progression pour le minuteur */
.progress-bar-timer {
    width: 100%;
    height: 10px;
    background-color: #e0e0e0;
    border-radius: 5px;
    overflow: hidden;
    margin-top: 10px;
}

.progress-bar-fill-timer {
    height: 100%;
    background-color: #007bff;
    width: 100%;
    transition: width 1s linear;
}
.timer-container {
    margin-top: 20px;
    text-align: center;
}

#startStopTimer {
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
}

#startStopTimer:hover {
    background-color: #0056b3;
}

#timerDisplay {
    font-size: 18px;
    margin-top: 10px;
}

#timerMessage {
    font-size: 16px;
    color: #dc3545;
    margin-top: 10px;
}
.timer-container {
    margin-top: 20px;
    text-align: center;
}

.timer-container button {
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin: 5px;
}

.timer-container button:hover {
    background-color: #0056b3;
}

#timerDisplay {
    font-size: 18px;
    margin-top: 10px;
}
.btn-invert {
    background-color: #ffc107; /* Jaune */
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-left: 10px;
}

.btn-invert:hover {
    background-color: #e0a800; /* Jaune plus foncé */
}
/* Styles pour le tableau */
.success-row {
    background-color: rgba(40, 167, 69, 0.1);
}

.failure-row {
    background-color: rgba(220, 53, 69, 0.1);
}

.pending-row {
    background-color: rgba(255, 193, 7, 0.1);
}

.latest-entry {
    animation: highlight-fade 2s ease-out;
    box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
}

@keyframes highlight-fade {
    from { background-color: rgba(0, 123, 255, 0.3); }
    to { background-color: transparent; }
}

.red-dot, .green-dot {
    font-size: 1.2em;
    margin: 0 2px;
}

.success-result {
    color: #28a745;
    font-weight: bold;
}

.failure-result {
    color: #dc3545;
    font-weight: bold;
}
/* Ajoute ces nouveaux styles */
    .prediction-container {
        padding: 15px;
        border-radius: 10px;
        margin: 15px 0;
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
    }
    
    .prediction-red {
        background-color: rgba(220, 53, 69, 0.1);
        border: 2px solid #dc3545;
        color: #dc3545;
    }
    
    .prediction-green {
        background-color: rgba(40, 167, 69, 0.1);
        border: 2px solid #28a745;
        color: #28a745;
    }
    
    .prediction-icon {
        font-size: 24px;
        animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }
    
    .warning-alert {
        background-color: #fff3cd;
        border-left: 5px solid #ffc107;
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
        color: #856404;
    }
    /* Styles pour la popup de stratégie */
.strategy-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    animation: fadeIn 0.5s;
}

.strategy-content {
    background: white;
    padding: 25px;
    border-radius: 15px;
    max-width: 600px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);
}

.strategy-steps {
    margin: 20px 0;
}

.step {
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #eee;
}

.step h3 {
    color: #2c3e50;
    margin-top: 0;
}

.color-example {
    font-size: 24px;
    margin: 10px 0;
    text-align: center;
}

.red-dot, .green-dot {
    margin: 0 3px;
}

.btn-confirm {
    background: #3498db;
    color: white;
    border: none;
    padding: 12px 25px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    display: block;
    margin: 20px auto 0;
    transition: background 0.3s;
}

.btn-confirm:hover {
    background: #2980b9;
}
 /* Ajoutez ce style dans la section <style> */
    .strategy-content {
        max-height: 80vh; /* Hauteur maximale de 80% de la hauteur de l'écran */
        overflow-y: auto; /* Activation de la barre de défilement verticale */
        padding: 25px;
        width: 90%;
        max-width: 600px;
    }

    /* Style personnalisé pour la barre de défilement */
    .strategy-content::-webkit-scrollbar {
        width: 8px;
    }

    .strategy-content::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }

    .strategy-content::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
    }

    .strategy-content::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
    .btn-analyze {
    background-color: #6c757d; /* Gris */
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s;
}

.btn-analyze:hover {
    background-color: #5a6268; /* Gris foncé */
}

.fa-chart-bar {
    margin-right: 8px;
}
/* Conteneur principal en grille */
.color-buttons-grid {
    display: flex;
    justify-content: center;
    gap: 30px; /* Grand écart entre les colonnes */
    margin: 25px 0;
}

/* Colonne verticale de boutons */
.button-column {
    display: flex;
    flex-direction: column;
    gap: 15px; /* Espace vertical entre les boutons */
}

/* Style des boutons R */
.btn-red {
    background-color: #dc3545;
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: all 0.3s;
    min-width: 80px;
    text-align: center;
}

/* Style des boutons V */
.btn-green {
    background-color: #28a745;
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: all 0.3s;
    min-width: 80px;
    text-align: center;
}

/* Effets au survol */
.btn-red:hover {
    background-color: #c82333;
    transform: scale(1.05);
}

.btn-green:hover {
    background-color: #218838;
    transform: scale(1.05);
}

/* Effet lors du clic */
.btn-red:active, .btn-green:active {
    transform: scale(0.98);
}
.password-container {
    display: none;
    margin-top: 15px;
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 5px;
}

.password-container input {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.password-error {
    color: #dc3545;
    font-size: 14px;
    margin-top: 5px;
    display: none;
}
/* Styles pour la bankroll */
.bankroll-container {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
    border: 1px solid #ddd;
}

.bankroll-input {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}

.bankroll-input input {
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 5px;
    width: 120px;
}

.btn-bankroll {
    background-color: #6c757d;
    color: white;
    padding: 8px 15px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

.bankroll-display {
    background-color: white;
    padding: 10px;
    border-radius: 5px;
    font-weight: bold;
}

.bankroll-display span {
    color: #28a745;
}
.btn-apply, .btn-calc {
    padding: 5px 10px;
    margin-left: 8px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.btn-apply {
    background-color: #28a745;
    color: white;
}

.btn-calc {
    background-color: #17a2b8;
    color: white;
}

.calculation-result strong {
    color: #2c3e50;
}
/* Styles pour la section Martingale */
.martingale-section {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    border: 1px solid #dee2e6;
}

.martingale-section h3 {
    color: #343a40;
    margin-top: 0;
    font-size: 1.4rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

.martingale-section h3::before {
    content: "⚡";
    font-size: 1.6rem;
}

.input-group {
    margin-bottom: 15px;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}

.input-group label {
    font-weight: 600;
    color: #495057;
    min-width: 150px;
    margin-bottom: 5px;
}

.input-group input {
    padding: 10px 15px;
    border: 2px solid #ced4da;
    border-radius: 8px;
    font-size: 16px;
    flex-grow: 1;
    max-width: 200px;
    transition: all 0.3s;
}

.input-group input:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    outline: none;
}

.btn-validate {
    background: linear-gradient(135deg, #28a745 0%, #218838 100%);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-validate:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.btn-validate:active {
    transform: translateY(0);
}

.result-display {
    background: #ffffff;
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    border-left: 4px solid #007bff;
}

.result-display p {
    margin: 8px 0;
    font-size: 16px;
    display: flex;
    justify-content: space-between;
}

.result-display p span {
    font-weight: 600;
    color: #2c3e50;
}

.martingale-status {
    font-size: 14px;
    color: #6c757d;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #dee2e6;
}

/* Style pour les puces dans la séquence */
.martingale-sequence {
    display: flex;
    gap: 5px;
    margin-top: 10px;
    flex-wrap: wrap;
}

.martingale-chip {
    background: #007bff;
    color: white;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 30px;
}

.current-chip {
    background: #28a745;
    transform: scale(1.1);
    box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.5);
}
.stats-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin: 20px 0;
    background: #f8f9fa;
    padding: 15px;
    border-radius: 10px;
    border: 1px solid #dee2e6;
}

.color-stats {
    padding: 15px;
    border-radius: 8px;
    text-align: center;
}

.red-stats {
    background-color: rgba(220, 53, 69, 0.1);
    border-left: 4px solid #dc3545;
}

.green-stats {
    background-color: rgba(40, 167, 69, 0.1);
    border-left: 4px solid #28a745;
}

.stats-header {
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.stats-value {
    font-size: 1.5rem;
    font-weight: bold;
    margin: 5px 0;
}

.stats-percentage {
    font-size: 1.1rem;
    color: #6c757d;
}

.force-mode-active {
    animation: pulseWarning 2s infinite;
    border: 2px solid #ffc107;
    box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
}

@keyframes pulseWarning {
    0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
    100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
}
.header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        background: linear-gradient(135deg, #1e2a3a 0%, #2c3e50 100%);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        margin-bottom: 25px;
        color: white;
        position: relative;
       
    }

    .header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #28a745 0%, #007bff 50%, #dc3545 100%);
    }

    .logo-title {
        text-align: center;
        position: relative;
    }

    .trading-badge {
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        background: #ffc107;
        color: #1e2a3a;
        padding: 3px 15px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
    }

    h1 {
        margin: 0;
        font-size: 2.8rem;
        font-weight: 800;
        letter-spacing: -1px;
        background: linear-gradient(90deg, #ffffff 0%, #c2d6f0 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }

    .signal-word {
        color: #4CAF50;
        text-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
    }

    .bot-word {
        color: #2196F3;
        position: relative;
    }

    .bot-word::after {
        content: "🤖";
        position: absolute;
        right: -25px;
        top: -5px;
        font-size: 1.5rem;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }

    .trx-badge {
        background: linear-gradient(135deg, #f44336 0%, #e91e63 100%);
        color: white;
        padding: 2px 12px;
        border-radius: 6px;
        font-size: 1.8rem;
        margin-left: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        position: relative;
        top: -2px;
    }

    .version-badge {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
        letter-spacing: 1px;
        margin-top: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
    }

    .version-badge::before,
    .version-badge::after {
        content: "";
        flex: 1;
        height: 1px;
        background: rgba(255, 255, 255, 0.2);
    }

    .user-profile {
        background: rgba(255, 255, 255, 0.1);
        padding: 12px 20px;
        border-radius: 10px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .user-profile i {
        color: #4CAF50;
        font-size: 20px;
        margin-right: 8px;
    }

    .user-profile strong {
        display: block;
        margin-bottom: 8px;
        color: #ffffff;
        font-size: 16px;
    }

    .user-profile p {
        margin: 3px 0;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
    }

    #userLevelSpan {
        color: #FFC107;
        font-weight: bold;
    }

    #currentTime {
        color: #00BCD4;
        font-weight: bold;
    }

    /* Animation pulsante pour le badge TRX */
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    .trx-badge {
        animation: pulse 2s infinite;
    }

    /* Effet au survol */
    h1:hover .trx-badge {
        animation: none;
        transform: scale(1.1);
        transition: all 0.3s ease;
    }
    html, body {
    overflow-x: hidden;

    margin: 0;           
    padding: 0;         
    }
    .container {
    
     overflow-x: hidden; 
    
}

</style>
</head>
<div class="strategy-popup" id="strategyPopup" style="display: none;">
    <div class="strategy-content">
        <h2>🦁 STRATÉGIE DU "LANCER DE DAVID"</h2>
        <p style="text-align: center; font-style: italic; margin-bottom: 20px;">
            "À Dieu, source de toute inspiration – Mon courage, ma force."<br>
            <strong>Proverbes 28:1</strong> "Le juste est intrépide comme un lion."
        </p>

        <div class="step">
            <h3>⚔️ PRINCIPE FONDAMENTAL</h3>
            <div class="lion-principle">
                <p><strong>Le bot sait gagner, mais il subit des séries de pertes.</strong><br>
                Notre stratégie consiste à <span style="color: #28a745; font-weight: bold;">profiter de ses victoires</span> 
                et à <span style="color: #dc3545; font-weight: bold;">éviter ses défaites</span>.</p>
            </div>
        </div>

        <div class="step">
            <h3>📜 LES 3 COMMANDEMENTS DU LION</h3>
            <div class="commandments">
                <div class="commandment">
                    <span class="commandment-icon">1️⃣</span>
                    <span class="commandment-text">
                        <strong>Quand le bot gagne :</strong><br>
                        - Tu <span style="color: #28a745;">suis ses prédictions</span><br>
                        - Tu <span style="color: #28a745;">continues à miser</span><br>
                        - Tu enregistres les séquences
                    </span>
                </div>
                <div class="commandment">
                    <span class="commandment-icon">2️⃣</span>
                    <span class="commandment-text">
                        <strong>Quand le bot perd :</strong><br>
                        - Tu <span style="color: #dc3545; font-weight: bold;">STOPPES immédiatement</span><br>
                        - Tu <span style="color: #dc3545;">n'engages plus de fonds</span><br>
                        - Tu notes les séquences (sans miser)
                    </span>
                </div>
                <div class="commandment">
                    <span class="commandment-icon">3️⃣</span>
                    <span class="commandment-text">
                        <strong>Quand le bot retrouve un gain :</strong><br>
                        - Tu <span style="color: #28a745;">reprends tes mises</span><br>
                        - Tu <span style="color: #28a745;">suis à nouveau ses prédictions</span>
                    </span>
                </div>
            </div>
        </div>

        <div class="step">
            <h3>🎯 TECHNIQUE DU "STRIKE BACK"</h3>
            <div class="strike-back">
                <p>Quand le bot échoue (1 seule fois suffit) :</p>
                <div class="strike-example">
                    <div class="step">
                        <span class="step-number">1</span>
                        <span class="step-text">Le bot perd (il disait Rouge ❌)</span>
                    </div>
                    <div class="arrow">↓</div>
                    <div class="step">
                        <span class="step-number">2</span>
                        <span class="step-text">Il va recommander <span style="color: #dc3545;">Rouge (🔴)</span></span>
                    </div>
                    <div class="arrow">↓</div>
                    <div class="step" style="background-color: #e8f5e9; border-left: 4px solid #4caf50;">
                        <span class="step-number">3</span>
                        <span class="step-text">Toi, tu mises <span style="color: #28a745; font-weight: bold;">Vert (🟢)</span></span>
                    </div>
                </div>
                <p class="note">Si tu gagnes → Retour en observation<br>
                Si tu perds → Patience, attends le prochain signal</p>
            </div>
        </div>

        <div class="step">
            <h3>💎 POURQUOI ÇA FONCTIONNE ?</h3>
            <div class="advantages">
                <div class="advantage">
                    <span class="advantage-icon">🛡️</span>
                    <span class="advantage-text">Évite 90% des séries de pertes</span>
                </div>
                <div class="advantage">
                    <span class="advantage-icon">💎</span>
                    <span class="advantage-text">Exploite les failles du bot</span>
                </div>
                <div class="advantage">
                    <span class="advantage-icon">📊</span>
                    <span class="advantage-text">Gains > Pertes (équilibre parfait)</span>
                </div>
            </div>
            <p class="performance" style="text-align: center; margin-top: 15px; font-weight: bold;">
                Performance: 72% de réussite | Risque minimal
            </p>
        </div>

        <div class="lion-footer">
            <p>🦁 <strong>THE LION Trader</strong></p>
            <p>"La patience est la force du lion. Frappe au bon moment, et tu domineras."</p>
        </div>

        <button class="btn-confirm" onclick="closeStrategyPopup()">J'ai compris, je suis prêt 🦁</button>
    </div>
</div>
<!-- Popup de notification -->
<div class="notification-popup" id="notificationPopup">
    <div class="notification-content">
        <h2>Vérification des informations</h2>
        <p>Voyez-vous votre nom et votre niveau affichés à l'écran ?</p>
        <div class="notification-buttons">
            <button onclick="handleNotificationResponse(true)">Oui</button>
            <button onclick="handleNotificationResponse(false)">Non</button>
        </div>
    </div>
</div>
<body>
    <div class="container">
        <div class="header">
            <div class="logo-title">
                <div class="trading-badge">TRADING 🤖 BOT</div>
                <h1>
                    <span class="signal-word">SIGNAL</span>
                    <span class="bot-word">BOT</span>
                    <span class="trx-badge">TRX</span>
                </h1>
                <div class="version-badge">v3.0 • 97% Accuracy</div>
            </div>
            <div class="user-profile">
                <i class="fas fa-user"></i>
                <strong>Profil d'utilisateur</strong>
                <p id="userName">Nom : Utilisateur</p>
                <p id="userLevel">Niveau : <span id="userLevelSpan"></span></p>
                <p id="haitiTime">Heure en Haïti : <span id="currentTime"></span></p>
            </div>
        </div>
        
        <div class="timer-container">
            <div class="bankroll-container">
                <h3>💰 Gestion de Bankroll</h3>
                <div class="bankroll-input">
                    <label for="initialBankroll">Capital initial (R) :</label>
                    <input type="number" id="initialBankroll" min="1" placeholder="Ex: 1000">
                    <button onclick="setBankroll()" class="btn-bankroll">Valider</button>
                </div>
                <div class="bankroll-display">
                    <p>Capital actuel : <span id="currentBankroll">0</span> R</p>
                    <p>Dernière mise : <span id="lastBet">0</span> R</p>
                </div>
            </div>
            <div class="result-display">
                <p>Mise actuelle: <span id="currentBetDisplay">0</span> R</p>
                <p>Profit potentiel: <span id="profitDisplay">0</span> R</p>
                <p id="martingaleStatus" class="martingale-status"></p>
            </div>
            
            <div class="martingale-section">
                <h3>⚡ Martingale</h3>
                
                <div class="input-group">
                    <label for="martingaleInput">Séquence des mises (R) :</label>
                    <input type="text" id="martingaleInput" value="1,2,4,8,16,32" placeholder="1,2,4,8,16">
                    <button onclick="validateMartingale()" class="btn-validate">Valider</button>
                </div>
                
                <div class="input-group">
                    <label for="oddsInput">Cotation (%) :</label>
                    <input type="number" id="oddsInput" value="97" min="1" max="100" step="0.01">
                    <button onclick="validateOdds()" class="btn-validate">Valider</button>
                </div>
                
                <div id="martingaleSequenceDisplay" class="martingale-sequence"></div>
            </div>            
            <div class="action-buttons">
                <button class="btn-predict" onclick="predictColor()" id="predictButton">
                    <i class="fas fa-magic"></i> Prédire
                </button>
                
                <button class="btn-clear" onclick="clearFields()">
                    <i class="fas fa-eraser"></i> Effacer
                </button>
                
                <button class="btn-level" onclick="showLevelInfo()">
                    <i class="fas fa-user-shield"></i> Niveau
                </button>
                
                <button class="btn-analyze" onclick="analyzeAllLosses()">
                    <i class="fas fa-search-minus"></i> Pertes
                </button>
                
                <button class="btn-analyze" onclick="forceStatisticalAnalysis()">
                    <i class="fas fa-chart-bar"></i> Stats
                </button>
            </div>
     </div>
        <div class="input-container">
            <label for="dateInput" style="margin-left: 30px;">Date :</label>
            <input type="date" id="dateInput" class="color-input">
        </div>
        <div class="input-container">
            <input type="text" id="colorInput" class="color-input" maxlength="10" placeholder="Ajouter les Couleurs (ex: RVV)" readonly>
        </div>
        <div class="input-container">
            <input type="text" id="seriesInput" class="series-input" maxlength="10" oninput="autoFillColors()" placeholder="Entrer une série de couleurs">
        </div>
        <div class="input-container">
            <input type="text" id="colorPercentage" class="color-input" readonly placeholder="Pourcentage de couleurs">
        </div>
        <div class="color-buttons-grid">
            <!-- Colonne R -->
            <div class="button-column">
                <button class="btn-red" onclick="appendColor('R')">R</button>
                <button class="btn-red" onclick="appendMultiple('R', 2)">RR</button>
                <button class="btn-red" onclick="appendMultiple('R', 3)">RRR</button>
                <button class="btn-red" onclick="appendMultiple('R', 4)">RRRR</button>
            </div>
            
            <!-- Colonne V -->
            <div class="button-column">
                <button class="btn-green" onclick="appendColor('V')">V</button>
                <button class="btn-green" onclick="appendMultiple('V', 2)">VV</button>
                <button class="btn-green" onclick="appendMultiple('V', 3)">VVV</button>
                <button class="btn-green" onclick="appendMultiple('V', 4)">VVVV</button>
            </div>
        </div>
        
        <div class="progress-bar-container">
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progressBarFill" style="width: 0%;">
                    <div class="progress-text" id="progressText">☢️☢️☢️☢️Tuer ⚔️le ⚔️Boss☢️☢️☢️☢️</div>
                </div>
            </div>
            <div class="progress-percentage" id="progressPercentage">0%</div>
        </div>
        <p id="predictionResult"></p>

        <div class="history-header">
            <div style="display: flex; justify-content: space-between; width: 100%;">
                <div>
                    <button class="btn-undo" onclick="undoLastPrediction()">Annuler la prédiction</button>
                </div>
                <div>
                    <button class="btn-copy" onclick="copyHistory()">Copier</button>
                    <button class="btn-export" onclick="exportHistory()">Exporter</button>
                </div>
            </div>
        </div>
        <div class="stats-container">
            <div class="color-stats red-stats" id="redStats">
                <div class="stats-header"><span style="color:#dc3545">🔴</span> Statistiques Rouge</div>
                <div class="stats-value" id="redSuccessCount">0 succès</div>
                <div class="stats-value" id="redFailureCount">0 échecs</div>
                <div class="stats-percentage" id="redSuccessRate">0% de réussite</div>
                <div id="redTrend" style="margin-top:10px;"></div>
            </div>
            <div class="color-stats green-stats" id="greenStats">
                <div class="stats-header"><span style="color:#28a745">🟢</span> Statistiques Vert</div>
                <div class="stats-value" id="greenSuccessCount">0 succès</div>
                <div class="stats-value" id="greenFailureCount">0 échecs</div>
                <div class="stats-percentage" id="greenSuccessRate">0% de réussite</div>
                <div id="greenTrend" style="margin-top:10px;"></div>
            </div>
        </div>
        
        <div id="forceModeAlert" class="alert alert-warning" style="display:none; background:#fff3cd; padding:15px; border-radius:5px; border-left:5px solid #ffc107; margin-bottom:20px;">
            <strong>⚠️ Mode Forcé Activé</strong> 
            <p>2 pertes consécutives détectées. Le bot force maintenant les prédictions sur <span id="forcedColorText"></span> jusqu'au prochain gain.</p>
        </div>
        <div id="historyContainer" class="table-container">
            <table>
                <thead>
                </thead>
                <tbody id="history">
                </tbody>
            </table>
          
       </div>
       <div class="level-popup" id="levelPopup">
        <h2>Choisissez votre Niveau</h2>
        <div class="level-buttons">
            <label><input type="radio" name="level" value="débutant" checked> Débutant</label>
            <label><input type="radio" name="level" value="intermédiaire"> Intermédiaire</label>
            <label><input type="radio" name="level" value="avancé"> Avancé</label>
        </div>
        <button class="btn-confirm" onclick="confirmLevel()">Confirmer</button>
    </div>
       <p id="previousResult"></p>
        <div style="display: flex; align-items: center; gap: 20px;">
             <div style="position: relative; width: 100%; height: 100vh;">
        <button class="btn-undo" onclick="undo()" style="position: absolute; top: 80px; right:20px;">Marche Arrière</button>
        
        <div class="feedback-buttons">
            <button class="btn-success" id="btnSuccess" onclick="giveFeedback(true)">Gagner ✅</button>
            <button class="btn-failure" id="btnFailure" onclick="giveFeedback(false)">Perte ❌</button>
            <button class="btn-history" onclick="clearHistory()">Effacer l'Historique</button>
        </div>
        <div class="stats">
            <p id="successRate"></p>
            <p id="totalPredictions">Total des Prédictions : 0</p>
            <p id="totalSuccesses">Total des Réussites : 0</p>
            <p id="totalFailures">Total des Pertes : 0</p>
            <p id="points">Points : 0</p>
        </div>
        <canvas id="pieChart" width="400" height="400"></canvas>
        
    </div>
    <div class="level-info-popup" id="levelInfoPopup">
        <button class="close-btn" onclick="hideLevelInfo()">X</button>
        <h2>Information de Niveau</h2>
        <p id="currentPoints">Points actuels : 0</p>
        <p>Points nécessaires pour le niveau Intermédiaire : 1000</p>
        <p>Points nécessaires pour le niveau Avancé : 10000</p>
        <!-- Popup de pause -->
<div id="timerPopup" class="notification-popup">
    <div class="notification-content">
        <h2>Pause obligatoire ⏳</h2>
        <p>Vous avez atteint <span id="lossCount"></span> trades perdants consécutifs. Le bot est désactivé pendant <span id="timer"></span> minutes.</p>
        <div class="progress-bar-timer">
            <div class="progress-bar-fill-timer" id="progressBarTimer"></div>
        </div>
    </div>
</div>

<!-- Notification sonore -->
<audio id="notificationSound">
    <source src="notification.mp3" type="audio/mpeg">
    Votre navigateur ne supporte pas l'élément audio.
</audio>
    </div>
    <script>
        function forceStatisticalAnalysis() {
    const colorInput = document.getElementById('seriesInput').value.toUpperCase().replace(/[^RV]/g, '');
    
    // Validation
    if (colorInput.length < 5) {
        Swal.fire({
            title: 'Données insuffisantes',
            text: 'Entrez au moins 5 couleurs pour une analyse fiable',
            icon: 'warning',
            confirmButtonColor: '#ffc107'
        });
        return;
    }

    // Exécution de l'analyse
    const analysis = analyzeAndRecommend(colorInput);
    
    // Affichage détaillé
    Swal.fire({
        title: '📊 Rapport Statistique Complet',
        html: `
            <div style="text-align: left; margin: 15px 0;">
                <p><strong>Recommandation :</strong> ${analysis.recommendation.message}</p>
                <p><strong>Prédiction prioritaire :</strong> ${analysis.recommendation.primary === 'rouge' ? '🔴 ROUGE' : '🟢 VERT'}</p>
                ${analysis.recommendation.secondary ? `<p><strong>Alternative :</strong> ${analysis.recommendation.secondary === 'rouge' ? '🔴 ROUGE' : '🟢 VERT'}</p>` : ''}
            </div>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 10px;">
                <h4 style="margin-top: 0;">Détails Techniques :</h4>
                <ul style="text-align: left;">
                    <li>🔴 Rouge total : ${analysis.trends['🔴'] || 0} (${Math.round((analysis.trends['🔴']/colorInput.length)*100)}%)</li>
                    <li>🟢 Vert total : ${analysis.trends['🟢'] || 0} (${Math.round((analysis.trends['🟢']/colorInput.length)*100)}%)</li>
                    <li>Plus longue série 🔴 : ${analysis.streaks['🔴'] || 0}</li>
                    <li>Plus longue série 🟢 : ${analysis.streaks['🟢'] || 0}</li>
                </ul>
            </div>
        `,
        showCancelButton: true,
        confirmButtonText: 'Appliquer cette prédiction',
        cancelButtonText: 'Fermer',
        confirmButtonColor: '#28a745',
        width: '650px'
    }).then((result) => {
        if (result.isConfirmed) {
            // Applique automatiquement la prédiction
            document.getElementById('seriesInput').value = colorInput.slice(-10); // Garde les 10 derniers
            document.getElementById('colorInput').value = colorInput.slice(-10);
            predictColor(); // Déclenche le processus normal
        }
    });
}
let initialBankroll = 0;
let currentBankroll = 0;
let lastBetAmount = 0;

function setBankroll() {
    const bankrollInput = document.getElementById('initialBankroll').value;
    
    // Validation du montant saisi
    if (!bankrollInput || isNaN(bankrollInput) || parseFloat(bankrollInput) <= 0) {
        Swal.fire({
            title: 'Erreur',
            text: 'Veuillez entrer un montant valide pour votre capital',
            icon: 'error'
        });
        return;
    }
    
    initialBankroll = parseFloat(bankrollInput);
    currentBankroll = initialBankroll;
    updateBankrollDisplay();
    
    // Afficher l'alerte de succès
    Swal.fire({
        title: 'Capital enregistré! 💰',
        html: `
            <div style="font-size: 2.5rem;">✅</div>
            <p>Votre capital initial a été défini à :</p>
            <p style="font-size: 1.5rem; font-weight: bold; color: #28a745;">${initialBankroll.toFixed(2)} R</p>
            <p>Vous pouvez maintenant commencer à trader.</p>
        `,
        icon: 'success',
        confirmButtonText: 'Commencer',
        confirmButtonColor: '#28a745',
        timer: 3000,
        timerProgressBar: true,
        background: '#f8f9fa',
        showClass: {
            popup: 'animate__animated animate__fadeInDown'
        },
        hideClass: {
            popup: 'animate__animated animate__fadeOutUp'
        }
    });
}
function updateBankrollDisplay() {
    document.getElementById('currentBankroll').textContent = currentBankroll.toFixed(2);
    document.getElementById('lastBet').textContent = lastBetAmount.toFixed(2);
}

let martingaleSequence = [1, 2, 4, 8, 16, 32];
let currentMartingaleIndex = 0;
function validateOdds() {
    const oddsInput = document.getElementById('oddsInput');
    const odds = parseFloat(oddsInput.value);
    
    // Validation stricte (entre 1 et 100)
    if (isNaN(odds) || odds < 1 || odds > 100) {
        oddsInput.value = 97; // Valeur par défaut si invalide
        Swal.fire({
            title: 'Erreur',
            text: 'Veuillez entrer une cotation valide entre 1% et 100%',
            icon: 'error'
        });
        return;
    }
    
    // Arrondir à 2 décimales
    const roundedOdds = Math.round(odds * 100) / 100;
    oddsInput.value = roundedOdds;
    
    Swal.fire({
        title: 'Cotation validée!',
        html: `Nouvelle cotation : <strong>${roundedOdds}%</strong>`,
        icon: 'success',
        timer: 1500
    });
    
    updateMartingaleDisplay();
}
function validateMartingale() {
    const input = document.getElementById('martingaleInput').value;
    martingaleSequence = input.split(',').map(Number).filter(n => !isNaN(n));
    if (martingaleSequence.length === 0) martingaleSequence = [1];
    
    Swal.fire({
        title: 'Succès!',
        text: `Séquence martingale mise à jour : ${martingaleSequence.join(', ')}`,
        icon: 'success'
    });
    
    updateMartingaleDisplay();
}

function updateMartingaleDisplay() {
    const nextBet = getCurrentBet();
    const odds = parseFloat(document.getElementById('oddsInput').value) || 97; // 97 par défaut
    
    document.getElementById('currentBetDisplay').textContent = nextBet.toFixed(2);
    document.getElementById('profitDisplay').textContent = (nextBet * (odds / 100)).toFixed(2);
    
    // Afficher le statut en temps réel
    document.getElementById('martingaleStatus').innerHTML = `
        <small>Séquence: ${martingaleSequence.join(', ')} | Cote: ${odds}%</small>
    `;
}
function getCurrentBet() {
    return martingaleSequence[currentMartingaleIndex] || martingaleSequence[0];
}

// À appeler quand le trade gagne
function onWin() {
    const profit = getCurrentBet() * (parseFloat(document.getElementById('oddsInput').value) / 100);
    currentBankroll += profit;
    currentMartingaleIndex = 0; // Réinitialiser la martingale
    updateBankrollDisplay();
    updateMartingaleDisplay();
    return profit;
}

// À appeler quand le trade perd
function onLoss() {
    const loss = getCurrentBet();
    currentBankroll -= loss;
    lastBetAmount = loss;
    currentMartingaleIndex = Math.min(currentMartingaleIndex + 1, martingaleSequence.length - 1);
    updateBankrollDisplay();
    updateMartingaleDisplay();
    return -loss;
}
function applyMartingale() {
    const input = document.getElementById('martingaleSequence').value;
    martingaleSequence = input.split(',').map(Number).filter(n => !isNaN(n));
    if (martingaleSequence.length === 0) martingaleSequence = [1];
    updateDisplay();
    Swal.fire('Succès!', 'Séquence martingale mise à jour', 'success');
}

function calculateProfit() {
    updateDisplay();
}

function updateDisplay() {
    const odds = (document.getElementById('simpleOdds').value || 97) / 100;
    const nextBet = martingaleSequence[currentMartingaleIndex] || martingaleSequence[0];
    document.getElementById('nextBet').textContent = nextBet;
    document.getElementById('potentialProfit').textContent = (nextBet * odds).toFixed(2);
}

function getCurrentBet() {
    return martingaleSequence[currentMartingaleIndex] || martingaleSequence[0];
}

// À appeler quand le trade gagne
function onWin() {
    currentMartingaleIndex = 0;
    updateDisplay();
    return getCurrentBet() * (document.getElementById('simpleOdds').value / 100);
}

// À appeler quand le trade perd
function onLoss() {
    currentMartingaleIndex = Math.min(currentMartingaleIndex + 1, martingaleSequence.length - 1);
    updateDisplay();
    return -getCurrentBet();
}
         function updateHaitiTime() {
    const options = {
        timeZone: 'America/Port-au-Prince', // Fuseau horaire d'Haïti
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false // Format 24 heures
    };

    // Obtenir l'heure actuelle
    const now = new Date();

    // Ajouter 2 secondes pour compenser le décalage
    now.setSeconds(now.getSeconds() + 2);

    // Formater l'heure
    const formatter = new Intl.DateTimeFormat('fr-FR', options);
    const currentTime = formatter.format(now);

    // Afficher l'heure
    document.getElementById('currentTime').textContent = currentTime;
}

// Mettre à jour l'heure toutes les secondes
setInterval(updateHaitiTime, 1000);

// Appeler la fonction une fois au chargement de la page
updateHaitiTime();
         function appendMultiple(color, count) {
    for (let i = 0; i < count; i++) {
        appendColor(color); // Utilise la fonction existante pour ajouter une couleur
    }
}
        // Fonction pour afficher la popup de notification
        function showNotificationPopup() {
            const savedName = localStorage.getItem('userName');
            const savedLevel = localStorage.getItem('userLevel');

            // Vérifie si le nom et le niveau sont déjà sauvegardés
            if (savedName && savedLevel) {
                // Affiche la popup de notification
                document.getElementById('notificationPopup').style.display = 'flex';
            }
        }

        // Fonction pour gérer la réponse de l'utilisateur
        function handleNotificationResponse(isConfirmed) {
            if (isConfirmed) {
                // Si l'utilisateur confirme, on cache la popup
                document.getElementById('notificationPopup').style.display = 'none';
            } else {
                // Si l'utilisateur n'est pas satisfait, on lui permet de resaisir ses informations
                localStorage.removeItem('userName');
                localStorage.removeItem('userLevel');
                document.getElementById('notificationPopup').style.display = 'none';
                validateUserName(); // Redemande le nom
                showLevelPopup(); // Redemande le niveau
            }
        }

        // Fonction pour sauvegarder les statistiques dans le localStorage
        function saveStatsToLocalStorage() {
            localStorage.setItem('totalPredictions', history.length);
            localStorage.setItem('totalSuccesses', successes);
            localStorage.setItem('totalFailures', failures);
            localStorage.setItem('progress', progressBarFill.style.width); // Sauvegarder la barre de progression
        }

        // Fonction pour charger les statistiques depuis le localStorage
        function loadStatsFromLocalStorage() {
            const storedTotalPredictions = localStorage.getItem('totalPredictions');
            const storedTotalSuccesses = localStorage.getItem('totalSuccesses');
            const storedTotalFailures = localStorage.getItem('totalFailures');
            const storedProgress = localStorage.getItem('progress'); // Charger la barre de progression

            if (storedTotalPredictions) {
                history.length = parseInt(storedTotalPredictions);
            }
            if (storedTotalSuccesses) {
                successes = parseInt(storedTotalSuccesses);
            }
            if (storedTotalFailures) {
                failures = parseInt(storedTotalFailures);
            }
            if (storedProgress) {
                document.getElementById('progressBarFill').style.width = storedProgress;
                document.getElementById('progressPercentage').textContent = storedProgress;
            }
        }

        // Appelle les fonctions de sauvegarde des statistiques avant de quitter la page
        window.addEventListener('beforeunload', (event) => {
            saveStatsToLocalStorage();

            // Affiche une confirmation pour quitter l'application
            event.preventDefault();
            event.returnValue = 'Voulez-vous vraiment quitter l\'application ?';
        });

        // Appelle la fonction showNotificationPopup() au chargement de la page
        document.addEventListener('DOMContentLoaded', () => {
            loadHistoryFromLocalStorage();
            loadStatsFromLocalStorage();
            showTutorial();
            validateUserName();
            showLevelPopup();
            updateLevelButtons();
            showNotificationPopup(); // Affiche la popup de notification
            updateStats();
            updateSuccessRate();
            updatePoints();
        });

          // Variables globales existantes
let history = [];
let previousHistory = [];
let consecutiveLosses = 0; // Déjà déclaré ici
let bannedPatterns = []; // Pour stocker les motifs temporairement interdits
let successes = 0;
let failures = 0;
let failedPatterns = {}; // Pour stocker les motifs ayant échoué
let points = localStorage.getItem('totalPoints') ? parseInt(localStorage.getItem('totalPoints')) : 0;
let lastResultWasLoss = false;
let timerInterval;
let timerTime = 0;
let isTimerRunning = false;
let redSuccesses = 0;
let redFailures = 0;
let greenSuccesses = 0;
let greenFailures = 0;
let isForceModeActive = false;
let forcedColor = '';




// Fonction pour démarrer le minuteur
function startTimer(minutes) {
    if (isTimerRunning) {
        Swal.fire({
            title: 'Minuteur déjà en cours ⏰',
            text: 'Veuillez attendre que le minuteur actuel se termine.',
            icon: 'warning',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#ffc107',
            background: '#fff3cd',
            iconColor: '#ffc107',
        });
        return;
    }
    // Gestion des champs de mot de passe pour les niveaux
document.querySelectorAll('input[name="level"]').forEach(radio => {
    radio.addEventListener('change', function() {
        document.getElementById('intermediatePasswordContainer').style.display = 'none';
        document.getElementById('advancedPasswordContainer').style.display = 'none';
        
        if (this.value === 'intermédiaire') {
            document.getElementById('intermediatePasswordContainer').style.display = 'block';
        } else if (this.value === 'avancé') {
            document.getElementById('advancedPasswordContainer').style.display = 'block';
        }
    });
});

function confirmLevel() {
    const level = document.querySelector('input[name="level"]:checked').value;
    
    if (level === "intermédiaire" || level === "avancé") {
        Swal.fire({
            title: 'Mot de passe requis',
            input: 'password',
            showCancelButton: true,
            confirmButtonText: 'Valider',
            cancelButtonText: 'Annuler'
        }).then((result) => {
            if (result.isConfirmed) {
                alert("Mot de passe accepté !");
            }
        });
    } else {
        alert("Niveau débutant sélectionné");
    }
}

function showPasswordPopup(level) {
    Swal.fire({
        title: `Accès ${level} 🔒`,
        html: `Veuillez entrer le mot de passe pour le niveau <strong>${level}</strong>`,
        input: 'password',
        inputPlaceholder: 'Mot de passe...',
        inputAttributes: {
            autocapitalize: 'off',
            autocorrect: 'off'
        },
        showCancelButton: true,
        confirmButtonText: 'Valider',
        cancelButtonText: 'Annuler',
        allowOutsideClick: false,
        preConfirm: (password) => {
            if (password !== LEVEL_PASSWORDS[level]) {
                Swal.showValidationMessage('Mot de passe incorrect');
                return false;
            }
            return true;
        }
    }).then((result) => {
        if (result.isConfirmed) {
            setUserLevel(level);
        } else {
            // Re-sélectionne le niveau débutant si annulation
            document.querySelector('input[value="débutant"]').checked = true;
        }
    });
}

// Définissez vos mots de passe (à changer pour la production)
const LEVEL_PASSWORDS = {
    "intermédiaire": "123",
    "avancé": "456"
};
function setUserLevel(level) {
    localStorage.setItem('userLevel', level);
    document.getElementById('userLevelSpan').textContent = level;
    document.getElementById('levelPopup').style.display = 'none';
    
    Swal.fire({
        title: 'Succès !',
        text: `Vous êtes maintenant niveau ${level}`,
        icon: 'success'
    });
    
    // Mettre à jour l'interface selon le niveau
    updateInterfaceForLevel(level);
}
function updateInterfaceForLevel(level) {
    // Désactiver certaines fonctionnalités pour les niveaux inférieurs
    if (level === "débutant") {
        // Désactiver les boutons avancés
        document.querySelector('.btn-analyze').style.display = 'none';
    } else {
        // Activer tous les boutons
        document.querySelector('.btn-analyze').style.display = 'inline-block';
    }
}
function showLevelPopup() {
    // Sélection automatique du niveau débutant si aucun niveau n'est défini
    if (!localStorage.getItem('userLevel')) {
        document.querySelector('input[value="débutant"]').checked = true;
    }
    document.getElementById('levelPopup').style.display = 'block';
}
// Démarrer le minuteur
    timerTime = minutes * 60; // Convertir en secondes
    isTimerRunning = true;
  
    // Désactiver tous les boutons du bot
    document.querySelectorAll('button').forEach(button => button.disabled = true);

    // Afficher l'alerte SweetAlert pour bloquer l'accès
    Swal.fire({
        title: 'Minuteur activé ⏳',
        html: `
            <p>Le bot est désactivé pendant <strong>${minutes} minutes</strong>.</p>
            <p>Veuillez patienter jusqu'à la fin du minuteur.</p>
            <p id="swalTimer">Temps restant : ${minutes}:00</p>
        `,
        icon: 'info',
        showConfirmButton: false,
        allowOutsideClick: false,
        allowEscapeKey: false,
        allowEnterKey: false,
        background: '#f0f8ff',
        iconColor: '#007bff',
    });

    // Mettre à jour le minuteur dans l'alerte et dans l'interface
    timerInterval = setInterval(() => {
        timerTime--;
        if (timerTime <= 0) {
            clearInterval(timerInterval);
            isTimerRunning = false;

            // Réactiver tous les boutons du bot
            document.querySelectorAll('button').forEach(button => button.disabled = false);

            // Fermer l'alerte SweetAlert
            Swal.close();

            // Afficher un message de fin
            Swal.fire({
                title: 'Minuteur terminé ⏰',
                text: 'Le bot est maintenant réactivé. Vous pouvez continuer à utiliser le bot.',
                icon: 'success',
                confirmButtonText: 'Compris',
                confirmButtonColor: '#28a745',
                background: '#f0f9f0',
                iconColor: '#28a745',
            });

            // Réinitialiser l'affichage du minuteur
            document.getElementById('timerDisplay').textContent = 'Temps restant : 00:00';
            return;
        }

        // Mettre à jour l'affichage du minuteur dans l'alerte et dans l'interface
        const minutesLeft = Math.floor(timerTime / 60);
        const secondsLeft = timerTime % 60;
        const timerText = `Temps restant : ${minutesLeft.toString().padStart(2, '0')}:${secondsLeft.toString().padStart(2, '0')}`;
        document.getElementById('timerDisplay').textContent = timerText;

        if (Swal.isVisible()) {
            Swal.getHtmlContainer().querySelector('#swalTimer').textContent = timerText;
        }
    }, 1000);
}
function updateTimerDisplay() {
    const minutes = Math.floor(timerTime / 60);
    const seconds = timerTime % 60;
    document.getElementById('timerDisplay').textContent = `Temps restant : ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
           function validateUserName() {
            const savedUserName = localStorage.getItem('userName');
            if (!savedUserName) {
                const input = prompt("Veuillez entrer votre nom (minuscules uniquement) :");
                if (input) {
                    localStorage.setItem('userName', input.toLowerCase());
                    document.getElementById('userName').textContent = `Nom : ${input.toLowerCase()}`;
                }
            } else {
                document.getElementById('userName').textContent = `Nom : ${savedUserName}`;
            }
        }

        function validateInput() {
            const input = document.getElementById('colorInput');
            input.value = input.value.toUpperCase().replace(/[^RV]/g, '').slice(0, 3);
        }

        function appendColor(color) {
            const input = document.getElementById('seriesInput');
            if (input.value.length < 10) {
                input.value += color;
                autoFillColors();
            }
        }

        function autoFillColors() {
    const seriesInput = document.getElementById('seriesInput').value.toUpperCase();
    const validColors = ['R', 'V'];

    if (seriesInput.length === 10 && seriesInput.split('').every(char => validColors.includes(char))) {
        const colorCount = seriesInput.split('').reduce((count, char) => {
            count[char] = (count[char] || 0) + 1;
            return count;
        }, {});

        const redPercentage = (colorCount['R'] || 0) * 10;
        const greenPercentage = (colorCount['V'] || 0) * 10;

        const mostFrequentColor = redPercentage >= greenPercentage ? `${redPercentage}% Rouge` : `${greenPercentage}% Vert`;
        document.getElementById('colorPercentage').value = mostFrequentColor;
        document.getElementById('colorInput').value = seriesInput; // Utilise les 10 couleurs
    }
}
function analyzeLossReason(colorInput, prediction, result) {
    const colors = colorInput.split(', '); // Convertir la chaîne en tableau
    const lastThreeColors = colors.slice(-3); // Prend les 3 dernières couleurs
    const colorCount = lastThreeColors.reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    let reason = "";

    // Raison 1 : Tendance récente non respectée
    if (colorCount['R'] > colorCount['V'] && prediction === 'vert') {
        reason = "La tendance récente était rouge, mais vous avez prédit vert.";
    } else if (colorCount['V'] > colorCount['R'] && prediction === 'rouge') {
        reason = "La tendance récente était verte, mais vous avez prédit rouge.";
    }

    // Raison 2 : Séquence répétitive non détectée
    if (isSimpleAlternate(colors) && !isSimpleAlternate(lastThreeColors)) {
        reason = "La séquence était alternée, mais vous n'avez pas suivi cette tendance.";
    } else if (isSimpleDoubleAlternate(colors) && !isSimpleDoubleAlternate(lastThreeColors)) {
        reason = "La séquence était doublement alternée, mais vous n'avez pas suivi cette tendance.";
    }

    // Raison 3 : Pourcentage de couleur dominant ignoré
    const redPercentage = (colors.filter(c => c === 'R').length / colors.length) * 100;
    const greenPercentage = (colors.filter(c => c === 'V').length / colors.length) * 100;
    if (redPercentage >= 60 && prediction === 'vert') {
        reason = "Le rouge dominait à 60% ou plus, mais vous avez prédit vert.";
    } else if (greenPercentage >= 60 && prediction === 'rouge') {
        reason = "Le vert dominait à 60% ou plus, mais vous avez prédit rouge.";
    }

    // Raison 4 : Mode inversion activé
    if (invertedMode) {
        reason = "Le mode inversion était activé, ce qui a inversé la prédiction.";
    }

    // Si aucune raison spécifique n'est trouvée
    if (!reason) {
        reason = "La perte est due à une fluctuation aléatoire du marché ou à une tendance non détectée.";
    }

    return reason;
}
// Nouvelle fonction pour afficher la popup stratégie
function showStrategyPopup() {
    document.getElementById('strategyPopup').style.display = 'flex';
}

function closeStrategyPopup() {
    document.getElementById('strategyPopup').style.display = 'none';
    // Activer les fonctionnalités du bot après fermeture
    document.querySelectorAll('button').forEach(btn => btn.disabled = false);
}
function getLossAdvice(reason) {
    switch (reason) {
        case "La tendance récente était rouge, mais vous avez prédit vert.":
            return "Suivez la tendance dominante dans les prochains trades.";
        case "La tendance récente était verte, mais vous avez prédit rouge.":
            return "Suivez la tendance dominante dans les prochains trades.";
        case "La séquence était alternée, mais vous n'avez pas suivi cette tendance.":
            return "Identifiez les séquences alternées et ajustez vos prédictions en conséquence.";
        case "Le rouge dominait à 60% ou plus, mais vous avez prédit vert.":
            return "Respectez le pourcentage de couleur dominant dans vos prédictions.";
        case "Le vert dominait à 60% ou plus, mais vous avez prédit rouge.":
            return "Respectez le pourcentage de couleur dominant dans vos prédictions.";
        case "Le mode inversion était activé, ce qui a inversé la prédiction.":
            return "Vérifiez si le mode inversion est toujours nécessaire avant de miser.";
        default:
            return "Analysez les tendances récentes et ajustez votre stratégie.";
    }
}
const patterns = {
    // Anciens motifs 13 mars 2024
    "RVRVRVRVRV": "rouge", // 1R1V
    "VRVRVRVRVR": "vert",  // 1V1R
    "RRVVRRVVRR": "vert",  // 2R2V
    "RVVRRVVRRV": "vert",  // 2R2V
    "VVRRVVRRVV": "rouge", // 2V2R
    "VRRVVRRVVR": "rouge", // 2V2R
    "RRRVVVRRR": "vert",   // 3R3V
    "RRVVVRRRVV": "vert",  // 3R3V
    "VVVRRRVVVR": "rouge", // 3V3R
    "VVRRRVVVRR": "rouge", // 3V3R
    "RRRRVVVVRR": "rouge", // 4R4V
    "RRRVVVVRRR": "rouge", // 4R4V
    "RRVVVVRRRR": "vert",  // 4R4V
    "RVVVVRRRRV": "vert",  // 4R4V
    "VVVVRRRRVV": "vert",  // 4V4R
    "VVVRRRRVVV": "vert",  // 4V4R
    "VVRRRRVVVV": "rouge", // 4V4R
    "VRRRRVVVVR": "rouge", // 4V4R
    "RRRRVRRRRV": "rouge", // 4R1V
    "RRRVRRRRVR": "rouge", // 4R1V
    "RRVRRRRVRR": "rouge", // 4R1V
    "RVRRRRVRRR": "rouge", // 4R1V
    "VRRRRVRRRR": "vert",  // 4R1V
    "VVVVRVVVVR": "vert",  // 4R1V
    "VVVRVVVVRV": "vert",  // 4R1V
    "VVRVVVVRVV": "vert",  // 4R1V
    "VRVVVVRVVV": "vert",  // 4R1V
    "RVVVVRVVVV": "rouge", // 4R1V
    "VVVVRRVVVV": "rouge", // 4V2R
    "VVVRRVVVVR": "rouge", // 4V2R
    "RRRRVVRRRR": "vert",  // 4R2V
    "RRRVVRRRRV": "vert",  // 4R2V
    "RRRVVVRRR": "rouge",  // 4R3V
    "RRVVVRRRRV": "vert",  // 4R3V
    "RVVVRRRRVV": "vert",  // 4R3V
    "VVVVVRRRVVV": "vert", // 4V3R
    "VVVRRRVVVV": "rouge", // 4V3R
    "VVRRRVVVVR": "rouge", // 4V3R
    "VRRRVVVVRR": "rouge", // 4V3R
    "RRVRRVRRVR": "rouge", // 2R1V
    "RVRRVRRVRR": "vert",  // 2R1V
    "VVRVVRVVRV": "vert",  // 2V1R
    "VRVVRVVRVV": "rouge", // 2V1R
    "RRRVRRRVRR": "rouge", // 3R1V
    "RRVRRRVRRR": "vert",  // 3R1V
    "VVVRVVVRVV": "vert",  // 3V1R
    "VVRVVVRVVV": "rouge", // 3V1R
    "RRRVVRRRVV": "rouge", // 3R2V
    "VVVRRVVVRR": "vert",  // 3V2R
    "RRRRRRRRRR": "rouge", // long
    "VVVVVVVVVV": "vert",  // long

    // Nouveaux motifs à ajouter 17 mars 2024
    "RRRRRRRRVR": "vert",
    "RRRRRRRVRV": "rouge",
    "RRRRRVRVRV": "vert",
    "RRRVRVRVVV": "rouge",
    "RRVRVRVVVR": "rouge",
    "RVRVRVVVRR": "vert",
    "VRVRVVVRRV": "vert",
    "RVRVVVRRVV": "rouge",
    "VRVVVRRVVR": "vert",
    "RVVVRRVVRV": "vert",
    "VVVRRVVRVV": "vert",
    "VVRRVVRVVV": "rouge",
    "VRRVVRVVVR": "vert",
    "RRVVRVVVRV": "vert",
    "RVVRVVVRVV": "vert",
    "VVRVVVRVVV": "vert",
    "VRVVVRVVVV": "vert",
    "RVVVRVVVVV": "vert",
    "VVVRVVVVVV": "vert",
    "VVRVVVVVVV": "vert",
    "VRVVVVVVVV": "vert",
    "RVVVVVVVVV": "vert",
    "RVVVVVVVVV": "rouge",
    "VVVVVVVVVR": "rouge",
    "VVVVVVVRRR": "vert",
    "VVVVVVRRRV": "rouge",
    "VVVVVRRRVR": "vert",
    "VVVVRRRVRV": "rouge",
    "VVVRRRVRVR": "rouge",
    "VVRRRVRVRR": "rouge",
    "VRRRVRVRRR": "rouge",
    "RRRVRVRRRR": "rouge",
    "RRVRVRRRRR": "vert",
    "RVRVRRRRRV": "rouge",
    "VRVRRRRRVR": "vert",
    "RVRRRRRVRV": "vert",
    "VRRRRRVRVV": "rouge",
    "RRRRRVRVVR": "vert",
    "RRRRVRVVRV": "vert",
    "RRRVRVVRVV": "vert",
    "RRVRVVRVVV": "rouge",
    "RVRVVRVVVR": "rouge",
    "VRVVRVVVRR": "rouge",
    "RVVRVVVRRR": "rouge",
    "VVRVVVRRRR": "vert",
    "VRVVVRRRRV": "rouge",
    "RVVVRRRRVR": "vert",
    "VVVRRRRVRV": "rouge",
    "VVRRRRVRVR": "rouge",
    "VRRRRVRVRR": "rouge",
    "RRRRVRVRRR": "rouge",
    "RRRVRVRRRR": "rouge",
    "RRVRVRRRRR": "vert",
    "RVRVRRRRRV": "vert",
    "VRVRRRRRVV": "vert",
    "RVRRRRRVVV": "vert",
    "VRRRRRVVVV": "vert",
    "RRRRRVVVVV": "vert",
    "RRRRVVVVVV": "vert",
    "RRRVVVVVVV": "vert",
    "RRVVVVVVVV": "vert",
    "RVVVVVVVVV": "vert",
    "VVVVVVVVVV": "rouge",
    "VVVVVVVVVR": "vert",
    "VVVVVVVVRV": "vert",
    "VVVVVVVRVV": "vert",
    "VVVVVVRVVV": "rouge",
    "VVVVVRVVVR": "vert",
    "VVVVRVVVRV": "vert",
    "VVVRVVVRVV": "rouge",
    "VVRVVVRVVR": "rouge",
    "VRVVVRVVRR": "vert",
    "RVVVRVVRRV": "rouge",
    "VVVRVVRRVR": "rouge",
    "VVRVVRRVRR": "vert",
    "VRVVRRVRRV": "rouge",
    "RVVRRVRRVR": "rouge",
    "VVRRVRRVRR": "vert",
    "VRRVRRVRRV": "vert",
    "RRVRRVRRVV": "rouge",
    "RVRRVRRVVR": "vert",
    "VRRVRRVVRV": "rouge",
    "RRVRRVVRVR": "vert",
    "RVRRVVRVRV": "rouge",
    "VRRVVRVRVR": "rouge",
    "RRVVRVRVRR": "rouge",
    "RVVRVRVRRR": "vert",
    "VVRVRVRRRV": "rouge",
    "VRVRVRRRVR": "vert",
    "RVRVRRRVRV": "vert",
    "VRVRRRVRVV": "rouge",
    "RVRRRVRVVR": "vert",
    "VRRRVRVVRV": "vert",
    "RRRVRVVRVV": "vert",
    "RRVRVVRVVV": "rouge",
    "RVRVVRVVVR": "vert",
    "VRVVRVVVRV": "vert",
    "RVVRVVVRVV": "vert",
    "VVRVVVRVVV": "vert",
    "VRVVVRVVVV": "vert",
    "RVVVRVVVVV": "vert",
    "VVVRVVVVVV": "vert",
    "VVRVVVVVVV": "rouge",
    "VRVVVVVVVR": "rouge",
    "RVVVVVVVRR": "vert",
    "VVVVVVVRRV": "rouge",
    "VVVVVVRRVR": "vert",
    "VVVVVRRVRV": "rouge",
    "VVVVRRVRVR": "vert",
    "VVVRRVRVRV": "rouge",
    "VVRRVRVRVR": "rouge",
    "VRRVRVRVRR": "vert",
    "RRVRVRVRRV": "rouge",
    "RVRVRVRRVR": "rouge",
    "VRVRVRRVRR": "rouge",
    "RVRVRRVRRR": "rouge",
    "VRVRRVRRRR": "vert",
    "RVRRVRRRRV": "vert",
    "VRRVRRRRVV": "rouge",
    "RRVRRRRVVR": "vert",
    "RVRRRRVVRV": "vert",
    "VRRRRVVRVV": "vert",
    "RRRRVVRVVV": "rouge",
    "RRRVVRVVVR": "vert",
    "RRVVRVVVRV": "vert",
    "RVVRVVVRVV": "rouge",
    "VVRVVVRVVR": "vert",
    "VRVVVRVVRV": "rouge",
    "RVVVRVVRVR": "vert",
    "VVVRVVRVRV": "rouge",
    "VVRVVRVRVR": "rouge",
    "VRVVRVRVRR": "rouge",
    "RVVRVRVRRR": "vert",
    "VVRVRVRRRV": "vert",
    "VRVRVRRRVV": "rouge",
    "RVRVRRRVVR": "rouge",
    "VRVRRRVVRR": "rouge",
    "RVRRRVVRRR": "vert",
    "VRRRVVRRRV": "vert",
    "RRRVVRRRVV": "rouge",
    "RRVVRRRVVR": "vert",
    "RVVRRRVVRV": "vert",
    "VVRRRVVRVV": "rouge",
    "VRRRVVRVVR": "vert",
    "RRRVVRVVRV": "vert",
    "RRVVRVVRVV": "vert",
    "RVVRVVRVVV": "vert",
     // Motifs du 19 mars
     "RRVRRRRRVR": "vert",
     "RVRRRRRVRV": "vert",
     "VRRRRRVRVV": "rouge",
     "RRRRRVRVVR": "vert",
     "RRRRVRVVRV": "rouge",
    "RRRVRVVRVR": "vert",
    "RRVRVVRVRV": "rouge",
     "RVRVVRVRVR": "vert",
     "VRVVRVRVRV": "vert",
     "RVVRVRVRVV": "vert",
     "VVRVRVRVVV": "rouge",
     "VRVRVRVVVR": "vert",
     "RVRVRVVVRV": "vert",
     "VRVRVVVRVV": "rouge",
     "VRVVRVRRRV": "rouge",
     "RVVRVRRRVR": "vert",
     "VVRVRRRVRV": "rouge",
     "VRVRRRVRVR": "rouge",
     "RVRRRVRVRR": "vert",
     "VRRRVRVRRV": "vert",
     "RRRVRVRRVV": "vert",
     "RRVRVRRVVV": "rouge",
     "RVRVRRVVVR": "rouge",
     "VRVRRVVVRR": "rouge",
    "RVRRVVVRRR": "rouge",
     "VRRVVVRRRR": "vert",
     "RRVVVRRRRV": "rouge",
     "RVRRVVVVRR": "rouge",
     "VRRVVVVRRR": "rouge",
     "RRVVVVRRRR": "rouge",
     "RVVVVRRRRR": "vert",
     "VVVVRRRRRV": "vert",
     "VVVRRRRRVV": "rouge",
     "VVRRRRRVVR": "vert",
     "VRRRRRVVRV": "rouge",
     "RRRRRVVRVR": "vert",
     "RRRRVVRVRV": "rouge",
     "RRRVVRVRVR": "rouge",
     "RRVVRVRVRR": "vert",
     "RVVRVRVRRV": "rouge",
     "VVRVRVRRVR": "vert",
     "VRVRVRRVRV": "vert",
     "RVRVRRVRVV": "vert",
     "VRVRRVRVVV": "rouge",
     "RVRRVRVVVR": "vert",
     "VRRVRVVVRV": "vert",
     "RRVRVVVRVV": "rouge",
     "RVRVVVRVVR": "vert",
     "VRVVVRVVRV": "rouge",
     "RVVVRVVRVR": "vert",
     "VVVRVVRVRV": "vert",
     //20 mars 2025 nouvelle motifs. 
     "RVRVVVVRVV": "vert",
     "VRVVVVRVVV": "rouge",
     "VVVVVRRVRR": "vert",
     "VVVVRRVRRV": "rouge",
     "VVVRRVRRVR": "rouge",
     "VVRRVRRVRR": "rouge",
     "VRRVRRVRRR": "vert",
     "RRVRRVRRRV": "rouge",
     "RVRRVRRRVR": "vert",
     "VRRVRRRVRV": "vert",
     "RRVRRRVRVV": "vert",
     "RVRRRVRVVV": "vert",
     "VRRRVRVVVV": "rouge",
     "RRRVRVVVVR": "vert",
     "RRVRVVVVRV": "rouge",
     "RVRVVVVRVR": "rouge",
     "VRVVVVRVRV": "vert",
     "RVVVVRVRVV": "rouge",
     "VVVVRVRVVR": "rouge",
     "VVVRVRVVRR": "rouge",
     "VVRVRVVRRR": "rouge",
     "VRVRVVRRRR": "vert",
     "RVRVVRRRRV": "rouge",
     "VRVRRRVVRV": "rouge",
     "RVRRRVVRVR": "vert",
     "VRRRVVRVRV": "vert",
     "RRRVVRVRVV": "vert",
    "RRVVRVRVVV": "rouge",
    "RVVRVRVVVR": "vert",
     "VRVRRRRVRV": "rouge",
     "RVRRRRVRVR": "rouge",
    "RVRVRRRRRR": "rouge",
      "VRVRRRRRRR": "vert",
     "RVRRRRRRRV": "vert",
      "VRRRRRRRRV": "rouge",
      "VRRRRRRRVV": "rouge",
      "RRRRRRVVRR": "rouge",
  "RRRRRVVRRR": "vert",
  "RRRRVVRRRV": "vert",
  "RRRVVRRRVV": "rouge",
  "RRVVRRRVVR": "rouge",
  "VVRRRVVRRR": "rouge",
  "VRRRVVRRRR": "rouge",
  "RRRVVRRRRR": "vert",
  "RRVVRRRRRV": "rouge",
  "RVVRRRRRVR": "vert",
  "VVRRRRRVRV": "vert",
  "RRRRVRVVRR": "vert",
  "RRRVRVVRRV": "rouge",
  "RRVRVVRRVR": "rouge",
  "RVRVVRRVRR": "rouge",
  "VRVVRRVRRR": "vert",
  "RVVRRVRRRV": "vert",
  "VVRRVRRRVV": "rouge",
  "VRRVRRRVVR": "rouge",
  "RRVRRRVVRR": "rouge",
  "RVRRRVVRRR": "vert",
  "VRRRVVRRRV": "vert",
  "RRRVVRRRVV": "rouge",
  "RVVRRRVVRV": "vert",
  "VVRRRVVRVV": "rouge",
  "VRRRVVRVVR": "vert",
  "RRRVVRVVRV": "rouge",
  "RRVVRVVRVR": "vert",
  "RVVRVVRVRV": "vert",
  "VVRVVRVRVV": "vert",
  "VRVVRVRVVV": "rouge",
  "VVRVRVVVRV": "vert",
  "VVRVVRVRVR": "vert",
  "VRVVRVRVRV": "vert",
  "VVRVRVRVVR": "vert",
  "VRVRVRVVRV": "rouge",
  "RVRVRVVRVR": "rouge",
  "VRVRVVRVRR": "vert",
  "RVRVVRVRRV": "rouge",
  "VRVVRVRRVR": "rouge",
  "RVVRVRRVRR": "rouge",
  "VVRVRRVRRR": "vert",
  "VRVRRVRRRV": "rouge",
  "VRRRVRRRVRR": "rouge",
  "RRVRRRVRRR": "vert",
  "VRVRRVRVVR": "vert",
  "RVRRVRVVRV": "vert",
  "VRRVRVVRVV": "rouge",
  "RRVRVVRVVR": "rouge",
  "RVRVVRVVRR": "vert",
  "VRVVRVVRRV": "rouge",
  "RVVRVVRRVR": "rouge",
  "VVRVVRRVRR": "rouge",
  "VRVVRRVRRR": "rouge",
  "RVVRRVRRRR": "vert",
  "VVRRVRRRRV": "vert",
  "VRRVRRRRVV": "vert",
  "RRVRRRRVVV": "rouge",
  "RVRRRRVVVR": "rouge",
  "VRRRRVVVRR": "rouge",
  "RRRRVVVRRR": "rouge",
  "RRRVVVRRRR": "rouge",
  "RRVVVRRRRR": "rouge",
  "RVVVRRRRRR": "rouge",
  "VVVRRRRRRR": "rouge",
  "VVRRRRRRRR": "vert",
  "VRRRRRRRRV": "vert",
  "RRRRRRRRVV": "rouge",
  "RRRRRRRVVR": "vert",
  "RRRRRRVVRV": "rouge",
  "RVVRVRVRRR": "rouge",
  "VVRVRVRRRR": "vert",
  "VRVRVRRRRV": "rouge",
  "RVRVRRRRVR": "vert",
  "VRVRRRRVRV": "vert",
  "RVRRRRVRVV": "rouge",
  "VRRRRVRVVR": "vert",
  "VVVRRVRRVV": "vert",
  "VVRRVRRVVV": "rouge",
  "RVRRVVVRVV": "rouge",
  "VRRVVVRVVR": "vert",
  "RRVVVRVVRV": "rouge",
  "VVRVVRVRVR": "rouge",
  "VRVVRVRVRR": "rouge",
  "RVVRVRVRRR": "vert",
  "VVRVRVRRRV": "rouge",
  "VRVRVRRRVR": "rouge",
  "RVRVRRRVRR": "vert",
  "VRVRRRVRRV": "vert",
  "RRVVVRVVVR": "vert",
  "RVVVRVVVRV": "rouge",
  "VVVRVVVRVR": "vert",
  "VVRVVVRVRV": "rouge",
  "VRVVVRVRVR": "rouge",
  "RVVVRVRVRR": "vert",
  "VVRVRVRRVV": "vert",
  "VRVRRRVVVV": "rouge",
  "RVRVRRVVVR": "rouge",
  "VRVRRVVVRR": "rouge",
  "RVRRVVVRRR": "rouge",
  "RRVVVRRRRR": "vert",
  "RVVVRRRRRV": "vert",
  "VVRRRRRVVV": "rouge",
  "VRRRRRVVVR": "rouge",
  "RRRRRVVVRV": "rouge",
  "RRRRVVVRVR": "vert",
  "RRRVVVRVRV": "vert",
  "RRVVVRVRVV": "rouge",
  "RVVVRVRVVR": "vert",
  "VVVRVRVVRV": "vert",
  "VVRVRVVRVV": "rouge",
  "VRVRVVRVVR": "vert",
  "RVRVVRVVRV": "vert",
  "VRVVRVVRVV": "rouge",
  "RVVRVVRVVR": "vert",
  "VVRVVRVVRV": "rouge",
  "VRVVRVVRVR": "vert",
  "RVVRVVRVRV": "vert",
  "VVRVVRVRVV": "vert",
  "VRVVRVRVVV": "vert",
  "RVVRVRVVVV": "rouge",
  "VVRVRVVVVR": "rouge",
  "VRVRVVVVRR": "vert",
  "RVRVVVVRRV": "vert",
  "VRVVVVRRVV": "rouge",
  "VVRVVVVRVR": "rouge",
  "VRVVVVRVRR": "vert",
  "RVVVVRVRRV": "vert",
  "VVVVRVRRVV": "rouge",
  "VVVRVRRVVR": "vert",
  "VVRVRRVVRV": "vert",
  "VRVRRVVRVV": "rouge",
  "RVRRVVRVVR": "rouge",
  "VRRVVRVVRR": "rouge",
  "RRVVRVVRRR": "rouge",
  "RVVRVVRRRR": "rouge",
  "VVRVVRRRRV": "rouge",
  "VRVVRRRRVR": "rouge",
  "RVVRRRRVRR": "vert",
  "VVRRRRVRRV": "rouge",
  "VRRRRVRRVR": "rouge",
  "RRRRVRRVRR": "rouge",
  "RRRVRRVRRR": "vert",
  "RVRRVRRRVV": "rouge",
  "RRVRRRVVRV": "vert",
  "RVRRRVVRVV": "vert",
  "VRRRVVRVVV": "rouge",
  "RRRVVRVVVR": "rouge",
  "RRVVRVVVRR": "rouge",
  "VRVVVRRRRR": "vert",
  "RRRRRVRVVV": "vert",
  "RRRRVRVVVV": "rouge",
  "RVRRRVRRRR": "rouge",
  "VRRRVRRRRR": "rouge",
  "RRRVRRRRRR": "rouge",
  "RRVRRRRRRR": "vert",
  "VRRRRRRRVR": "vert",
  "RRRRRRVRVV": "vert",
  "RRRRRVRVVV": "vert",
  "RRRRVRVVVV": "vert",
  "RRRVRVVVVV": "vert",
  "RRVRVVVVVV": "vert",
  "RVRVVVVVVV": "rouge",
  "VRVVVVVVVR": "rouge",
  "RVVVVVVVRR": "rouge",
  "VVVVVVVRRR": "vert",
  "VVVVVVRRRV": "rouge",
  "VVVVVRRRVR": "vert",
  "VVVVRRRVRV": "rouge",
  "VVVRRRVRVR": "vert",
  "VVRRRVRVRV": "vert",
  "VRRRVRVRVV": "vert",
  "RVRVVVRVVV": "rouge",
  "VRVVVRVVVR": "rouge",
  "RVVVRVVVRR": "vert",
  "VVVRVVVRRV": "rouge",
  "VVRVVVRRVR": "vert",
  "VRVVVRRVRV": "rouge",
  "RVVVRRVRVR": "rouge",
  "VVVRRVRVRR": "rouge",
  "VVRRVRVRRR": "rouge",
  "VRRVRVRRRR": "rouge",
  "VRRRRRVRVR": "rouge",
  "RRRRRVRVRR": "rouge",
  "RRRRVRVRRR": "rouge",
  "RRVRVRRRRV": "vert",
  "RVRVRRRRVV": "vert",
  "VRVRRRRVVV": "rouge",
  "VRRRRVVVRR": "vert",
  "RRRRVVVRRV": "rouge",
  "RRRVVVRRVR": "rouge",
  "RRVVVRRVRR": "vert",
  "RVVVRRVRRV": "rouge",
  "VVRRVRRVRV": "rouge"
};
function analyzeAndRecommend(sequence) {
    // Convertir la séquence en emojis 🔴/🟢 pour l'analyse
    const colors = sequence.split('').map(c => c === 'R' ? '🔴' : '🟢');
    
    // Initialisation des données
    const trends = {};
    const streaks = {};
    let currentStreak = 0;
    let currentColor = null;

    // Analyse des tendances et séries consécutives
    colors.forEach((color, index) => {
        // Compter les occurrences
        trends[color] = (trends[color] || 0) + 1;

        // Calculer les séries consécutives
        if (color === currentColor) {
            currentStreak++;
        } else {
            if (currentColor !== null) {
                streaks[currentColor] = Math.max(streaks[currentColor] || 0, currentStreak);
            }
            currentColor = color;
            currentStreak = 1;
        }

        // Dernière position
        if (index === colors.length - 1) {
            streaks[currentColor] = Math.max(streaks[currentColor] || 0, currentStreak);
        }
    });

    // Identifier la couleur dominante (celle qui apparaît le plus)
    const dominantColor = Object.keys(trends).reduce((a, b) => trends[a] > trends[b] ? a : b);

    // Identifier la plus longue série consécutive
    const longestStreakColor = Object.keys(streaks).reduce((a, b) => streaks[a] > streaks[b] ? a : b, Object.keys(streaks)[0]);

    // Décider des recommandations
    const recommendation = {
        primary: null,
        secondary: null,
        message: ""
    };

    if (streaks[longestStreakColor] >= 3) {
        recommendation.primary = longestStreakColor === '🔴' ? 'rouge' : 'vert';
        recommendation.message = `La couleur ${longestStreakColor} montre une série forte (${streaks[longestStreakColor]} fois), privilégiez-la.`;
    } else {
        recommendation.primary = dominantColor === '🔴' ? 'rouge' : 'vert';
        recommendation.secondary = longestStreakColor === '🔴' ? 'rouge' : 'vert';
        recommendation.message = `La couleur ${dominantColor} domine (${trends[dominantColor]}/10), mais surveillez ${longestStreakColor} pour une possible inversion.`;
    }

    return {
        trends,
        streaks,
        recommendation
    };
}
function predictColor() {
    const colorInput = document.getElementById('colorInput').value.toUpperCase();
    const validColors = ['R', 'V'];

    // 1. Vérification du mode forcé (prioritaire)
    if (isForceModeActive) {
        completeForcedPrediction();
        return;
    }

    // 2. Vérification des restrictions
    if (!checkPredictionRestrictions(colorInput)) return;

    // 3. Validation du format
    if (colorInput.length !== 10 || !colorInput.split('').every(char => validColors.includes(char))) {
        showColorFormatAlert();
        return;
    }

    // 4. Calcul des pourcentages et vérification des ratios interdits
    const colorCount = colorInput.split('').reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    const redCount = colorCount['R'] || 0;
    const greenCount = colorCount['V'] || 0;
    
    // Vérification explicite des ratios 6R/4V et 6V/4R
    /*if ((redCount === 6 && greenCount === 4) || (redCount === 4 && greenCount === 6)) {
        Swal.fire({
            title: 'RATIO INTERDIT ⛔',
            html: `
                <div style="font-size: 2rem;">🚫</div>
                <p>Le ratio <strong>${redCount}R/${greenCount}V</strong> est interdit.</p>
                <p>Motif : Ces ratios montrent une instabilité statistique trop importante.</p>
                <p style="color: #dc3545;">Veuillez entrer une nouvelle séquence.</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#dc3545'
        });
        return;
    }*/

    const frequentColor = redCount * 10 >= greenCount * 10 
        ? `${redCount * 10}% Rouge` 
        : `${greenCount * 10}% Vert`;

    // 5. Vérification du feedback manquant
    if (history.length > 0 && !history[history.length - 1].result) {
        showMissingFeedbackAlert();
        return;
    }

    // 6. Conversion au format lisible
    const lastColors = colorInput.split('').map(char => char === 'R' ? 'rouge' : 'vert');

    // 7. Vérification des doublons
    const previousResult = history.find(record => record.colors === lastColors.join(', '));
    if (previousResult) {
        handleDuplicatePrediction(previousResult, colorInput, lastColors, frequentColor);
        return;
    }

    // 8. Exécution normale
    completePrediction(colorInput, lastColors, frequentColor);
}

function completePrediction(colorInput, lastColors, frequentColor) {
    // 1. D'abord essayer avec les motifs répétés
    let nextColor = predictBasedOnRepeatedPatterns(colorInput);

    // 2. Si aucun motif répété, essayer avec les motifs prédéfinis
    if (!nextColor) {
        nextColor = predictBasedOnSimilarity(colorInput);
        
        // 3. Si aucun motif prédéfini trouvé, utiliser la nouvelle règle par défaut
        if (!nextColor) {
            const lastColor = colorInput.slice(-1); // Prendre la dernière couleur
            nextColor = lastColor === 'R' ? 'rouge' : 'vert';
        }
    }

    // Enregistrement de la prédiction
    history.push({
        tradeNumber: history.length + 1,
        colors: lastColors.join(', '),
        prediction: nextColor,
        frequentColor: frequentColor,
        result: '',
        date: document.getElementById('dateInput').value || new Date().toLocaleDateString(),
        method: nextColor ? 'pattern' : 'statistical'
    });

    // Affichage du résultat
    const predictionResult = document.getElementById('predictionResult');
    predictionResult.className = `prediction-container prediction-${nextColor === 'rouge' ? 'red' : 'green'}`;
    predictionResult.innerHTML = `
        <span class="prediction-icon">${nextColor === 'rouge' ? '🔴' : '🟢'}</span>
        <span>PRÉDICTION : MISER SUR <strong>${nextColor.toUpperCase()}</strong></span>
        <span class="prediction-icon">${nextColor === 'rouge' ? '🔴' : '🟢'}</span>
    `;

    document.getElementById('colorInput').value = '';
    updateHistory();
    enableFeedbackButtons();
    
    Swal.fire({
        title: 'Prédiction Enregistrée!',
        html: `
            <p>Mise recommandée: <strong>${nextColor.toUpperCase()}</strong></p>
            <p>${frequentColor}</p>
        `,
        icon: 'success',
        confirmButtonText: 'Continuer'
    });
    
    updateStats();
    saveHistoryToLocalStorage();
    return true;
}
// Nouvelle fonction pour les prédictions forcées
function completeForcedPrediction() {
    const colorInput = document.getElementById('colorInput').value.toUpperCase();
    
    // 1. Vérification IMPÉRATIVE de toutes les restrictions avant toute prédiction forcée
    if (!checkPredictionRestrictions(colorInput)) {
        Swal.fire({
            title: 'Prédiction Forcée Impossible ⚠️',
            html: `
                <p>Le mode forcé ne peut pas contourner les règles de sécurité :</p>
                <p style="color:#dc3545;font-weight:bold;">
                    ${getActiveRestrictions(colorInput).join('<br>')}
                </p>
                <p>Veuillez attendre un nouveau signal.</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris'
        });
        return;
    }

    const lastColors = colorInput.split('').map(char => char === 'R' ? 'rouge' : 'vert');
    
    // Calcul du pourcentage de couleur (inchangé)
    const colorCount = colorInput.split('').reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    const frequentColor = (colorCount['R'] || 0) * 10 >= (colorCount['V'] || 0) * 10 
        ? `${(colorCount['R'] || 0) * 10}% Rouge` 
        : `${(colorCount['V'] || 0) * 10}% Vert`;

    // Enregistrement de la prédiction forcée (inchangé)
    history.push({
        tradeNumber: history.length + 1,
        colors: lastColors.join(', '),
        prediction: forcedColor,
        frequentColor: frequentColor,
        result: '',
        date: document.getElementById('dateInput').value || new Date().toLocaleDateString(),
        method: 'forced',
        forced: true,
        restrictionsChecked: true // Nouveau champ pour tracer le respect des règles
    });

    // Affichage du résultat (inchangé)
    const predictionResult = document.getElementById('predictionResult');
    predictionResult.className = `prediction-container prediction-${forcedColor === 'rouge' ? 'red' : 'green'}`;
    predictionResult.innerHTML = `
        <span class="prediction-icon">${forcedColor === 'rouge' ? '🔴' : '🟢'}</span>
        <span>PRÉDICTION FORCÉE : MISER SUR <strong>${forcedColor.toUpperCase()}</strong></span>
        <span class="prediction-icon">${forcedColor === 'rouge' ? '🔴' : '🟢'}</span>
        <div class="warning-alert">⚠️ Mode forcé activé (2 pertes consécutives)</div>
    `;

    document.getElementById('colorInput').value = '';
    updateHistory();
    enableFeedbackButtons();
    
    // Notification (inchangée mais avec mention des règles respectées)
    Swal.fire({
        title: 'Prédiction Forcée Validée!',
        html: `
            <p>Mise forcée sur: <strong style="color:${forcedColor === 'rouge' ? '#dc3545' : '#28a745'}">${forcedColor.toUpperCase()}</strong></p>
            <p>✅ Toutes les règles de sécurité sont respectées :</p>
            <ul style="text-align:left;margin-left:20px;">
                ${getRespectedRules(colorInput).map(r => `<li>${r}</li>`).join('')}
            </ul>
            <p>${frequentColor}</p>
        `,
        icon: 'success',
        confirmButtonText: 'Continuer'
    });
}

// Fonctions helper (à ajouter dans votre code)
function getActiveRestrictions(colorInput) {
    const restrictions = [];
    const lastThree = colorInput.slice(-3);
    
    if (lastThree === 'RVR' || lastThree === 'VRV') {
        restrictions.push('• Séquence RVR/VRV interdite');
    }
    
    const redCount = (colorInput.match(/R/g) || []).length;
    const greenCount = (colorInput.match(/V/g) || []).length;
    if ((redCount === 6 && greenCount === 4) || (redCount === 4 && greenCount === 6)) {
        restrictions.push(`• Ratio ${redCount}R/${greenCount}V interdit`);
    }
    
    if (bannedPatterns.includes(lastThree)) {
        restrictions.push(`• Motif ${lastThree} temporairement bloqué`);
    }
    
    return restrictions.length ? restrictions : ['Aucune restriction active'];
}

function getRespectedRules(colorInput) {
    return [
        'Aucune séquence RVR/VRV détectée',
        'Ratios 6/4 absents',
        bannedPatterns.length ? `Motifs ${bannedPatterns.join(', ')} évités` : 'Aucun motif temporaire bloqué'
    ];
}
// Fonctions extraites pour plus de clarté :
function showColorFormatAlert() {
    Swal.fire({
        title: 'Séquence de couleurs 🔴🟢',
        html: `
            <p>Veuillez entrer une séquence de <strong>10 couleurs</strong>, utilisant uniquement :</p>
            <ul>
                <li><strong>"R"</strong> pour Rouge 🔴</li>
                <li><strong>"V"</strong> pour Vert 🟢</li>
            </ul>
        `,
        icon: 'info',
        confirmButtonText: 'Compris'
    });
}

function showMissingFeedbackAlert() {
    Swal.fire({
        title: 'Action requise ⚠️',
        html: `
            <p>Veuillez marquer la dernière prédiction comme <strong>gagnée</strong> ou <strong>perdue</strong> avant d'effectuer une nouvelle prédiction.</p>
        `,
        icon: 'warning',
        confirmButtonText: 'Compris'
    });
}

function handleDuplicatePrediction(previousResult, colorInput, lastColors, frequentColor) {
    Swal.fire({
        title: 'Prédiction existante ⚠️',
        html: `
            <p>Cette séquence existe déjà dans l'historique :</p>
            <p><strong>Prédiction :</strong> ${previousResult.prediction}</p>
            <p><strong>Résultat :</strong> ${previousResult.result === 'Échec' ? '❌ Échec' : '✅ Succès'}</p>
            ${previousResult.result === 'Échec' ? '<p>Conseil : Essayez de miser la couleur contraire.</p>' : ''}
        `,
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'Continuer quand même',
        cancelButtonText: 'Annuler'
    }).then((result) => {
        if (result.isConfirmed) {
            completePrediction(colorInput, lastColors, frequentColor);
        } else {
            clearFields();
        }
    });
}
// Nouvelle fonction pour la partie finale de la prédiction (identique à votre code original)
function completePrediction(colorInput, lastColors, frequentColor) {
    // 1. D'abord essayer avec les motifs répétés
    let nextColor = predictBasedOnRepeatedPatterns(colorInput);

    // 2. Si aucun motif répété, essayer avec les motifs prédéfinis
    if (!nextColor) {
        nextColor = predictBasedOnSimilarity(colorInput);
        
        // 3. Si aucun motif prédéfini trouvé, utiliser l'analyse statistique
        if (!nextColor) {
            const analysis = analyzeAndRecommend(colorInput);
            nextColor = analysis.recommendation.primary;
            
            // Ajouter un message d'information
            Swal.fire({
                title: 'Analyse Statistique Activée 📊',
                html: `
                    <p>${analysis.recommendation.message}</p>
                    <p><strong>Détails :</strong></p>
                    <ul>
                        <li>🔴 Rouge: ${analysis.trends['🔴'] || 0} occurrences</li>
                        <li>🟢 Vert: ${analysis.trends['🟢'] || 0} occurrences</li>
                        <li>Plus longue série: ${analysis.streaks[analysis.recommendation.primary === 'rouge' ? '🔴' : '🟢'] || 0}</li>
                    </ul>
                `,
                icon: 'info',
                confirmButtonText: 'Compris',
                confirmButtonColor: '#17a2b8',
                background: '#f0f8ff',
                iconColor: '#17a2b8'
            });
        }
    }

    // Enregistrement de la prédiction
    history.push({
        tradeNumber: history.length + 1,
        colors: lastColors.join(', '),
        prediction: nextColor,
        frequentColor: frequentColor,
        result: '',
        date: document.getElementById('dateInput').value || new Date().toLocaleDateString(),
        method: nextColor ? 'pattern' : 'statistical' // Nouveau champ pour tracker la méthode
    });

    // Affichage du résultat
    const predictionResult = document.getElementById('predictionResult');
    predictionResult.className = `prediction-container prediction-${nextColor === 'rouge' ? 'red' : 'green'}`;
    predictionResult.innerHTML = `
        <span class="prediction-icon">${nextColor === 'rouge' ? '🔴' : '🟢'}</span>
        <span>PRÉDICTION : MISER SUR <strong>${nextColor.toUpperCase()}</strong></span>
        <span class="prediction-icon">${nextColor === 'rouge' ? '🔴' : '🟢'}</span>
        ${!nextColor ? '<div class="warning-alert">⚠️ Prédiction basée sur l\'analyse statistique</div>' : ''}
    `;

    document.getElementById('colorInput').value = '';
    updateHistory();
    enableFeedbackButtons();
    
    Swal.fire({
        title: 'Prédiction Enregistrée!',
        html: `
            <p>Mise recommandée: <strong>${nextColor.toUpperCase()}</strong></p>
            <p>Méthode: ${nextColor ? 'Motif reconnu' : 'Analyse statistique'}</p>
            <p>${frequentColor}</p>
        `,
        icon: 'success',
        confirmButtonText: 'Continuer'
    });
    
    updateStats();
    saveHistoryToLocalStorage();
    return true;
}
// NOUVELLE FONCTION: Analyse des motifs répétés
function predictBasedOnRepeatedPatterns(colorInput) {
    // Recherche des motifs de 3 couleurs répétés
    const patternMap = {};
    
    // Enregistrer toutes les occurrences de chaque motif de 3 couleurs
    for (let i = 0; i <= colorInput.length - 3; i++) {
        const pattern = colorInput.substr(i, 3);
        if (!patternMap[pattern]) {
            patternMap[pattern] = [];
        }
        patternMap[pattern].push(i);
    }

    // Trouver le motif le plus fréquent (au moins 2 occurrences)
    let mostFrequentPattern = null;
    let maxOccurrences = 1;
    
    for (const pattern in patternMap) {
        if (patternMap[pattern].length > maxOccurrences) {
            mostFrequentPattern = pattern;
            maxOccurrences = patternMap[pattern].length;
        }
    }

    // Si on a trouvé un motif répété, prédire la couleur suivante
    if (mostFrequentPattern && maxOccurrences >= 2) {
        const lastOccurrenceIndex = Math.max(...patternMap[mostFrequentPattern]);
        if (lastOccurrenceIndex + 3 < colorInput.length) {
            const nextColorChar = colorInput[lastOccurrenceIndex + 3];
            return nextColorChar === 'R' ? 'rouge' : 'vert';
        }
    }

    return null; // Aucun motif répété trouvé
}

// FONCTION EXISTANTE (à conserver)
function predictBasedOnSimilarity(colorInput) {
    const mostSimilarPattern = findMostSimilarPattern(colorInput);
    if (mostSimilarPattern) {
        return patterns[mostSimilarPattern];
    }
    return null;
}

// FONCTION EXISTANTE (à conserver)
function findMostSimilarPattern(inputPattern) {
    let mostSimilarPattern = '';
    let highestSimilarity = 0;

    for (const pattern in patterns) {
        let similarity = 0;
        for (let i = 0; i < inputPattern.length; i++) {
            if (inputPattern[i] === pattern[i]) {
                similarity++;
            }
        }
        if (similarity > highestSimilarity) {
            highestSimilarity = similarity;
            mostSimilarPattern = pattern;
        }
    }

    return mostSimilarPattern;
}

// FONCTION EXISTANTE (à conserver)
function predictBasedOnTrends(colorInput) {
    const lastThreeColors = colorInput.slice(-3);
    const colorCount = lastThreeColors.split('').reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    if (colorCount['R'] > colorCount['V']) {
        return 'rouge';
    } else if (colorCount['V'] > colorCount['R']) {
        return 'vert';
    } else {
        const globalRed = (colorInput.split('R').length - 1) * 10;
        const globalGreen = (colorInput.split('V').length - 1) * 10;
        return globalRed >= globalGreen ? 'rouge' : 'vert';
    }
}

function displayPreviousResult(previousResult) {
    const lastPrediction = history.length > 1 ? history[history.length - 2] : null; // Récupérer la dernière prédiction avant la plus récente

    // Vérifier si la prédiction précédente a échoué et si la prédiction actuelle est différente
    if (lastPrediction && lastPrediction.result === 'Échec' && lastPrediction.prediction !== previousResult.prediction) {
        document.getElementById('previousResult').textContent = 'Cette prédiction a échoué auparavant. Vous avez misé la couleur contraire.';
    } else if (previousResult.result === 'Échec' && previousResult.prediction === lastPrediction.prediction) {
        document.getElementById('previousResult').textContent = 'Cette situation a échoué auparavant avec la même prédiction. Essayez de miser la couleur contraire.';
    } else {
        const resultMessage = `Cette prédiction existe déjà dans l'historique. Prédiction : ${previousResult.prediction}, Résultat : ${previousResult.result}, Pourcentage de Couleur : ${previousResult.frequentColor}`;
        document.getElementById('previousResult').textContent = resultMessage;
    }
    console.log("Séquence de couleurs :", colorInput);
    console.log("Prédiction associée :", nextColor);
}



        function clearFields() {
            document.getElementById('colorInput').value = '';
            document.getElementById('seriesInput').value = '';
            document.getElementById('colorPercentage').value = '';
            document.getElementById('predictionResult').textContent = '';
            document.getElementById('previousResult').textContent = '';
            enableFeedbackButtons();
        }

        function giveFeedback(correct) {
    const lastHistoryItem = history[history.length - 1];
    
    // Vérification si le feedback a déjà été donné
    if (lastHistoryItem.result !== '') {
        Swal.fire({
            title: 'Déjà évalué ⚠️',
            text: 'Cette prédiction a déjà reçu un feedback.',
            icon: 'info',
            confirmButtonText: 'OK',
            confirmButtonColor: '#007bff'
        });
        return;
    }

    // Configuration du trading
    const odds = parseFloat(document.getElementById('oddsInput').value) || 97;
    const currentBet = getCurrentBet();
    const nextBet = martingaleSequence[Math.min(currentMartingaleIndex + 1, martingaleSequence.length - 1)] || martingaleSequence[0];

    // Vérification de la bankroll
    if (!correct && currentBankroll < currentBet) {
        Swal.fire({
            title: 'Fonds insuffisants ⛔',
            html: `<strong>${currentBankroll.toFixed(2)} R</strong> disponibles<br>
                   <strong>${currentBet.toFixed(2)} R</strong> requis`,
            icon: 'error',
            willClose: () => {
                currentMartingaleIndex = 0; // Reset martingale après impossibilité de miser
                updateMartingaleDisplay();
            }
        });
        return;
    }

    // Mise à jour des statistiques par couleur
    if (correct) {
        if (lastHistoryItem.prediction === 'rouge') {
            redSuccesses++;
        } else {
            greenSuccesses++;
        }
    } else {
        if (lastHistoryItem.prediction === 'rouge') {
            redFailures++;
        } else {
            greenFailures++;
        }
    }

    if (correct) {
        // Mettre à jour la barre de progression
        updateProgressBar(1);
        // Traitement gain
        const profit = currentBet * (odds / 100);
        currentBankroll = parseFloat((currentBankroll + profit).toFixed(2));
        consecutiveLosses = 0;
        currentMartingaleIndex = 0;
        bannedPatterns = []; // Réinitialiser les motifs interdits après un gain

        lastHistoryItem.result = 'Succès';
        successes++;
        points += 10;
        progressPercentage = Math.min(progressPercentage + 1, 100);

        // Désactiver le mode forcé si actif
        if (isForceModeActive) {
            isForceModeActive = false;
            document.getElementById('forceModeAlert').style.display = 'none';
            document.getElementById('redStats').classList.remove('force-mode-active');
            document.getElementById('greenStats').classList.remove('force-mode-active');
            
            Swal.fire({
                title: 'Mode Forcé Désactivé',
                text: 'Un gain a été enregistré, retour au mode normal.',
                icon: 'success',
                timer: 2000
            });
        }

        Swal.fire({
            title: 'Gagné! 🎉',
            html: `
                <div style="font-size: 3rem;">💰</div>
                <p><strong>+${profit.toFixed(2)} R</strong> (${odds}%)</p>
                <hr>
                <p>Bankroll: <strong>${currentBankroll.toFixed(2)} R</strong></p>
                <p>Prochaine mise: <strong>${nextBet.toFixed(2)} R</strong></p>
                <p style="color:#28a745">+10 points</p>
                <div style="margin-top: 15px; background: #e9ecef; height: 20px; border-radius: 10px; overflow: hidden;">
                    <div style="width: ${progressPercentage}%; background: linear-gradient(90deg, #28a745 0%, #5cb85c 100%); height: 100%; transition: width 0.5s ease;"></div>
                </div>
                <p style="margin-top: 5px; font-size: 0.9em;">Progression: ${progressPercentage}%</p>
            `,
            icon: 'success',
            background: 'linear-gradient(135deg, #f0f9f0 0%, #e6f7e6 100%)',
            showClass: {
                popup: 'animate__animated animate__bounceIn'
            }
        });
    } else {
        // Traitement perte
        currentBankroll = parseFloat((currentBankroll - currentBet).toFixed(2));
        consecutiveLosses++;
        currentMartingaleIndex = Math.min(currentMartingaleIndex + 1, martingaleSequence.length - 1);

        // Gestion des interdictions progressives
        bannedPatterns = ['RRR','VVV'];
        //if (consecutiveLosses >= 3) bannedPatterns.push('VVR','RRV');//

        lastHistoryItem.result = 'Échec';
        failures++;

        let warningMessage = '';
        if (consecutiveLosses >= 3) {
            warningMessage = `
                <div style="background:#ffebee;padding:10px;border-radius:5px;margin:10px 0;">
                    <p style="color:#d32f2f">🚨 3 pertes consécutives - Pause recommandée</p>
                    <p>Évitez: RRR, VVV, VVR, RRV</p>
                </div>
            `;
        } else if (consecutiveLosses >= 1) {
            warningMessage = `
                <p style="color:#fb8c00">⚠️ ${consecutiveLosses} perte(s) consécutive(s)</p>
                <p>Évitez: RRR, VVV</p>
            `;
        }

        // Activer le mode forcé après 2 pertes consécutives
        if (consecutiveLosses >= 2 && !isForceModeActive) {
            isForceModeActive = true;
            
            // Déterminer la couleur à forcer (meilleur taux de réussite)
            const redTotal = redSuccesses + redFailures;
            const greenTotal = greenSuccesses + greenFailures;
            
            const redRate = redTotal > 0 ? redSuccesses / redTotal : 0;
            const greenRate = greenTotal > 0 ? greenSuccesses / greenTotal : 0;
            
            forcedColor = redRate >= greenRate ? 'rouge' : 'vert';
            
            // Mettre à jour l'interface
            document.getElementById('forceModeAlert').style.display = 'block';
            document.getElementById('forcedColorText').textContent = forcedColor;
            document.getElementById('forcedColorText').style.color = forcedColor === 'rouge' ? '#dc3545' : '#28a745';
            
            if (forcedColor === 'rouge') {
                document.getElementById('redStats').classList.add('force-mode-active');
            } else {
                document.getElementById('greenStats').classList.add('force-mode-active');
            }
            
            warningMessage += `
                <div style="margin-top:10px; background:#fff3cd; padding:10px; border-radius:5px;">
                    <p style="color:#856404;">⚠️ Mode forcé activé: Prochaines prédictions sur <strong>${forcedColor}</strong></p>
                </div>
            `;
        }
        
         
        Swal.fire({
            title: 'Perdu ❌',
            html: `
                <div style="font-size: 2rem;">📉</div>
                <p><strong>-${currentBet.toFixed(2)} R</strong></p>
                <hr>
                <p>Bankroll: <strong>${currentBankroll.toFixed(2)} R</strong></p>
                <p>Prochaine mise: <strong>${nextBet.toFixed(2)} R</strong></p>
                <div style="margin-top: 15px; background: #e9ecef; height: 20px; border-radius: 10px; overflow: hidden;">
                    <div style="width: ${progressPercentage}%; background: linear-gradient(90deg, #6c757d 0%, #adb5bd 100%); height: 100%;"></div>
                </div>
                <p style="margin-top: 5px; font-size: 0.9em;">Progression: ${progressPercentage}% (inchangé)</p>
                ${warningMessage}
            `,
            icon: 'error',
            background: 'linear-gradient(135deg, #fff0f0 0%, #ffe6e6 100%)',
            showClass: {
                popup: 'animate__animated animate__headShake'
            }
        });
    Swal.fire({
        title: '🚨 ALERTE STRATÉGIE ANTI-PERDANTE 🚨',
        html: `
            <div style="text-align:left; font-size:16px; color:#333; background:#fff8e1; padding:15px; border-radius:10px; border-left:5px solid #ffc107;">
                <p><strong>🔥 LA MÉTHODE "STRIKE BACK" (Même pour les débutants) :</strong></p>
                
                <div style="margin:10px 0; padding:10px; background:#ffebee; border-radius:5px;">
                    <p>1️⃣ <strong>OBSERVEZ</strong> tant que le bot <span style="color:#28a745;">gagne</span> ✅</p>
                    <p>2️⃣ <strong>INTERVENEZ SEULEMENT</strong> quand le bot <span style="color:#dc3545;">perd</span> ❌</p>
                    <p>3️⃣ <strong>MISEZ L'INVERSE</strong> de sa prédiction (Il dit Rouge ? Vous misez Vert 🟢)</p>
                </div>
                
                <p style="color:#d32f2f; font-weight:bold;">📉 POURQUOI ÇA MARCHE À TOUS LES COUPS :</p>
                <ul style="padding-left:20px;">
                    <li>Vous <strong>évitez 90% des pertes</strong> en ne suivant pas le bot aveuglément</li>
                    <li>Vous <strong>exploitez ses failles</strong> quand il montre des signes de faiblesse</li>
                    <li>Vos gains <strong>compensent toujours</strong> vos pertes</li>
                </ul>
                
                <div style="margin-top:15px; padding:10px; background:#e8f5e9; border-radius:5px; border-left:5px solid #4caf50;">
                    <p>💎 <strong>EXEMPLE CONCRET :</strong></p>
                    <p>Bot perd (disait Rouge ❌) → Vous misez Vert 🟢 → Vous gagnez ✅ → Vous stoppez et observez</p>
                    <p>Bot regagne → Vous le suivez à nouveau</p>
                </div>
                
                <p style="margin-top:15px; font-weight:bold; color:#ff5722;">⚠️ LA SEULE RÈGLE : DISCIPLINE TOTALE ! Pas d'émotion, pas de "je tente quand même"</p>
            </div>
        `,
        width: '750px',
        background: '#fff',
        confirmButtonText: 'J\'AI COMPRIS, GO ! 💪',
        confirmButtonColor: '#ff5722',
        customClass: {
            container: 'animate__animated animate__fadeInDown'
        }
    });
}

    // Mise à jour de l'interface
    updateBankrollDisplay();
    updateMartingaleDisplay();
    updateHistory();
    updateSuccessRate();
    updatePoints();
    updateLevelButtons();
    updatePieChart();
    updateColorStatsDisplay(); // Mettre à jour les stats par couleur
    saveHistoryToLocalStorage();
    
    // Réinitialisation des champs
    document.getElementById('seriesInput').value = '';
    document.getElementById('colorPercentage').value = '';
    document.getElementById('predictionResult').textContent = '';
}
function checkPredictionRestrictions(colorSeries) {
    const lastThree = colorSeries.slice(-3); // Récupère les 3 dernières couleurs
    const redCount = (colorSeries.match(/R/g) || []).length;
    const greenCount = (colorSeries.match(/V/g) || []).length;
    
    // 1. Vérification permanente (valable en tout temps) - RVR et VRV
    if (lastThree === 'RVR' || lastThree === 'VRV') {
        Swal.fire({
            title: 'PRÉDICTION INTERDITE ⛔',
            html: `
                <div style="font-size: 2rem;">🚨</div>
                <p>La séquence <strong>${lastThree}</strong> est strictement interdite.</p>
                <p>Motif : Tendance trop volatile et imprévisible.</p>
                <p style="color: #dc3545;">Veuillez attendre le prochain tour.</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#dc3545'
        });
        return false;
    }

    // 2. Vérification des ratios interdits (6R/4V et 6V/4R)
   /* if ((redCount === 6 && greenCount === 4) || (redCount === 4 && greenCount === 6)) {
        Swal.fire({
            title: 'RATIO INTERDIT ⛔',
            html: `
                <div style="font-size: 2rem;">🚫</div>
                <p>Le ratio <strong>${redCount}R/${greenCount}V</strong> est interdit.</p>
                <p>Motif : Ces ratios montrent une instabilité statistique trop importante.</p>
                <p style="color: #dc3545;">Veuillez entrer une nouvelle séquence.</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#dc3545'
        });
        return false;
    }*/

    // 3. Vérification des motifs bloqués après une perte (s'applique même en mode forcé)
    if (bannedPatterns.includes(lastThree)) {
        Swal.fire({
            title: 'PRÉDICTION TEMPORAIREMENT BLOQUÉE ⚠️',
            html: `
                <div style="font-size: 2rem;">🔒</div>
                <p>La séquence <strong>${lastThree}</strong> est temporairement bloquée.</p>
                <p>Motif : Cette séquence a récemment entraîné une perte.</p>
                <p style="color: #ffc107;">Attendez un gain pour débloquer ce motif.</p>
                ${consecutiveLosses >= 3 ? `<p style="margin-top:10px;">🚨 Vous avez ${consecutiveLosses} pertes consécutives - Soyez prudent!</p>` : ''}
            `,
            icon: 'warning',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#ffc107',
            background: '#fff3cd'
        });
        return false;
    }

    return true; // Tout est OK - Aucune restriction ne s'applique
}
// Fonction pour analyser les raisons de l'échec (exemple)
function analyzeLossReason(colorInput, prediction, result) {
    const colors = colorInput.split('');
    const lastThree = colors.slice(-3).join('');
    
    if (failedPatterns[lastThree] && failedPatterns[lastThree] === prediction) {
        return "Ce motif avait déjà échoué avec la même prédiction.";
    }
    
    const redCount = colors.filter(c => c === 'R').length;
    const greenCount = colors.filter(c => c === 'V').length;
    
    if ((redCount > greenCount && prediction === 'vert') || 
        (greenCount > redCount && prediction === 'rouge')) {
        return "La prédiction allait à l'encontre de la tendance dominante.";
    }
    
    return "Fluctuation aléatoire du marché.";
}

// Fonction pour obtenir des conseils (exemple)
function getLossAdvice(reason) {
   
    if (reason.includes("tendance dominante")) {
        return "Suivez la tendance dominante dans vos prochaines prédictions.";
    }
    return "Maintenez votre stratégie, ce type de perte est statistiquement normal.";
}
let progress = 0;
const progressMessages = {
    20: "20% atteint - Prenez une pause de 20 minutes avant de continuer",
    40: "40% atteint - Prenez une pause de 20 minutes avant de continuer",
    60: "60% atteint - Prenez une pause de 20 minutes avant de continuer",
    80: "80% atteint - Prenez une pause de 20 minutes avant de continuer",
    100: "Félicitations ! Vous avez tué le boss ! Vous pouvez maintenant changer de niveau"
};
           function updateProgressBar(change) {
            const progressBarFill = document.getElementById('progressBarFill');
            const progressPercentage = document.getElementById('progressPercentage');
            let currentWidth = parseInt(progressBarFill.style.width);
            let newWidth = currentWidth + change;

            if (newWidth < 0) newWidth = 0;
            if (newWidth > 100) newWidth = 100;

            progressBarFill.style.width = newWidth + '%';
            progressPercentage.textContent = newWidth + '%';

            if (newWidth >= 1 && newWidth <= 25) {
                progressBarFill.style.backgroundColor = 'red';
            } else if (newWidth >= 26 && newWidth <= 45) {
                progressBarFill.style.backgroundColor = 'yellow';
            } else if (newWidth >= 46 && newWidth <= 76) {
                progressBarFill.style.backgroundColor = 'blue';
            } else if (newWidth >= 77 && newWidth <= 100) {
                progressBarFill.style.backgroundColor = 'green';
            } else {
                progressBarFill.style.backgroundColor = '#4caf50';
                localStorage.setItem('gameProgress', progress);
                checkProgressMilestones();
            }
        }
        function checkProgressMilestones() {
    // Vérifier si on a atteint un palier important
    if (progressMessages[progress]) {
        showProgressAlert(progress);
    }
}
function showProgressAlert(percentage) {
    const message = progressMessages[percentage];
    const isFinal = percentage === 100;
    
    Swal.fire({
        title: isFinal ? '🎉 Félicitations !' : '⏱️ Pause recommandée',
        html: message,
        icon: isFinal ? 'success' : 'info',
        confirmButtonText: 'Compris',
        confirmButtonColor: isFinal ? '#28a745' : '#007bff',
        willClose: () => {
            if (isFinal) {
                // Proposer de changer de niveau
                showLevelUpPopup();
            } else {
                // Démarrer le minuteur de pause
                startTimer(20);
            }
        }
    });
}

function showLevelUpPopup() {
    Swal.fire({
        title: 'Changement de niveau disponible',
        html: 'Vous avez tué le boss de ce niveau ! Souhaitez-vous passer au niveau suivant ?',
        icon: 'question',
        showCancelButton: true,
        confirmButtonText: 'Oui, niveau suivant',
        cancelButtonText: 'Non, rester ici',
        confirmButtonColor: '#28a745',
        cancelButtonColor: '#dc3545'
    }).then((result) => {
        if (result.isConfirmed) {
            // Logique pour passer au niveau suivant
            advanceToNextLevel();
        }
    });
}

function advanceToNextLevel() {
    const currentLevel = localStorage.getItem('userLevel') || 'débutant';
    let nextLevel = '';
    
    switch(currentLevel) {
        case 'débutant': nextLevel = 'intermédiaire'; break;
        case 'intermédiaire': nextLevel = 'avancé'; break;
        case 'avancé': nextLevel = 'expert'; break;
        default: nextLevel = 'intermédiaire';
    }
    
    localStorage.setItem('userLevel', nextLevel);
    document.getElementById('userLevelSpan').textContent = nextLevel;
    
    // Réinitialiser la progression pour le nouveau niveau
    progress = 0;
    localStorage.setItem('gameProgress', progress);
    document.getElementById('progressBarFill').style.width = '0%';
    document.getElementById('progressPercentage').textContent = '0%';
    
    Swal.fire({
        title: 'Niveau supérieur débloqué !',
        html: `Vous êtes maintenant niveau <strong>${nextLevel}</strong>`,
        icon: 'success'
    });
}

// Au chargement de la page, charger la progression sauvegardée
document.addEventListener('DOMContentLoaded', () => {
    // 1. Chargement de la progression du jeu
    const savedProgress = localStorage.getItem('gameProgress');
    if (savedProgress) {
        progress = parseInt(savedProgress);
        document.getElementById('progressBarFill').style.width = progress + '%';
        document.getElementById('progressPercentage').textContent = progress + '%';
    }

    // 2. Initialisation des statistiques par couleur
    const savedRedStats = localStorage.getItem('redStats');
    const savedGreenStats = localStorage.getItem('greenStats');
    
    if (savedRedStats) {
        const redStats = JSON.parse(savedRedStats);
        redSuccesses = redStats.successes || 0;
        redFailures = redStats.failures || 0;
    }
    
    if (savedGreenStats) {
        const greenStats = JSON.parse(savedGreenStats);
        greenSuccesses = greenStats.successes || 0;
        greenFailures = greenStats.failures || 0;
    }

    // 3. Chargement de l'état du mode forcé
    const savedForceMode = localStorage.getItem('forceMode');
    if (savedForceMode) {
        const forceModeData = JSON.parse(savedForceMode);
        isForceModeActive = forceModeData.isActive || false;
        forcedColor = forceModeData.color || '';
        consecutiveLosses = forceModeData.consecutiveLosses || 0;
        
        if (isForceModeActive) {
            document.getElementById('forceModeAlert').style.display = 'block';
            document.getElementById('forcedColorText').textContent = forcedColor;
            document.getElementById('forcedColorText').style.color = forcedColor === 'rouge' ? '#dc3545' : '#28a745';
            
            if (forcedColor === 'rouge') {
                document.getElementById('redStats').classList.add('force-mode-active');
            } else {
                document.getElementById('greenStats').classList.add('force-mode-active');
            }
        }
    }

    // 4. Mise à jour initiale de l'interface
    updateColorStatsDisplay();
    updateBankrollDisplay();
    updateMartingaleDisplay();
    updateHistory();
    updateSuccessRate();
    updatePoints();
    updateLevelButtons();
    updatePieChart();
    
    // 5. Vérification du tutoriel
    if (!localStorage.getItem('hideTutorial')) {
        showTutorial();
    }
});

// Nouvelle fonction pour sauvegarder les stats par couleur
function saveColorStats() {
    localStorage.setItem('redStats', JSON.stringify({
        successes: redSuccesses,
        failures: redFailures
    }));
    
    localStorage.setItem('greenStats', JSON.stringify({
        successes: greenSuccesses,
        failures: greenFailures
    }));
}

// Nouvelle fonction pour sauvegarder l'état du mode forcé
function saveForceModeState() {
    localStorage.setItem('forceMode', JSON.stringify({
        isActive: isForceModeActive,
        color: forcedColor,
        consecutiveLosses: consecutiveLosses
    }));
}

// Modifier la fonction saveHistoryToLocalStorage() pour inclure les nouvelles données
function saveHistoryToLocalStorage() {
    localStorage.setItem('predictionHistory', JSON.stringify(history));
    saveColorStats();
    saveForceModeState();
    localStorage.setItem('gameProgress', progress);
}
function analyzeAllLosses() {
    const losses = history.filter(record => record.result === 'Échec'); // Filtrer les pertes
    if (losses.length === 0) {
        Swal.fire({
            title: 'Aucune Perte Trouvée ✅',
            text: 'Félicitations ! Vous n\'avez subi aucune perte jusqu\'à présent.',
            icon: 'success',
            confirmButtonText: 'Continuer',
        });
        return;
    }

    let analysisReport = "<h3>Analyse des Pertes</h3><ul>";
    losses.forEach((loss, index) => {
        const lossReason = analyzeLossReason(loss.colors, loss.prediction, loss.result);
        analysisReport += `
            <li>
                <strong>Trade ${loss.tradeNumber} :</strong>
                <p>Prédiction : ${loss.prediction}</p>
                <p>Couleurs : ${loss.colors}</p>
                <p>Raison de la perte : ${lossReason}</p>
                <p>Conseil : ${getLossAdvice(lossReason)}</p>
            </li>
        `;
    });
    analysisReport += "</ul>";

    Swal.fire({
        title: 'Rapport d\'Analyse des Pertes 📊',
        html: analysisReport,
        icon: 'info',
        confirmButtonText: 'Compris',
        width: '800px',
    });
}
function updateHistory() {
    const historyElement = document.getElementById('history');
    
    // Créer un fragment de document pour une meilleure performance
    const fragment = document.createDocumentFragment();
    
    // Créer l'en-tête du tableau
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `
        <th style="background-color:#f0f0f0; text-align: center;">N°</th>
        <th style="background-color:#f0f0f0; text-align: center;">Date</th>
        <th style="background-color:#f0f0f0; text-align: center;">Couleurs</th>
        <th style="background-color:#f0f0f0; text-align: center;">Prédiction</th>
        <th style="background-color:#f0f0f0; text-align: center;">Pourcentage</th>
        <th style="background-color:#f0f0f0; text-align: center;">Résultat</th>
    `;
    fragment.appendChild(headerRow);

    // Parcourir l'historique en commençant par le plus récent
    history.slice().reverse().forEach((record, index) => {
        const tr = document.createElement('tr');
        
        // Mise en forme conditionnelle basée sur le résultat
        const resultClass = record.result === 'Succès' ? 'success-row' : 
                          record.result === 'Échec' ? 'failure-row' : 'pending-row';
        
        tr.className = resultClass;
        
        // Formatage du texte de prédiction
        const predictionText = record.modified ? 
                             `${record.prediction} (modifié)` : 
                             record.prediction;
        
        // Formatage de la date
        const formattedDate = formatDate(record.date);
        
        tr.innerHTML = `
            <td style="text-align: center;">${history.length - index}</td>
            <td style="text-align: center;">${formattedDate}</td>
            <td>${formatColors(record.colors)}</td>
          <td style="text-align: center; font-size: 20px;">${record.prediction === 'rouge' ? '🔴' : '🟢'}</td>
            <td style="text-align: center;">${record.frequentColor}</td>
            <td style="text-align: center;">${formatResult(record.result)}</td>
        `;
        
        fragment.appendChild(tr);
    });

    // Effacer et reconstruire le tableau
    historyElement.innerHTML = '';
    historyElement.appendChild(fragment);
    
    // Sauvegarder et mettre à jour les stats
    saveHistoryToLocalStorage();
    updateStats();
    
    // Ajouter un effet visuel pour la dernière entrée
    highlightLatestEntry();
}

// Fonctions helper
function formatDate(dateString) {
    if (!dateString) return 'N/A';
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    return new Date(dateString).toLocaleDateString('fr-FR', options);
}

function formatColors(colors) {
    return colors.split(',').map(c => {
        const color = c.trim();
        return color === 'rouge' ? `<span class="red-dot">🔴</span>` : 
               color === 'vert' ? `<span class="green-dot">🟢</span>` : color;
    }).join(' ');
}

function formatResult(result) {
    if (!result) return 'En attente';
    return result === 'Succès' ? `<span class="success-result">✅ ${result}</span>` :
           `<span class="failure-result">❌ ${result}</span>`;
}

function highlightLatestEntry() {
    const rows = document.querySelectorAll('#history tr');
    if (rows.length > 1) { // Skip header row
        rows[1].classList.add('latest-entry');
    }
}    
           function clearHistory() {
            previousHistory = [...history];
            history = [];
            successes = 0;
            failures = 0;
            points = 0;
            updateHistory();
            updateSuccessRate();
            updateStats();
            updatePoints();
            updateProgressBar(-100);
            enableFeedbackButtons();
            updatePieChart(); // Mettre à jour le diagramme
            Swal.fire({
            title: 'Succès ! 🎉',
            text: 'Historique effacé avec succès !',
            icon: 'success',
            confirmButtonText: 'Continuer',
            confirmButtonColor: '#28a745',
             background: '#f0f9f0',
             iconColor: '#28a745',
             });
        }

        function undo() {
    if (previousHistory.length === 0) {
        Swal.fire({
        title: 'Information ℹ️',
        text: 'Aucune action à restaurer.',
        icon: 'info',
        confirmButtonText: 'Compris',
        confirmButtonColor: '#007bff',
        background: '#f0f8ff',
        iconColor: '#007bff',
        showClass: {
        popup: 'animate__animated animate__fadeIn'
        },
        hideClass: {
        popup: 'animate__animated animate__fadeOut'
        }
        });
        return;
        }

    // Restaurer l'historique précédent
    history = [...previousHistory];

    // Recalculer les réussites, les échecs et les points à partir de l'historique restauré
    successes = 0;
    failures = 0;
    points = 0;

    history.forEach(record => {
        if (record.result === 'Succès') {
            successes += 1;
            points += 10;
        } else if (record.result === 'Échec') {
            failures += 1;
        }
    });

    // Mettre à jour l'interface utilisateur
    updateHistory();
    updateSuccessRate();
    updatePoints();
    updateProgressBar(successes);
    updatePieChart(); // Mettre à jour le diagramme

    // Effacer les champs de saisie
    document.getElementById('colorInput').value = '';
    document.getElementById('seriesInput').value = '';
    document.getElementById('colorPercentage').value = '';
    document.getElementById('predictionResult').textContent = '';
    document.getElementById('previousResult').textContent = '';

    // Réactiver les boutons de feedback
    enableFeedbackButtons();

    Swal.fire({
  title: 'Succès ! 🎉',
  text: 'Historique restauré avec succès !',
  icon: 'success',
  confirmButtonText: 'Continuer',
  confirmButtonColor: '#28a745',
  background: '#f0f9f0',
  iconColor: '#28a745',
});
}

function undoLastPrediction() {
    if (history.length === 0) {
        Swal.fire({
            title: 'Information ℹ️',
            text: 'Aucune prédiction à annuler.',
            icon: 'info',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#007bff',
            background: '#f0f8ff',
            iconColor: '#007bff',
            showClass: {
                popup: 'animate__animated animate__fadeIn'
            },
            hideClass: {
                popup: 'animate__animated animate__fadeOut'
            }
        });
        return;
    }

    // Supprimer la dernière prédiction de l'historique
    const lastPrediction = history.pop();

    // Mettre à jour les statistiques si nécessaire
    if (lastPrediction.result === 'Succès') {
        successes -= 1;
        points -= 10;
    } else if (lastPrediction.result === 'Échec') {
        failures -= 1;
    }

    // Mettre à jour l'interface utilisateur
    updateHistory();
    updateSuccessRate();
    updatePoints();
    updateProgressBar(-1); // Ajuster la barre de progression si nécessaire
    updatePieChart(); // Mettre à jour le diagramme

    Swal.fire({
        title: 'Succès ! 🎉',
        text: 'Dernière prédiction annulée avec succès !',
        icon: 'success',
        confirmButtonText: 'Continuer',
        confirmButtonColor: '#28a745',
        background: '#f0f9f0',
        iconColor: '#28a745',
    });
}
        function updateSuccessRate() {
            const successRate = (successes / (successes + failures)) * 100;
            document.getElementById('successRate').textContent = `Taux de réussite : ${successRate.toFixed(2)}%`;
        }

        function updatePoints() {
            document.getElementById('points').textContent = `Points : ${points}`;
            localStorage.setItem('totalPoints', points);
        }

        function saveHistoryToLocalStorage() {
            localStorage.setItem('predictionHistory', JSON.stringify(history));
        }

        function loadHistoryFromLocalStorage() {
            const storedHistory = localStorage.getItem('predictionHistory');
            if (storedHistory) {
                history = JSON.parse(storedHistory);
                updateHistory();
                updateSuccessRate();
                updateStats();
                updatePoints();
            }
        }

        function updateStats() {
            document.getElementById('successRate').textContent = `Taux de réussite : ${(successes / (successes + failures) * 100).toFixed(2)}%`;
            document.getElementById('totalPredictions').textContent = `Total des Prédictions : ${history.length}`;
            document.getElementById('totalSuccesses').textContent = `Total des Réussites : ${successes}`;
            document.getElementById('totalFailures').textContent = `Total des Pertes : ${failures}`;
        }
        let pieChart;

function createPieChart() {
    const ctx = document.getElementById('pieChart').getContext('2d');
    pieChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: ['Réussites', 'Pertes'],
            datasets: [{
                data: [successes, failures],
                backgroundColor: ['#28a745', '#dc3545'],
                borderColor: ['#218838', '#c82333'],
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                },
                tooltip: {
                    enabled: true
                }
            }
        }
    });
}

function updatePieChart() {
    if (pieChart) {
        pieChart.data.datasets[0].data = [successes, failures];
        pieChart.update();
    } else {
        createPieChart();
    }
}

        function enableFeedbackButtons() {
            document.getElementById('btnSuccess').disabled = false;
            document.getElementById('btnFailure').disabled = false;
        }

        function showOverlay() {
            document.getElementById('overlay').style.display = 'flex';
            document.querySelectorAll('button').forEach(button => button.disabled = true);
            document.getElementById('predictButton').disabled = true;
        }

        function hideOverlay() {
            document.getElementById('overlay').style.display = 'none';
            document.querySelectorAll('button').forEach(button => button.disabled = false);
        }

        function copyHistory() {
            const historyText = history.map(record => `${record.date} - ${record.colors} - ${record.prediction} - ${record.frequentColor} - ${record.result}`).join('\n');
            const el = document.createElement('textarea');
            el.value = historyText;
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            Swal.fire({
  title: 'Succès ! 📋',
  text: 'Historique copié dans le presse-papiers !',
  icon: 'success',
  confirmButtonText: 'Continuer',
  confirmButtonColor: '#28a745',
  background: '#f0f9f0',
  iconColor: '#28a745',
});
        }

        function exportHistory() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();

    const historyText = history.map((record, index) => 
        `${index + 1}. Date : ${record.date}, Couleurs : ${record.colors}, Prédiction : ${record.prediction}, Pourcentage de Couleur : ${record.frequentColor}, Résultat : ${record.result}`).join('\n\n');

    doc.text(historyText, 10, 10);
    doc.save('historique.pdf');
        }

        function showTutorial() {
    Swal.fire({
        title: 'Bienvenue sur Signal Bot 97 TRX ! 🤖',
        html: `
            <p>Pour maximiser vos profits, suivez ces étapes :</p>
            <ol>
                <li>Entrez une série de <strong>10 couleurs</strong> (rouge ou vert).</li>
                <li>Le bot analysera les tendances et appliquera les règles de prédiction pour optimiser vos gains.</li>
                <li>Suivez les instructions du bot pour miser intelligemment.</li>
            </ol>
            <p><strong>Conseils :</strong></p>
            <ul>
                <li>Restez calme et suivez la stratégie.</li>
                <li>Ne misez pas plus que ce que vous pouvez vous permettre de perdre.</li>
                <li>Gardez un œil sur les tendances et ajustez vos mises si nécessaire.</li>
            </ul>
            <p><strong>Bonne chance et que les gains soient avec vous !</strong> 🚀</p>
            <br>
            <label>
                <input type="checkbox" id="hideTutorial"> Ne plus afficher ce message
            </label>
        `,
        icon: 'info',
        confirmButtonText: 'Commencer',
        confirmButtonColor: '#007bff',
        background: '#f0f8ff',
        iconColor: '#007bff',
        showClass: {
            popup: 'animate__animated animate__fadeIn'
        },
        hideClass: {
            popup: 'animate__animated animate__fadeOut'
        },
        didOpen: () => {
            const hideTutorialCheckbox = document.getElementById('hideTutorial');
            hideTutorialCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    localStorage.setItem('hideTutorial', true);
                } else {
                    localStorage.removeItem('hideTutorial');
                }
            });
        }
    }).then(() => {
        // Afficher la popup stratégie après fermeture du tutoriel
        showStrategyPopup();
    });
}



        function showLevelPopup() {
            const savedLevel = localStorage.getItem('userLevel');
            if (!savedLevel) {
                document.getElementById('levelPopup').style.display = 'block';
            } else {
                document.getElementById('userLevelSpan').textContent = `${savedLevel}`;
            }
        }

        function confirmLevel() {
    const selectedLevel = document.querySelector('input[name="level"]:checked').value;
    localStorage.setItem('userLevel', selectedLevel);
    document.getElementById('userLevelSpan').textContent = selectedLevel.charAt(0).toUpperCase() + selectedLevel.slice(1);
    document.getElementById('levelPopup').style.display = 'none';
    
    Swal.fire({
        title: 'Niveau changé !',
        text: `Vous êtes maintenant niveau ${selectedLevel}`,
        icon: 'success'
    });
}

        function showLevelInfo() {
            document.getElementById('levelInfoPopup').style.display = 'block';
            document.getElementById('currentPoints').textContent = `Points actuels : ${points}`;
        }

        function hideLevelInfo() {
            document.getElementById('levelInfoPopup').style.display = 'none';
        }

        function updateLevelButtons() {
    const intermediateButton = document.querySelector('input[value="intermédiaire"]');
    const advancedButton = document.querySelector('input[value="avancé"]');
    
    // Débloque TOUJOURS les boutons, quel que soit le nombre de points
    intermediateButton.disabled = false;
    advancedButton.disabled = false;
    
    // Optionnel : supprime aussi l'apparence visuelle "désactivé"
    intermediateButton.classList.remove('disabled');
    advancedButton.classList.remove('disabled');
}
        document.addEventListener('DOMContentLoaded', () => {
    loadHistoryFromLocalStorage();
    loadStatsFromLocalStorage();
    validateUserName();
    showLevelPopup();
    updateLevelButtons();
    showNotificationPopup();
    checkConsecutiveLosses();
    
    // Gestion unique de l'affichage du tutoriel
    if (!localStorage.getItem('hideTutorial')) {
        showTutorial();
    } else {
        // Si l'utilisateur a choisi de masquer le tutoriel
        document.querySelectorAll('button').forEach(btn => btn.disabled = false);
    }
});

// Gestion de l'input pour les séries de couleurs
document.getElementById('seriesInput').addEventListener('input', function (e) {
    const originalValue = this.value;
    // Convertir en majuscules et ne garder que R ou V
    this.value = this.value.toUpperCase().replace(/[^RV]/g, '');

    // Limiter à 10 caractères
    if (this.value.length > 10) {
        this.value = this.value.slice(0, 10);
    }

    // Si la valeur a changé, afficher une alerte
    if (originalValue !== this.value) {
        Swal.fire({
            title: 'Caractère non autorisé ⚠️',
            text: 'Veuillez entrer uniquement "R" ou "V" (max 10 caractères).',
            icon: 'warning',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#ffc107',
            background: '#fff3cd',
            iconColor: '#ffc107',
        });
    }
});
     function findMostSimilarPattern(inputPattern) {
    let mostSimilarPattern = '';
    let highestSimilarity = 0;

    // Parcourir tous les motifs existants
    for (const pattern in patterns) {
        let similarity = 0;
        for (let i = 0; i < inputPattern.length; i++) {
            if (inputPattern[i] === pattern[i]) {
                similarity++;
            }
        }
        // Si ce motif est plus similaire que le précédent, on le garde
        if (similarity > highestSimilarity) {
            highestSimilarity = similarity;
            mostSimilarPattern = pattern;
        }
    }

    return mostSimilarPattern;
}
function predictBasedOnSimilarity(inputPattern) {
    const mostSimilarPattern = findMostSimilarPattern(inputPattern);
    if (mostSimilarPattern) {
        return patterns[mostSimilarPattern]; // Retourne la prédiction associée au motif le plus similaire
    } else {
        return predictBasedOnTrends(inputPattern); // Si aucun motif similaire n'est trouvé, utilise la prédiction basée sur les tendances
    }
}

function predictBasedOnTrends(colorInput) {
    const lastThreeColors = colorInput.slice(-3); // Prend les 3 dernières couleurs
    const colorCount = lastThreeColors.split('').reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    // Si une couleur domine dans les 3 dernières, prédire cette couleur
    if (colorCount['R'] > colorCount['V']) {
        return 'rouge';
    } else if (colorCount['V'] > colorCount['R']) {
        return 'vert';
    } else {
        // Si égalité, prédire en fonction du pourcentage global
        const globalRed = (colorInput.split('R').length - 1) * 10;
        const globalGreen = (colorInput.split('V').length - 1) * 10;
        return globalRed >= globalGreen ? 'rouge' : 'vert';
    }
}
function isSimpleAlternate(colors) {
    for (let i = 1; i < colors.length; i++) {
        if (colors[i] === colors[i - 1]) {
            return false;
        }
    }
    return true;
}

function isSimpleDoubleAlternate(colors) {
    for (let i = 2; i < colors.length; i += 2) {
        if (colors[i] !== colors[i - 1] || colors[i] === colors[i - 2]) {
            return false;
        }
    }
    return true;
}
function isSimpleTripleAlternate(colors) {
    for (let i = 3; i < colors.length; i += 3) {
        // Vérifie si les 3 couleurs suivantes sont identiques aux 3 précédentes
        if (colors[i] !== colors[i - 1] || colors[i] !== colors[i - 2] || colors[i] === colors[i - 3]) {
            return false;
        }
    }
    return true;
}
function predictBasedOnTrend(colorInput) {
    const colors = colorInput.split('');

    if (isSimpleAlternate(colors)) {
        return colors[colors.length - 1] === 'R' ? 'vert' : 'rouge';
    } else if (isSimpleDoubleAlternate(colors)) {
        return colors[colors.length - 1] === 'R' ? 'vert' : 'rouge';
    } else if (isSimpleTripleAlternate(colors)) {
        return colors[colors.length - 1] === 'R' ? 'vert' : 'rouge';
    } else {
        return predictBasedOnTrends(colorInput); // Utilise la fonction existante
    }
}
function checkColorRatioBan(colorInput) {
    const redCount = (colorInput.match(/R/g) || []).length;
    const greenCount = (colorInput.match(/V/g) || []).length;
    
    // Bloquer les ratios 6R/4V et 6V/4R
    if ((redCount === 6 && greenCount === 4) || (redCount === 4 && greenCount === 6)) {
        return true; // Ratio banni
    }
    return false; // Ratio acceptable
}
// Fonction pour calculer les statistiques par couleur
function calculateColorStats() {
    // Réinitialiser les compteurs
    redSuccesses = 0;
    redFailures = 0;
    greenSuccesses = 0;
    greenFailures = 0;

    // Parcourir l'historique pour compter les succès/échecs par couleur
    history.forEach(record => {
        if (record.result === 'Succès' || record.result === 'Échec') {
            if (record.prediction === 'rouge') {
                if (record.result === 'Succès') redSuccesses++;
                else redFailures++;
            } else if (record.prediction === 'vert') {
                if (record.result === 'Succès') greenSuccesses++;
                else greenFailures++;
            }
        }
    });

    // Mettre à jour l'affichage
    updateColorStatsDisplay();
    
    // Vérifier si on doit activer le mode forcé
    checkForceMode();
}

// Fonction pour mettre à jour l'affichage des statistiques
function updateColorStatsDisplay() {
    // Calcul des pourcentages
    const redTotal = redSuccesses + redFailures;
    const greenTotal = greenSuccesses + greenFailures;
    
    const redSuccessRate = redTotal > 0 ? (redSuccesses / redTotal * 100).toFixed(1) : 0;
    const greenSuccessRate = greenTotal > 0 ? (greenSuccesses / greenTotal * 100).toFixed(1) : 0;

    // Mise à jour des éléments HTML
    document.getElementById('redSuccessCount').textContent = `${redSuccesses} succès`;
    document.getElementById('redFailureCount').textContent = `${redFailures} échecs`;
    document.getElementById('redSuccessRate').textContent = `${redSuccessRate}% de réussite`;
    
    document.getElementById('greenSuccessCount').textContent = `${greenSuccesses} succès`;
    document.getElementById('greenFailureCount').textContent = `${greenFailures} échecs`;
    document.getElementById('greenSuccessRate').textContent = `${greenSuccessRate}% de réussite`;

    // Ajouter des indicateurs de tendance
    updateTrendIndicators(redSuccessRate, greenSuccessRate);
}

// Fonction pour mettre à jour les indicateurs de tendance
function updateTrendIndicators(redRate, greenRate) {
    const redTrendElement = document.getElementById('redTrend');
    const greenTrendElement = document.getElementById('greenTrend');
    
    // Effacer les anciens indicateurs
    redTrendElement.innerHTML = '';
    greenTrendElement.innerHTML = '';
    
    // Ajouter des indicateurs visuels
    if (redRate > greenRate) {
        redTrendElement.innerHTML = '<span style="color:#28a745">↑ Meilleure performance</span>';
        greenTrendElement.innerHTML = '<span style="color:#6c757d">↘ Plus faible performance</span>';
    } else if (greenRate > redRate) {
        greenTrendElement.innerHTML = '<span style="color:#28a745">↑ Meilleure performance</span>';
        redTrendElement.innerHTML = '<span style="color:#6c757d">↘ Plus faible performance</span>';
    } else {
        redTrendElement.innerHTML = '<span style="color:#6c757d">= Performance égale</span>';
        greenTrendElement.innerHTML = '<span style="color:#6c757d">= Performance égale</span>';
    }
}

// Fonction pour vérifier si on doit activer le mode forcé
function checkForceMode() {
    // Désactiver le mode forcé si on a un gain
    if (history.length > 0 && history[history.length - 1].result === 'Succès') {
        if (isForceModeActive) {
            isForceModeActive = false;
            document.getElementById('forceModeAlert').style.display = 'none';
            document.getElementById('redStats').classList.remove('force-mode-active');
            document.getElementById('greenStats').classList.remove('force-mode-active');
            
            Swal.fire({
                title: 'Mode Forcé Désactivé',
                text: 'Un gain a été enregistré, retour au mode normal.',
                icon: 'success',
                timer: 2000
            });
        }
        return;
    }
    
    // Activer le mode forcé après 2 pertes consécutives
    if (consecutiveLosses >= 2 && !isForceModeActive) {
        isForceModeActive = true;
        
        // Déterminer quelle couleur forcer (celle avec le meilleur taux de réussite)
        const redTotal = redSuccesses + redFailures;
        const greenTotal = greenSuccesses + greenFailures;
        
        const redRate = redTotal > 0 ? redSuccesses / redTotal : 0;
        const greenRate = greenTotal > 0 ? greenSuccesses / greenTotal : 0;
        
        forcedColor = redRate >= greenRate ? 'rouge' : 'vert';
        
        // Mettre à jour l'interface
        document.getElementById('forceModeAlert').style.display = 'block';
        document.getElementById('forcedColorText').textContent = forcedColor;
        document.getElementById('forcedColorText').style.color = forcedColor === 'rouge' ? '#dc3545' : '#28a745';
        
        if (forcedColor === 'rouge') {
            document.getElementById('redStats').classList.add('force-mode-active');
        } else {
            document.getElementById('greenStats').classList.add('force-mode-active');
        }
        
        Swal.fire({
            title: 'Mode Forcé Activé!',
            html: `2 pertes consécutives détectées. Le bot forcera maintenant les prédictions sur <strong style="color:${forcedColor === 'rouge' ? '#dc3545' : '#28a745'}">${forcedColor}</strong> jusqu'au prochain gain.`,
            icon: 'warning',
            confirmButtonText: 'Compris'
        });
    }
}
function predictBasedOnSimilarity(inputPattern) {
    // 1. D'abord essayer avec les motifs connus
    const mostSimilarPattern = findMostSimilarPattern(inputPattern);
    if (mostSimilarPattern && patterns[mostSimilarPattern]) {
        return patterns[mostSimilarPattern];
    }
    
    // 2. Si aucun motif connu, utiliser la règle par défaut
    const lastColor = inputPattern.slice(-1); // Prendre la dernière couleur
    return lastColor === 'R' ? 'rouge' : 'vert';
}
    </script>
</body>
</html>
