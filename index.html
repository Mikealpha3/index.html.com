<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pr√©diction de Couleurs √âlite</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f8ff; /* Fond bleu clair */
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Emp√™cher le d√©filement */
        }
        .container {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            padding: 20px;
            max-width: 800px;
            width: 100%;
            height: 95vh;
            overflow-y: auto; /* Ajouter un d√©filement interne si n√©cessaire */
            position: relative; /* Permettre l'utilisation de la position absolue pour le minuteur */
        }
        h1 {
            color: #5b5b5b;
            text-align: center;
            margin-bottom: 20px;
        }
        label {
            margin: 5px 0;
            font-weight: bold;
            display: inline-block;
            width: 180px; /* Align labels with inputs */
        }
        .action-buttons, .right-buttons {
            display: flex;
            justify-content: flex-start;
            gap: 10px;
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            font-size: 16px;
            margin-right: 10px; /* Ajouter un √©cart entre les boutons */
        }
        .btn-predict {
            background-color: #28a745; /* Vert */
        }
        .btn-predict:hover {
            background-color: #218838;
        }
        .btn-clear {
            background-color: #dc3545; /* Rouge */
        }
        .btn-clear:hover {
            background-color: #c82333;
        }
        .btn-history, .btn-undo {
            background-color: #007bff; /* Bleu */
        }
        .btn-history:hover, .btn-undo:hover {
            background-color: #0056b3;
        }
        .btn-success {
            background-color: #28a745; /* Vert */
        }
        .btn-success:hover {
            background-color: #218838;
        }
        .btn-failure {
            background-color: #dc3545; /* Rouge */
        }
        .btn-failure:hover {
            background-color: #c82333;
        }
        .btn-copy, .btn-export {
            background-color: #ffc107; /* Jaune */
        }
        .btn-copy:hover, .btn-export:hover {
            background-color: #e0a800;
        }
        .color-input {
            padding: 10px;
            border: 2px solid #aaa;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 120px; /* Ajuster la largeur pour plus de visibilit√© */
            text-align: center;
            font-size: 18px;
            color: #444;
            background-color: #fff; /* Couleur de fond blanc */
        }
        .color-input::placeholder {
            color: #888; /* Couleur du placeholder */
        }
        select {
            padding: 10px;
            border: 2px solid #aaa;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 18px;
            width: auto;
            color: #444;
            background-color: #fff; /* Couleur de fond blanc */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 16px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }
        th {
            background-color: #f0f0f0; /* Arri√®re-plan gris clair */
        }
        #historyContainer {
            max-height: 200px;
            overflow-y: auto;
        }
        .highlight {
            background-color: yellow; /* Couleur de surlignage temporaire */
        }
        .feedback-buttons {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        .feedback-buttons button {
            width: 30%; /* Ajuster la largeur des boutons */
        }
        .stats {
            margin-top: 20px;
            font-size: 18px;
            text-align: left;
        }
        .bottom-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin: 20px 0;
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }
        .date-selector {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .undo-button {
            position: relative;
            margin-top: 10px; /* Ajouter de la marge pour positionner au-dessus du tableau */
        }
        .overlay {
            display: none; /* Masquer par d√©faut */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5); /* Fond semi-transparent */
            justify-content: center;
            align-items: center;
            z-index: 9999; /* Par-dessus tout */
        }
        .overlay-message {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5em;
            color: #333;
        }
        .patterns {
            position: absolute;
            right: 20px;
            bottom: 7.5cm; /* Ajuster la hauteur √† 7.5 cm */
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            animation: slideIn 1s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .patterns h3 {
            margin-top: 0;
            color: #333;
        }
        .patterns p {
            margin: 5px 0;
            color: #555;
        }
        /* Style de la barre de d√©filement */
        ::-webkit-scrollbar {
            width: 16px; /* Augmenter la largeur de la barre de d√©filement */
        }
        ::-webkit-scrollbar-track {
            background: #e1e1e1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pr√©diction de Couleurs √âlite</h1>
        <div class="date-selector">
            <label for="dateInput">Date :</label>
            <input type="date" id="dateInput" class="color-input">
        </div>
        <div style="display: flex; align-items: center; gap: 20px;">
            <input type="text" id="colorInput" class="color-input" maxlength="3" oninput="validateInput()" placeholder="Ajouter les Couleurs (ex: RVV)">
        </div>
        <div class="action-buttons">
            <button class="btn-success" onclick="appendColor('R')">R</button>
            <button class="btn-success" onclick="appendColor('V')">V</button>
        </div>
        <div class="action-buttons">
            <button class="btn-predict" onclick="predictColor()" id="predictButton">Pr√©dire</button>
            <button class="btn-clear" onclick="clearFields()">Effacer</button>
        </div>
        <div style="display: flex; align-items: center; gap: 20px;">
            <select id="mostFrequentColor">
                <option value="50% rouge">50% Rouge</option>
                <option value="50% vert">50% Vert</option>
                <option value="60% rouge">60% Rouge</option>
                <option value="60% vert">60% Vert</option>
                <option value="70% rouge">70% Rouge</option>
                <option value="70% vert">70% Vert</option>
                <option value="80% rouge">80% Rouge</option>
                <option value="80% vert">80% Vert</option>
                <option value="90% rouge">90% Rouge</option>
                <option value="90% vert">90% Vert</option>
                <option value="100% rouge">100% Rouge</option>
                <option value="100% vert">100% Vert</option>
            </select>
        </div>
        <div class="history-header">
            <h2>Historique</h2>
            <div>
                <button class="btn-copy" onclick="copyHistory()">Copier</button>
                <button class="btn-export" onclick="exportHistory()">Exporter</button>
            </div>
        </div>
        <div id="historyContainer" class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>COULEURS</th>
                        <th>PR√âDICTION</th>
                        <th>COULEUR R√âCURRENTE</th>
                        <th>R√âSULTAT</th>
                    </tr>
                </thead>
                <tbody id="history">
                </tbody>
            </table>
        </div>
        <p id="predictionResult"></p>
        <p id="previousResult"></p> <!-- Message pour les r√©sultats pr√©c√©dents -->
        <div style="display: flex; align-items: center; gap: 20px;">
            <label for="correctPrediction" style="margin-bottom: 0;">Pr√©diction Incorrecte :</label>
            <input type="text" id="correctPrediction" class="color-input" placeholder="Couleur Correcte" maxlength="5">
            <button class="btn-success" onclick="correctPrediction()">Corriger</button>
            <button class="btn-undo" onclick="undo()">Marche Arri√®re</button> <!-- Bouton d√©plac√© √† droite de "Corriger" -->
        </div>
        <div class="feedback-buttons">
            <button class="btn-success" id="btnSuccess" onclick="giveFeedback(true)">Gagner ‚úÖ</button>
            <button class="btn-failure" id="btnFailure" onclick="giveFeedback(false)">Perte ‚ùå</button>
            <button class="btn-history" onclick="clearHistory()">Effacer l'Historique</button>
        </div>
        <div class="stats">
            <p id="successRate"></p>
            <p id="totalPredictions">Total des Pr√©dictions : 0</p>
            <p id="totalSuccesses">Total des R√©ussites : 0</p>
            <p id="totalFailures">Total des Pertes : 0</p>
            <p id="points">Points : 0</p>
        </div>
        <div class="patterns">
            <h3>Motifs √† 95% de succ√®s</h3>
            <p>RRV ‚ûî R</p>
            <p>VRR ‚ûî R</p>
            <p>VRR ‚ûî V</p>
            <p>RRV ‚ûî R</p>
            <p>VRR ‚ûî R</p>
            <p>VRR ‚ûî R</p>
            <p>RRV ‚ûî V</p>
        </div>
    </div>
    <div class="overlay" id="overlay">
        <div class="overlay-message">
            Vous devez attendre l'expiration du minuteur pour voir les pr√©dictions. Temps restant : <span id="overlay-timer">05:00</span> ü§ñü§ñü§ñ
        </div>
    </div>
    <script>
        let history = [];
        let previousHistory = [];
        let consecutiveLosses = 0;
        let successes = 0;
        let failures = 0; // Ajout du compteur de points
        let points = 0; // Ajout du compteur de points
        let lastResultWasLoss = false; // Indicateur de la derni√®re pr√©diction perdue
        let timer;
        let totalSeconds = 300; // 5 minutes = 300 secondes
        let timerActive = false; // Indicateur pour savoir si le minuteur est actif

        function startTimer() {
            timerActive = true;
            timer = setInterval(setTime, 1000);
        }

        function stopTimer() {
            timerActive = false;
            clearInterval(timer);
        }

        function setTime() {
            if (totalSeconds > 0) {
                --totalSeconds;
                let minutes = Math.floor(totalSeconds / 60);
                let seconds = totalSeconds % 60;

                document.getElementById('overlay-timer').innerText =
                    ("0" + minutes).slice(-2) + ":" + ("0" + seconds).slice(-2);
            } else {
                stopTimer();
                hideOverlay();
                alert("Le temps est √©coul√© !");
                resetTimer();
            }
        }

        function resetTimer() {
            totalSeconds = 300;
            document.getElementById('overlay-timer').innerText = "05:00";
            document.getElementById('predictButton').disabled = false; // R√©activer le bouton pr√©dire apr√®s l'expiration du minuteur
        }

        function validateInput() {
            const input = document.getElementById('colorInput');
            input.value = input.value.toUpperCase().replace(/[^RV]/g, '').slice(0, 3);
        }

        function appendColor(color) {
            const input = document.getElementById('colorInput');
            if (input.value.length < 3) {
                input.value += color;
            }
        }

        function predictColor() {
            const colorInput = document.getElementById('colorInput').value.toUpperCase();
            const validColors = ['R', 'V'];

            if (colorInput === 'VRV' || colorInput === 'RVR') {
                document.getElementById('previousResult').textContent = 'Pr√©diction Ind√©cise';
                return;
            }

            if (colorInput.length !== 3 || !colorInput.split('').every(char => validColors.includes(char))) {
                alert('Veuillez entrer une s√©quence de trois couleurs, utilisant uniquement "R" ou "V".');
                return;
            }

            const lastColors = colorInput.split('').map(char => char === 'R' ? 'rouge' : 'vert');
            const mostFrequentColor = document.getElementById('mostFrequentColor').value.toLowerCase();

            let nextColor;

            // Algorithme de pr√©diction bas√© sur les motifs fournis et la couleur la plus r√©currente
            if (lastColors.every(color => color === 'vert')) {
                nextColor = 'vert';
            } else if (lastColors.every(color => color === 'rouge')) {
                nextColor = 'rouge';
            } else if (lastColors[lastColors.length - 1] === 'vert' && lastColors.includes('rouge')) {
                nextColor = 'rouge';
            } else if (lastColors[lastColors.length - 1] === 'rouge' && lastColors.includes('vert')) {
                nextColor = 'vert';
            } else if (mostFrequentColor.includes('%')) {
                const percent = parseInt(mostFrequentColor.split('%')[0]);
                if (Math.random() * 100 < percent) {
                    nextColor = mostFrequentColor.includes('rouge') ? 'rouge' : 'vert';
                } else {
                    nextColor = mostFrequentColor.includes('rouge') ? 'vert' : 'rouge';
                }
            } else {
                nextColor = mostFrequentColor; // Utiliser la couleur la plus r√©currente pour la pr√©diction
            }

            // V√©rifier si la pr√©diction existe d√©j√† dans l'historique
            const previousResult = history.find(record => record.colors === lastColors.join(', '));

            if (previousResult) {
                if (previousResult.result === '√âchec') {
                    document.getElementById('previousResult').textContent = 'Cette pr√©diction existe d√©j√† dans l\'historique avec r√©sultat √âchec. Essayez de miser la couleur contraire.';
                } else {
                    document.getElementById('previousResult').textContent = `Pr√©diction : ${previousResult.prediction}, R√©sultat : ${previousResult.result}, Couleur R√©currente : ${previousResult.frequentColor}`;
                }
            } else {
                document.getElementById('previousResult').textContent = ''; // Effacer le message pr√©c√©dent
            }

            // Ajouter automatiquement √† l'historique m√™me si la pr√©diction existe d√©j√†
            previousHistory = [...history]; // Sauvegarde de l'historique actuel
            history.push({ colors: lastColors.join(', '), prediction: nextColor, frequentColor: mostFrequentColor, result: '', date: document.getElementById('dateInput').value || new Date().toLocaleDateString() });

            const predictionResult = document.getElementById('predictionResult');
            predictionResult.textContent = "Pr√©diction : " + nextColor;

            // Effacer les champs apr√®s la pr√©diction
            document.getElementById('colorInput').value = '';

            updateHistory();
            enableFeedbackButtons();

            // Notification de confirmation de la pr√©diction
            alert('Pr√©diction ajout√©e avec succ√®s !');
        }

        function displayPreviousResult(previousResult) {
            const resultMessage = `Cette pr√©diction existe d√©j√† dans l'historique. Pr√©diction : ${previousResult.prediction}, R√©sultat : ${previousResult.result}, Couleur R√©currente : ${previousResult.frequentColor}`;
            document.getElementById('previousResult').textContent = resultMessage;
        }

        function clearFields() {
            document.getElementById('colorInput').value = '';
            document.getElementById('mostFrequentColor').value = '50% rouge';
            document.getElementById('predictionResult').textContent = '';
            document.getElementById('previousResult').textContent = ''; // Effacer le message pr√©c√©dent
            enableFeedbackButtons(); // R√©activer les boutons de feedback
        }

        function giveFeedback(correct) {
            if (correct) {
                history[history.length - 1].result = 'Succ√®s';
                successes += 1;
                points += 10; // Ajouter des points pour chaque pr√©diction correcte
                lastResultWasLoss = false; // R√©initialiser apr√®s un gain
                consecutiveLosses = 0; // R√©initialiser les pertes cons√©cutives

                // Notification de r√©ussite
                alert('F√©licitations, vous avez r√©ussi !');
            } else {
                history[history.length - 1].result = '√âchec';
                failures += 1; // Ajouter √† l'√©chec
                lastResultWasLoss = true; // Indiquer que la derni√®re pr√©diction √©tait une perte
                consecutiveLosses += 1; // Incr√©menter les pertes cons√©cutives

                // Activer le minuteur uniquement apr√®s deux pertes cons√©cutives
                if (consecutiveLosses >= 2) {
                    startTimer();
                    showOverlay(); // Afficher le message d'attente
                    consecutiveLosses = 0; // R√©initialiser les pertes cons√©cutives apr√®s activation du minuteur
                }

                // Notification d'√©chec
                alert('Dommage, vous avez perdu.');
            }
            updateHistory();
            updateSuccessRate();
            updatePoints(); // Mettre √† jour les points

            if (lastResultWasLoss) {
                document.getElementById('previousResult').textContent = 'Miser la couleur contraire pour la prochaine fois !';
            } else {
                document.getElementById('previousResult').textContent = ''; // Effacer le message apr√®s un gain
            }
        }

        function correctPrediction() {
            const correctPrediction = document.getElementById('correctPrediction').value.toLowerCase();
            const validValues = ['rouge', 'vert', '50%'];

            if (!validValues.includes(correctPrediction)) {
                alert('Veuillez entrer "rouge", "vert" ou "50%" uniquement.');
                return;
            }

            history[history.length - 1].prediction = correctPrediction;
            updateHistory();
            document.getElementById('correctPrediction').value = ''; // Effacer le champ de correction
        }

        function updateHistory() {
            const historyElement = document.getElementById('history');
            historyElement.innerHTML = '';
            history.forEach((record, index) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td style="background-color:#f5f5f5;">${record.date}</td><td style="background-color:#f8d7da;">${record.colors}</td><td style="background-color:#d4edda;">${record.prediction}</td><td style="background-color:#fff3cd;">${record.frequentColor}</td><td style="background-color:#f5c6cb;">${record.result}</td>`;
                historyElement.appendChild(tr);
            });
            saveHistoryToLocalStorage(); // Sauvegarder apr√®s mise √† jour
            updateStats();
        }

        function clearHistory() {
            previousHistory = [...history]; // Sauvegarde de l'historique actuel
            history = [];
            successes = 0; // R√©initialiser les r√©ussites
            failures = 0; // R√©initialiser les pertes
            points = 0; // R√©initialiser les points
            updateHistory();
            updateSuccessRate();
            updateStats(); // Mettre √† jour les statistiques apr√®s effacement
            updatePoints(); // Mettre √† jour les points apr√®s effacement
            enableFeedbackButtons(); // R√©activer les boutons de feedback

            // Notification de l'effacement de l'historique
            alert('Historique effac√© avec succ√®s !');
        }

        function undo() {
            history = [...previousHistory]; // Restaure l'historique pr√©c√©dent
            updateHistory();
            updateSuccessRate();
            updateStats(); // Mettre √† jour les statistiques apr√®s restauration
            updatePoints(); // Mettre √† jour les points apr√®s restauration
            enableFeedbackButtons(); // R√©activer les boutons de feedback

            // Notification de la restauration de l'historique
            alert('Historique restaur√© avec succ√®s !');
        }

        function updateSuccessRate() {
            const successRate = (successes / (successes + failures)) * 100;
            document.getElementById('successRate').textContent = `Taux de r√©ussite : ${successRate.toFixed(2)}%`;
        }

        function updatePoints() {
            document.getElementById('points').textContent = `Points : ${points}`; // Afficher les points
        }

        function saveHistoryToLocalStorage() {
            localStorage.setItem('predictionHistory', JSON.stringify(history));
        }

        function loadHistoryFromLocalStorage() {
            const storedHistory = localStorage.getItem('predictionHistory');
            if (storedHistory) {
                history = JSON.parse(storedHistory);
                updateHistory();
                updateSuccessRate();
                updateStats(); // Mettre √† jour les statistiques apr√®s chargement
                updatePoints(); // Mettre √† jour les points apr√®s chargement
            }
        }

        function updateStats() {
            document.getElementById('successRate').textContent = `Taux de r√©ussite : ${(successes / (successes + failures) * 100).toFixed(2)}%`;
            document.getElementById('totalPredictions').textContent = `Total des Pr√©dictions : ${history.length}`;
            document.getElementById('totalSuccesses').textContent = `Total des R√©ussites : ${successes}`;
            document.getElementById('totalFailures').textContent = `Total des Pertes : ${failures}`;
        }

        function enableFeedbackButtons() {
            document.getElementById('btnSuccess').disabled = false;
            document.getElementById('btnFailure').disabled = false;
        }

        function showOverlay() {
            document.getElementById('overlay').style.display = 'flex';
            document.querySelectorAll('button').forEach(button => button.disabled = true); // D√©sactiver tous les boutons sauf la barre de d√©filement
            document.getElementById('predictButton').disabled = true; // D√©sactiver le bouton de pr√©diction
        }

        function hideOverlay() {
            document.getElementById('overlay').style.display = 'none';
            document.querySelectorAll('button').forEach(button => button.disabled = false); // R√©activer tous les boutons
        }

        // Fonction pour copier l'historique dans le presse-papiers
        function copyHistory() {
            const historyText = history.map(record => `${record.date} - ${record.colors} - ${record.prediction} - ${record.frequentColor} - ${record.result}`).join('\n');
            const el = document.createElement('textarea');
            el.value = historyText;
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            alert('Historique copi√© dans le presse-papiers!');
        }

        // Fonction pour exporter l'historique en fichier texte
        function exportHistory() {
            const historyText = history.map(record => `${record.date} - ${record.colors} - ${record.prediction} - ${record.frequentColor} - ${record.result}`).join('\n');
            const blob = new Blob([historyText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'historique.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

              // Fonction pour enlever les accents des entr√©es
              function removeAccents(input) {
            const accentsMap = {
                '√°': 'a', '√†': 'a', '√¢': 'a', '√§': 'a', '√£': 'a', '√•': 'a', '√¶': 'ae', '√ß': 'c',
                '√©': 'e', '√®': 'e', '√™': 'e', '√´': 'e', '√≠': 'i', '√¨': 'i', '√Æ': 'i', '√Ø': 'i',
                '√±': 'n', '√≥': 'o', '√≤': 'o', '√¥': 'o', '√∂': 'o', '√µ': 'o', '√∏': 'o', '√∫': 'u',
                '√π': 'u', '√ª': 'u', '√º': 'u', '√Ω': 'y', '√ø': 'y', '√Å': 'A', '√Ä': 'A', '√Ç': 'A', '√Ñ': 'A', '√É': 'A', '√Ö': 'A', '√Ü': 'AE', '√á': 'C', '√â': 'E', '√à': 'E', '√ä': 'E',
                '√ã': 'E', '√ç': 'I', '√å': 'I', '√é': 'I', '√è': 'I', '√ë': 'N', '√ì': 'O', '√í': 'O', '√î': 'O',
                '√ñ': 'O', '√ï': 'O', '√ò': 'O', '√ö': 'U', '√ô': 'U', '√õ': 'U', '√ú': 'U', '√ù': 'Y'
            };
            input.value = input.value.split('').map(char => accentsMap[char] || char).join('');
        }

        // Afficher un tutoriel au d√©marrage
        function showTutorial() {
            alert("Bienvenue dans le Jeu de Pr√©diction de Couleurs √âlite!\n\n1. Entrez trois couleurs : rouge ou vert.\n2. Ajoutez la couleur la plus r√©currente parmi vos choix.\n3. Appuyez sur 'Pr√©dire' pour voir le r√©sultat.\n\nBonne chance!");
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadHistoryFromLocalStorage();
            showTutorial(); // Afficher le tutoriel au d√©marrage
        });
    </script>
</body>
</html>
