<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìàSignal bü§ñt 97 Trx üìà</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://unpkg.com/docx@7.8.2/build/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <!-- Sons pour les feedbacks -->
<audio id="winSound" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" preload="auto"></audio>
<audio id="lossSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3" preload="auto"></audio>
    <style>
        /* Styles pour la popup de notification */
        .notification-popup {
            display: none; /* Cache la popup par d√©faut */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .notification-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .notification-buttons button {
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .notification-buttons button:first-child {
            background-color: #28a745; /* Vert pour "Oui" */
            color: white;
        }

        .notification-buttons button:last-child {
            background-color: #dc3545; /* Rouge pour "Non" */
            color: white;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f8ff;
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            padding: 20px;
            max-width: 800px;
            width: 100%;
            height: 95vh;
            overflow-y: auto;
            position: relative;
        }

        .fas {
            font-size: 24px; /* Taille de l'ic√¥ne */
            color: blue; /* Couleur de l'ic√¥ne */
            margin-right: 10px; /* Espace entre l'ic√¥ne et le texte */
        }

        .header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-profile {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 15px;
    text-align: center;
    margin-left: 20px;  /* Marge √† gauche comme WhatsApp */
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    width: 150px;  /* M√™me largeur */
    display: flex;
    flex-direction: column;
    align-items: center;
}

        h1 {
            color: #5b5b5b;
            text-align: center;
            margin-bottom: 20px;
        }

        label {
            margin: 5px 0;
            font-weight: bold;
            display: inline-block;
            width: 180px;
        }

        .action-buttons, .right-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
        }

        button {
            padding: 10px 20px;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            font-size: 16px;
            margin-right: 10px;
        }

        .btn-predict {
            background-color: #28a745;
        }

        .btn-predict:hover {
            background-color: #218838;
        }

        .btn-clear {
            background-color: #dc3545;
        }

        .btn-clear:hover {
            background-color: #c82333;
        }

        .btn-history, .btn-undo {
            background-color: #007bff;
        }

        .btn-history:hover, .btn-undo:hover {
            background-color: #0056b3;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-failure {
            background-color: #dc3545;
        }

        .btn-failure:hover {
            background-color: #c82333;
        }

       
        .btn-copy {
         background-color: #ffc107; /* Jaune */
        
        }
        .btn-copy:hover {
          background-color: #e0a800; /* Jaune plus fonc√© */
         }

         .btn-export[onclick="exportToTxt()"] {
    background-color: hsl(128, 79%, 41%);
    margin-left: 10px;
}

.btn-export[onclick="exportToTxt()"]:hover {
    background-color: #208a29;
}

        .color-input, .series-input, .level-selection, #colorPercentage {
            padding: 10px;
            border: 2px solid #aaa;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 150px;
            text-align: center;
            font-size: 18px;
            color: #444;
            background-color: #fff;
        }

        .color-input::placeholder, .series-input::placeholder {
            color: #888;
        }

        .input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
        }
        #haitiTime {
    font-size: 14px;
    color: #333; /* Noir */
    margin-top: 5px;
}

#currentTime {
    font-weight: bold;
    color: #000; /* Noir */
    font-family: 'Arial', sans-serif; /* Police plus lisible */
}
        .level-popup, .level-info-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 2px solid #aaa;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            width: 300px;
        }

        .level-popup h2, .level-info-popup h2 {
            margin-top: 0;
        }

        .level-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .level-buttons label {
            cursor: pointer;
        }

        .btn-confirm {
            background-color: #007bff;
        }

        .btn-confirm:hover {
            background-color: #0056b3;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 16px;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }

        th {
            background-color: #f0f0f0;
        }

        #historyContainer {
            max-height: 300px;
            overflow-y: auto; /* Ajout de la barre de d√©filement */
        }

        .highlight {
            background-color: yellow;
        }

        .feedback-buttons {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .feedback-buttons button {
            width: 30%;
        }

        .stats {
            margin-top: 20px;
            font-size: 18px;
            text-align: left;
        }

        .bottom-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin: 20px 0;
        }

        .history-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 20px;
    width: 100%;
}

.history-header > div {
    display: flex;
    gap: 10px;
}
        .date-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-bottom: 20px;
        }
       .patterns {
            margin-bottom: 20px;
        }

        .tips {
            margin-bottom: 20px;
        }
       
        .global-stats {
            margin-bottom: 20px;
        }

        .info-tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
            color: #007bff;
        }

        .info-tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .info-tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

      .btn-level {
    background-color: green; /* Couleur de fond */
    color: white; /* Couleur du texte */
    padding: 10px 20px; /* Taille du bouton */
    border: none; /* Pas de bordure */
    border-radius: 5px; /* Coins arrondis */
    cursor: pointer; /* Curseur en main */
    font-size: 16px; /* Taille de police */
    margin-left: 10px; /* Espacement avec le bouton "Effacer" */
}

.action-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 15px 0;
}
.action-buttons button {
    padding: 8px 12px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}
/* Couleurs des boutons */
.btn-predict { background-color: #28a745; color: white; }
.btn-clear { background-color: #dc3545; color: white; }
.btn-level { background-color: #6f42c1; color: white; }
.btn-analyze { background-color: #17a2b8; color: white; }

/* Ic√¥nes */
.action-buttons button i {
    font-size: 14px;
}

/* Effets au survol */
.action-buttons button:hover {
    opacity: 0.9;
    transform: translateY(-1px);
}

/* Version mobile */
@media (max-width: 768px) {
    .action-buttons {
        gap: 6px;
    }
    .action-buttons button {
        padding: 6px 10px;
        font-size: 13px;
    }
}

        .level-info-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 2px solid #aaa;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            width: 300px;
        }

        .level-info-popup h2 {
            margin-top: 0;
        }

        .level-info-popup .close-btn {
            position: absolute;
            top: 10px;
            right: 0px;
            background-color: red;
            border: none;
            font-size: 18px;
            cursor: pointer;
        }
        .last-six {
    margin-top: 20px;
}

.last-six h2 {
    text-align: center;
    font-size: 24px;
    margin-bottom: 10px;
}

.prediction-item {
    background-color: #f5f5f5;
    padding: 10px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
}

.prediction-item p {
    margin: 5px 0;
}

.blink {
    animation: blink-animation 0s infinite;
    background-color: #0378fd;
}
#pieChart {
    max-width: 400px;
    margin: 20px auto;
    display: block;
}
.btn-analyze {
    background-color: #17a2b8; /* Couleur turquoise */
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-left: 10px;
}

.btn-analyze:hover {
    background-color: #138496; /* Couleur turquoise plus fonc√©e */
}
/* Animation pour la popup de pause */
@keyframes fadeIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
}

.notification-popup {
    animation: fadeIn 0.5s ease-in-out;
}

/* Barre de progression pour le minuteur */
.progress-bar-timer {
    width: 100%;
    height: 10px;
    background-color: #e0e0e0;
    border-radius: 5px;
    overflow: hidden;
    margin-top: 10px;
}

.progress-bar-fill-timer {
    height: 100%;
    background-color: #007bff;
    width: 100%;
    transition: width 1s linear;
}
.timer-container {
    margin-top: 20px;
    text-align: center;
}

#startStopTimer {
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
}

#startStopTimer:hover {
    background-color: #0056b3;
}

#timerDisplay {
    font-size: 18px;
    margin-top: 10px;
}

#timerMessage {
    font-size: 16px;
    color: #dc3545;
    margin-top: 10px;
}
.timer-container {
    margin-top: 20px;
    text-align: center;
}

.timer-container button {
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin: 5px;
}

.timer-container button:hover {
    background-color: #0056b3;
}

#timerDisplay {
    font-size: 18px;
    margin-top: 10px;
}
.btn-invert {
    background-color: #ffc107; /* Jaune */
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-left: 10px;
}

.btn-invert:hover {
    background-color: #e0a800; /* Jaune plus fonc√© */
}
/* Styles pour le tableau */
.success-row {
    background-color: rgba(40, 167, 69, 0.1);
}

.failure-row {
    background-color: rgba(220, 53, 69, 0.1);
}

.pending-row {
    background-color: rgba(255, 193, 7, 0.1);
}

.latest-entry {
    animation: highlight-fade 2s ease-out;
    box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
}

@keyframes highlight-fade {
    from { background-color: rgba(0, 123, 255, 0.3); }
    to { background-color: transparent; }
}

.red-dot, .green-dot {
    font-size: 1.2em;
    margin: 0 2px;
}

.success-result {
    color: #28a745;
    font-weight: bold;
}

.failure-result {
    color: #dc3545;
    font-weight: bold;
}
/* Ajoute ces nouveaux styles */
    .prediction-container {
        padding: 15px;
        border-radius: 10px;
        margin: 15px 0;
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
    }
    
    .prediction-red {
        background-color: rgba(220, 53, 69, 0.1);
        border: 2px solid #dc3545;
        color: #dc3545;
    }
    
    .prediction-green {
        background-color: rgba(40, 167, 69, 0.1);
        border: 2px solid #28a745;
        color: #28a745;
    }
    
    .prediction-icon {
        font-size: 24px;
        animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }
    
    .warning-alert {
        background-color: #fff3cd;
        border-left: 5px solid #ffc107;
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
        color: #856404;
    }
    /* Styles pour la popup de strat√©gie */
.strategy-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    animation: fadeIn 0.5s;
}

.strategy-content {
    background: white;
    padding: 25px;
    border-radius: 15px;
    max-width: 600px;
    box-shadow: 0 0 20px rgba(0,0,0,0.3);
}

.strategy-steps {
    margin: 20px 0;
}

.step {
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #eee;
}

.step h3 {
    color: #2c3e50;
    margin-top: 0;
}

.color-example {
    font-size: 24px;
    margin: 10px 0;
    text-align: center;
}

.red-dot, .green-dot {
    margin: 0 3px;
}

.btn-confirm {
    background: #3498db;
    color: white;
    border: none;
    padding: 12px 25px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    display: block;
    margin: 20px auto 0;
    transition: background 0.3s;
}

.btn-confirm:hover {
    background: #2980b9;
}
 /* Ajoutez ce style dans la section <style> */
    .strategy-content {
        max-height: 80vh; /* Hauteur maximale de 80% de la hauteur de l'√©cran */
        overflow-y: auto; /* Activation de la barre de d√©filement verticale */
        padding: 25px;
        width: 90%;
        max-width: 600px;
    }

    /* Style personnalis√© pour la barre de d√©filement */
    .strategy-content::-webkit-scrollbar {
        width: 8px;
    }

    .strategy-content::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }

    .strategy-content::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
    }

    .strategy-content::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
    .btn-analyze {
    background-color: #6c757d; /* Gris */
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s;
}

.btn-analyze:hover {
    background-color: #5a6268; /* Gris fonc√© */
}

.fa-chart-bar {
    margin-right: 8px;
}
/* Conteneur principal en grille */
.color-buttons-grid {
    display: flex;
    justify-content: center;
    gap: 30px; /* Grand √©cart entre les colonnes */
    margin: 25px 0;
}

/* Colonne verticale de boutons */
.button-column {
    display: flex;
    flex-direction: column;
    gap: 15px; /* Espace vertical entre les boutons */
}

/* Style des boutons R */
.btn-red {
    background-color: #dc3545;
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: all 0.3s;
    min-width: 80px;
    text-align: center;
}

/* Style des boutons V */
.btn-green {
    background-color: #28a745;
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: all 0.3s;
    min-width: 80px;
    text-align: center;
}

/* Effets au survol */
.btn-red:hover {
    background-color: #c82333;
    transform: scale(1.05);
}

.btn-green:hover {
    background-color: #218838;
    transform: scale(1.05);
}

/* Effet lors du clic */
.btn-red:active, .btn-green:active {
    transform: scale(0.98);
}
.password-container {
    display: none;
    margin-top: 15px;
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 5px;
}

.password-container input {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.password-error {
    color: #dc3545;
    font-size: 14px;
    margin-top: 5px;
    display: none;
}
/* Styles pour la bankroll */
.bankroll-container {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
    border: 1px solid #ddd;
}

.bankroll-input {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}

.bankroll-input input {
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 5px;
    width: 120px;
}

.btn-bankroll {
    background-color: #6c757d;
    color: white;
    padding: 8px 15px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

.bankroll-display {
    background-color: white;
    padding: 10px;
    border-radius: 5px;
    font-weight: bold;
}

.bankroll-display span {
    color: #28a745;
}
.btn-apply, .btn-calc {
    padding: 5px 10px;
    margin-left: 8px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.btn-apply {
    background-color: #28a745;
    color: white;
}

.btn-calc {
    background-color: #17a2b8;
    color: white;
}

.calculation-result strong {
    color: #2c3e50;
}
/* Styles pour la section Martingale */
.martingale-section {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    border: 1px solid #dee2e6;
}

.martingale-section h3 {
    color: #343a40;
    margin-top: 0;
    font-size: 1.4rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

.martingale-section h3::before {
    content: "‚ö°";
    font-size: 1.6rem;
}

.input-group {
    margin-bottom: 15px;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}

.input-group label {
    font-weight: 600;
    color: #495057;
    min-width: 150px;
    margin-bottom: 5px;
}

.input-group input {
    padding: 10px 15px;
    border: 2px solid #ced4da;
    border-radius: 8px;
    font-size: 16px;
    flex-grow: 1;
    max-width: 200px;
    transition: all 0.3s;
}

.input-group input:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    outline: none;
}

.btn-validate {
    background: linear-gradient(135deg, #28a745 0%, #218838 100%);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-validate:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.btn-validate:active {
    transform: translateY(0);
}

.result-display {
    background: #ffffff;
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    border-left: 4px solid #007bff;
}

.result-display p {
    margin: 8px 0;
    font-size: 16px;
    display: flex;
    justify-content: space-between;
}

.result-display p span {
    font-weight: 600;
    color: #2c3e50;
}

.martingale-status {
    font-size: 14px;
    color: #6c757d;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #dee2e6;
}

/* Style pour les puces dans la s√©quence */
.martingale-sequence {
    display: flex;
    gap: 5px;
    margin-top: 10px;
    flex-wrap: wrap;
}

.martingale-chip {
    background: #007bff;
    color: white;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 30px;
}

.current-chip {
    background: #28a745;
    transform: scale(1.1);
    box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.5);
}
.stats-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin: 20px 0;
    background: #f8f9fa;
    padding: 15px;
    border-radius: 10px;
    border: 1px solid #dee2e6;
}

.color-stats {
    padding: 15px;
    border-radius: 8px;
    text-align: center;
}

.red-stats {
    background-color: rgba(220, 53, 69, 0.1);
    border-left: 4px solid #dc3545;
}

.green-stats {
    background-color: rgba(40, 167, 69, 0.1);
    border-left: 4px solid #28a745;
}

.stats-header {
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.stats-value {
    font-size: 1.5rem;
    font-weight: bold;
    margin: 5px 0;
}

.stats-percentage {
    font-size: 1.1rem;
    color: #6c757d;
}

.force-mode-active {
    animation: pulseWarning 2s infinite;
    border: 2px solid #ffc107;
    box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
}

@keyframes pulseWarning {
    0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
    100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
}
.header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        background: linear-gradient(135deg, #1e2a3a 0%, #2c3e50 100%);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        margin-bottom: 25px;
        color: white;
        position: relative;
       
    }

    .header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #28a745 0%, #007bff 50%, #dc3545 100%);
    }

    .logo-title {
        text-align: center;
        position: relative;
    }

    .trading-badge {
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        background: #ffc107;
        color: #1e2a3a;
        padding: 3px 15px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
    }

    h1 {
        margin: 0;
        font-size: 2.8rem;
        font-weight: 800;
        letter-spacing: -1px;
        background: linear-gradient(90deg, #ffffff 0%, #c2d6f0 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }

    .signal-word {
        color: #4CAF50;
        text-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
    }

    .bot-word {
        color: #2196F3;
        position: relative;
    }

    .bot-word::after {
        content: "ü§ñ";
        position: absolute;
        right: -25px;
        top: -5px;
        font-size: 1.5rem;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }

    .trx-badge {
        background: linear-gradient(135deg, #f44336 0%, #e91e63 100%);
        color: white;
        padding: 2px 12px;
        border-radius: 6px;
        font-size: 1.8rem;
        margin-left: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        position: relative;
        top: -2px;
    }

    .version-badge {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
        letter-spacing: 1px;
        margin-top: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
    }

    .version-badge::before,
    .version-badge::after {
        content: "";
        flex: 1;
        height: 1px;
        background: rgba(255, 255, 255, 0.2);
    }

    .user-profile {
        background: rgba(255, 255, 255, 0.1);
        padding: 12px 20px;
        border-radius: 10px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .user-profile i {
        color: #4CAF50;
        font-size: 20px;
        margin-right: 8px;
    }

    .user-profile strong {
        display: block;
        margin-bottom: 8px;
        color: #ffffff;
        font-size: 16px;
    }

    .user-profile p {
        margin: 3px 0;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
    }

    #userLevelSpan {
        color: #FFC107;
        font-weight: bold;
    }

    #currentTime {
        color: #00BCD4;
        font-weight: bold;
    }

    /* Animation pulsante pour le badge TRX */
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    .trx-badge {
        animation: pulse 2s infinite;
    }

    /* Effet au survol */
    h1:hover .trx-badge {
        animation: none;
        transform: scale(1.1);
        transition: all 0.3s ease;
    }
    html, body {
    overflow-x: hidden;

    margin: 0;           
    padding: 0;         
    }
    .container {
    
     overflow-x: hidden; 
    
}

.stats {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    padding: 20px;
    border-radius: 12px;
    margin: 20px 0;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    border: 1px solid #dee2e6;
}

.stats p {
    margin: 0;
    padding: 12px 15px;
    font-size: 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e9ecef;
}

.stats p:last-child {
    border-bottom: none;
}

.stats p::after {
    content: '';
    flex: 1;
    margin-left: 15px;
    height: 1px;
    background: linear-gradient(90deg, #dee2e6 0%, transparent 100%);
}

.stats p span {
    font-weight: bold;
    background-color: rgba(0, 0, 0, 0.03);
    padding: 4px 10px;
    border-radius: 20px;
    min-width: 60px;
    text-align: center;
}

#successRate span {
    color: #28a745;
    background-color: rgba(40, 167, 69, 0.1);
}

#totalSuccesses span {
    color: #28a745;
    background-color: rgba(40, 167, 69, 0.1);
}

#totalFailures span {
    color: #dc3545;
    background-color: rgba(220, 53, 69, 0.1);
}

#points span {
    color: #007bff;
    background-color: rgba(0, 123, 255, 0.1);
}

#totalPredictions span {
    color: #6c757d;
    background-color: rgba(108, 117, 125, 0.1);
}
.password-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    animation: fadeIn 0.3s;
}

.password-content {
    background: #121a25;
    padding: 30px;
    border-radius: 20px;
    width: 300px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.08);
}

.password-header {
    text-align: center;
    margin-bottom: 25px;
}

.password-header h2 {
    color: #4e9af1;
    margin: 0 0 10px 0;
    font-size: 1.5rem;
}

.password-header p {
    color: #a0a8b8;
    margin: 0;
    font-size: 0.9rem;
}

.code-display {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 30px;
}

.code-dot {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: rgba(255,255,255,0.05);
    border: 2px solid rgba(255,255,255,0.1);
    transition: all 0.2s;
}

.code-dot.filled {
    background: #4e9af1;
    border-color: #4e9af1;
    box-shadow: 0 0 10px rgba(78,154,241,0.3);
}

.numeric-keypad {
    display: grid;
    grid-template-rows: repeat(4, 1fr);
    gap: 10px;
}

.keypad-row {
    display: flex;
    justify-content: center;
    gap: 10px;
}

.keypad-btn {
    width: 70px;
    height: 50px;
    border-radius: 10px;
    background: rgba(30,40,55,0.8);
    border: none;
    color: white;
    font-size: 1.3rem;
    font-weight: 300;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
}

.keypad-btn:hover {
    background: rgba(40,50,65,0.9);
    transform: translateY(-2px);
}

.keypad-btn:active {
    transform: translateY(0);
    background: rgba(50,60,75,1);
}

.clear-btn {
    background: rgba(220,53,69,0.7);
    font-size: 0.9rem;
    flex-grow: 1;
    border-radius: 10px;
}

.confirm-btn {
    background: rgba(40,167,69,0.7);
    font-size: 1.2rem;
    flex-grow: 1;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    20%, 60% { transform: translateX(-5px); }
    40%, 80% { transform: translateX(5px); }
}

.shake {
    animation: shake 0.4s;
}
.whatsapp-profile {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 15px;
    text-align: center;
    margin-right: 70px; /* Chang√© de margin-left √† margin-right */
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    width: 150px;
    order: -1; /* Pour le placer en premier dans le flex container */
}

.profile-image-container {
    position: relative;
    margin-bottom: 10px;
}

#profileImage {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid #25D366;
    cursor: pointer;
    transition: all 0.3s;
}

#profileImage:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(37, 211, 102, 0.5);
}

.btn-change-profile {
    background: #25D366;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.3s;
    width: 100%;
    margin-bottom: 8px;
}

.btn-change-profile:hover {
    background: #128C7E;
}

.whatsapp-status {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.8);
    padding: 4px;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.2);
}

#whatsappStatus::before {
    content: "‚Ä¢";
    color: #25D366;
    font-size: 16px;
    margin-right: 5px;
}
#maxConsecutiveLosses span {
    color: #dc3545; /* Rouge pour les pertes */
    background-color: rgba(220, 53, 69, 0.1);
    padding: 3px 8px;
    border-radius: 10px;
}

#lionCoins span {
    color: #ff9800; /* Orange pour les Lion Coins */
    background-color: rgba(255, 152, 0, 0.1);
    padding: 3px 8px;
    border-radius: 10px;
    font-weight: bold;
}
.external-patterns-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
}


.external-patterns-table th {
    background-color: #f8f9fa;
    position: sticky;
    top: 0;
}

.external-patterns-table tr:nth-child(even) {
    background-color: #f2f2f2;
}

.external-patterns-table tr:hover {
    background-color: #e9ecef;
}



#externalPatternsList {
    max-height: 400px;
    overflow-y: auto;
    margin-top: 15px;
    border: 1px solid #dee2e6;
    border-radius: 5px;
}

.red-dot, .green-dot {
    font-size: 1.2em;
    margin: 0 2px;
}
.btn-edit, .btn-delete {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
    width: 100px;
}

.btn-edit {
    background-color: #ffc107;
    color: #212529;
}

.btn-edit:hover {
    background-color: #e0a800;
}

.btn-delete {
    background-color: #dc3545;
    color: white;
}

.btn-delete:hover {
    background-color: #c82333;
}

.external-patterns-table td {
    vertical-align: middle;
}
.db-buttons-container {
    display: flex;
    flex-direction: row; /* Alignement horizontal */
    justify-content: space-between;
    gap: 10px;
    margin: 15px 0;
    padding: 10px;
}

.db-button {
    flex: 1;
    padding: 10px 15px;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    transition: all 0.3s ease;
    background: white;
    color: black;
    min-width: 120px; /* Largeur minimale pour chaque bouton */
}
.db-button i {
    font-size: 16px;
    color: black !important; /* Change la couleur de l'ic√¥ne en noir */
}

.db-button:hover i {
    color: black !important; /* Garde la couleur noire au survol */
}
.btn-edit, .btn-delete {
    padding: 8px 12px;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    transition: all 0.3s ease;
    background: white;
    color: black;
    width: 100%;
    margin-bottom: 5px;
}

.btn-edit i, .btn-delete i {
    font-size: 16px;
    color: #000;
}
.btn-analyze i.fas.fa-database {
    color: black !important;
    font-size: 16px;
    margin-right: 8px;
}

.btn-edit:hover, .btn-delete:hover {
    transform: translateY(-2px);
    background-color: #f5f5f5;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.btn-copy {
    background-color: #17a2b8;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-left: 10px;
    transition: background-color 0.3s;
}

.btn-copy:hover {
    background-color: #138496;
}

.btn-copy i {
    margin-right: 8px;
}
/* Styles pour les ic√¥nes des boutons sp√©cifiques tout en gardant les couleurs de fond d'origine */
.btn-predict i,
.btn-clear i, 
.btn-level i,
.btn-analyze i,
.btn-export i {
    color: white !important;
}

/* Pour s'assurer que tous les symboles de ces boutons sont bien en blanc */
.action-buttons button i {
    color: white !important;
}
/* Modifiez ces styles dans votre section style existante */
.prediction-icon {
    animation: pulse 1s infinite;
    display: inline-block;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); } /* R√©duit de 1.2 √† 1.1 pour un effet plus subtil */
    100% { transform: scale(1); }
}

/* Style pour faire clignoter uniquement les pr√©dictions en cours */
tr.pending-row .prediction-icon {
    animation: pulse 1s infinite;
}

/* Arr√™ter l'animation pour les pr√©dictions termin√©es */
tr.success-row .prediction-icon,
tr.failure-row .prediction-icon {
    animation: none;
}
</style>
</head>
<div class="password-popup" id="passwordPopup" style="display: none;">
    <div class="password-content">
        <div class="password-header">
            <h2>üîí ACC√àS S√âCURIS√â</h2>
            <p>Entrez votre code √† 6 chiffres</p>
        </div>
        
        <div class="password-body">
            <div class="code-display">
                <div class="code-dot" id="dot1"></div>
                <div class="code-dot" id="dot2"></div>
                <div class="code-dot" id="dot3"></div>
                <div class="code-dot" id="dot4"></div>
                <div class="code-dot" id="dot5"></div>
                <div class="code-dot" id="dot6"></div>
            </div>
            
            <input type="text" id="passwordInput" maxlength="6" pattern="\d*" inputmode="numeric" style="opacity: 0; position: absolute; height: 0;">
            
            <div class="numeric-keypad">
                <div class="keypad-row">
                    <button class="keypad-btn" data-value="1">1</button>
                    <button class="keypad-btn" data-value="2">2</button>
                    <button class="keypad-btn" data-value="3">3</button>
                </div>
                <div class="keypad-row">
                    <button class="keypad-btn" data-value="4">4</button>
                    <button class="keypad-btn" data-value="5">5</button>
                    <button class="keypad-btn" data-value="6">6</button>
                </div>
                <div class="keypad-row">
                    <button class="keypad-btn" data-value="7">7</button>
                    <button class="keypad-btn" data-value="8">8</button>
                    <button class="keypad-btn" data-value="9">9</button>
                </div>
                <div class="keypad-row">
                    <button class="keypad-btn clear-btn" data-action="clear">Effacer</button>
                    <button class="keypad-btn" data-value="0">0</button>
                    <button class="keypad-btn confirm-btn" data-action="confirm">‚úì</button>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- Popup de notification -->
<div class="notification-popup" id="notificationPopup">
    <div class="notification-content">
        <h2>V√©rification des informations</h2>
        <p>Voyez-vous votre nom et votre niveau affich√©s √† l'√©cran ?</p>
        <div class="notification-buttons">
            <button onclick="handleNotificationResponse(true)">Oui</button>
            <button onclick="handleNotificationResponse(false)">Non</button>
        </div>
    </div>
</div>
<body>
    <div class="container">
        <div class="header">
            <div class="whatsapp-profile">
                <div class="profile-image-container">
                    <img id="profileImage" src="https://cdn-icons-png.flaticon.com/512/124/124034.png" alt="Profil WhatsApp">
                    <input type="file" id="profileUpload" accept="image/*" style="display: none;">
                </div>
              
                <button class="btn-change-profile" onclick="document.getElementById('profileUpload').click()">
                    <i class="fas fa-camera"></i> Changer la photo
                </button>
                <div class="whatsapp-status">
                    <span id="whatsappStatus">En ligne</span>
                </div>
            </div>
            <div class="logo-title">
                <div class="trading-badge">TRADING ü§ñ BOT</div>
                <h1>
                    <span class="signal-word">SIGNAL</span>
                    <span class="bot-word">BOT</span>
                    <span class="trx-badge">TRX</span>
                </h1>
                <div class="version-badge">v3.0 ‚Ä¢ 97% Accuracy</div>
            </div>
            <div class="user-profile">
                <p id="userName">Nom : Utilisateur</p>
                <p id="userLevel">Niveau : <span id="userLevelSpan"></span></p>
                <p id="haitiTime">Heure : <span id="currentTime"></span></p>
            </div>
        </div>
        <!-- Citation Motivante (3 phrases cl√©s) -->
<div id="trx-quote" style="
text-align: center;
margin: 5px 0 15px 0;
padding: 8px;
font-size: 14px;
font-weight: 500;
color: #2E7D32;
background: rgba(46, 125, 50, 0.08);
border-radius: 6px;
border-top: 1px solid #4CAF50;
font-family: 'Open Sans', sans-serif;
">
<span id="quote-text">"L'algorithme ne doute pas. Il calcule et conquiert."</span>
</div>
 <!-- Bouton d'acc√®s √† la base externe -->
<button class="btn-analyze" onclick="toggleExternalDBInterface()" style="background: white; color: black; border: 1px solid #e0e0e0;">
    <i class="fas fa-database" style="color: black;"></i> Base Externe
</button>

<!-- Interface de la base de donn√©es externe -->
<div id="externalDBInterface" style="display:none; margin-top:20px; padding:15px; background:white; border-radius:8px; border:1px solid #e0e0e0; box-shadow:0 2px 4px rgba(0,0,0,0.05);">
    <h3 style="color: black; margin-top:0;"><i class="fas fa-database" style="color: black;"></i> Base de Donn√©es Externe</h3>
    
    <div style="margin-bottom:15px;">
        <textarea id="externalPatternInput" style="width:100%; padding:12px; border-radius:6px; border:1px solid #e0e0e0; font-family:monospace; background:white; color:black;" 
                  rows="5" placeholder="Collez vos motifs ici (format: date - couleurs - pr√©diction - r√©sultat)"></textarea>
    </div>
    
   <!-- Remplacez les boutons existants par ce code -->
<div class="db-buttons-container">
    <button class="db-button" onclick="addExternalPattern()">
        <i class="fas fa-plus"></i> Ajouter
    </button>
    <button class="db-button" onclick="copyExternalDatabase()">
        <i class="fas fa-copy"></i> Copier
    </button>
    <button class="db-button" onclick="clearExternalPatterns()">
        <i class="fas fa-trash"></i> Effacer
    </button>
    <button class="db-button" onclick="exportToTxt()">
        <i class="fas fa-file-export"></i> Exporter
    </button>
</div>
    
    <div id="externalPatternsList" style="margin-top:15px; max-height:300px; overflow-y:auto; background:white; border:1px solid #e0e0e0; border-radius:6px;"></div>
</div>
        <div class="timer-container">
            <div class="bankroll-container">
                <h3>üí∞ Gestion de Bankroll</h3>
                <div class="bankroll-input">
                    <label for="initialBankroll">Capital initial (R) :</label>
                    <input type="number" id="initialBankroll" min="1" placeholder="Ex: 1000">
                    <button onclick="setBankroll()" class="btn-bankroll">Valider</button>
                </div>
                <div class="bankroll-display">
                    <p>Capital actuel : <span id="currentBankroll">0</span> R</p>
                    <p>Derni√®re mise : <span id="lastBet">0</span> R</p>
                </div>
            </div>
            <div class="result-display">
                <p>Mise actuelle: <span id="currentBetDisplay">0</span> R</p>
                <p>Profit potentiel: <span id="profitDisplay">0</span> R</p>
                <p id="martingaleStatus" class="martingale-status"></p>
            </div>
            
            <div class="martingale-section">
                <h3>‚ö° Martingale</h3>
                
                <div class="input-group">
                    <label for="martingaleInput">S√©quence des mises (R) :</label>
                    <input type="text" id="martingaleInput" value="1,2,4,8,16,32" placeholder="1,2,4,8,16">
                    <button onclick="validateMartingale()" class="btn-validate">Valider</button>
                </div>
                
                <div class="input-group">
                    <label for="oddsInput">Cotation (%) :</label>
                    <input type="number" id="oddsInput" value="97" min="1" max="100" step="0.01">
                    <button onclick="validateOdds()" class="btn-validate">Valider</button>
                </div>
                
                <div id="martingaleSequenceDisplay" class="martingale-sequence"></div>
            </div>            
            <div class="action-buttons">
                <button class="btn-predict" onclick="predictColor()" id="predictButton">
                    <i class="fas fa-magic"></i> Pr√©dire
                </button>
                
                <button class="btn-clear" onclick="clearFields()">
                    <i class="fas fa-eraser"></i> Effacer
                </button>
                
                <button class="btn-level" onclick="showPasswordPopup()">
                    <i class="fas fa-lock"></i> Acc√®s S√©curis√©
                </button>
                
                <button class="btn-analyze" onclick="analyzeAllLosses()">
                    <i class="fas fa-search-minus"></i> Pertes
                </button>
                
                <button class="btn-analyze" onclick="forceStatisticalAnalysis()">
                    <i class="fas fa-chart-bar"></i> Stats
                </button>
            </div>
     </div>
        <div class="input-container">
            <label for="dateInput" style="margin-left: 30px;">Date :</label>
            <input type="date" id="dateInput" class="color-input">
        </div>
        <div class="input-container">
            <input type="text" id="colorInput" class="color-input" maxlength="10" placeholder="Ajouter les Couleurs (ex: RVV)" readonly>
        </div>
        <div class="input-container">
            <input type="text" id="seriesInput" class="series-input" maxlength="10" oninput="autoFillColors()" placeholder="Entrer une s√©rie de couleurs">
        </div>
        <div class="input-container">
            <input type="text" id="colorPercentage" class="color-input" readonly placeholder="Pourcentage de couleurs">
        </div>
        <p id="predictionResult"></p>
        <div class="color-buttons-grid">
            <!-- Colonne R -->
            <div class="button-column">
                <button class="btn-red" onclick="appendColor('R')">R</button>
                <button class="btn-red" onclick="appendMultiple('R', 2)">RR</button>
                <button class="btn-red" onclick="appendMultiple('R', 3)">RRR</button>
                <button class="btn-red" onclick="appendMultiple('R', 4)">RRRR</button>
            </div>
            
            <!-- Colonne V -->
            <div class="button-column">
                <button class="btn-green" onclick="appendColor('V')">V</button>
                <button class="btn-green" onclick="appendMultiple('V', 2)">VV</button>
                <button class="btn-green" onclick="appendMultiple('V', 3)">VVV</button>
                <button class="btn-green" onclick="appendMultiple('V', 4)">VVVV</button>
            </div>
        </div>
           <div class="history-header">
            <div style="display: flex; justify-content: space-between; width: 100%;">
                <div>
                    <button class="btn-undo" onclick="undoLastPrediction()">Annuler la pr√©diction</button>
                </div>
                <div>
                    <button class="btn-export" onclick="exportToTxt()" style="margin-left: 10px;">
                        <i class="fas fa-file-text"></i> Exporter
                    </button>
                </div>
            </div>
        </div>
        <div class="stats-container">
            <div class="color-stats red-stats" id="redStats">
                <div class="stats-header"><span style="color:#dc3545">üî¥</span> Statistiques Rouge</div>
                <div class="stats-value" id="redSuccessCount">0 succ√®s</div>
                <div class="stats-value" id="redFailureCount">0 √©checs</div>
                <div class="stats-percentage" id="redSuccessRate">0% de r√©ussite</div>
                <div id="redTrend" style="margin-top:10px;"></div>
            </div>
            <div class="color-stats green-stats" id="greenStats">
                <div class="stats-header"><span style="color:#28a745">üü¢</span> Statistiques Vert</div>
                <div class="stats-value" id="greenSuccessCount">0 succ√®s</div>
                <div class="stats-value" id="greenFailureCount">0 √©checs</div>
                <div class="stats-percentage" id="greenSuccessRate">0% de r√©ussite</div>
                <div id="greenTrend" style="margin-top:10px;"></div>
            </div>
        </div>
        <div class="db-buttons-container">
            <!-- Vos autres boutons... -->
            <button class="db-button" onclick="copyHistoryInDBFormat()">
                <i class="fas fa-copy"></i> Copier
            </button>
        </div>
        <div id="forceModeAlert" class="alert alert-warning" style="display:none; background:#fff3cd; padding:15px; border-radius:5px; border-left:5px solid #ffc107; margin-bottom:20px;">
            <strong>‚ö†Ô∏è Mode Forc√© Activ√©</strong> 
            <p>2 pertes cons√©cutives d√©tect√©es. Le bot force maintenant les pr√©dictions sur <span id="forcedColorText"></span> jusqu'au prochain gain.</p>
        </div>
        <div id="historyContainer" class="table-container">
            <table>
                <thead>
                </thead>
                <tbody id="history">
                </tbody>
            </table>
          
       </div>
       <div class="level-popup" id="levelPopup">
        <h2>Choisissez votre Niveau</h2>
        <div class="level-buttons">
            <label><input type="radio" name="level" value="d√©butant" checked> D√©butant</label>
            <label><input type="radio" name="level" value="interm√©diaire"> Interm√©diaire</label>
            <label><input type="radio" name="level" value="avanc√©"> Avanc√©</label>
        </div>
        <button class="btn-confirm" onclick="confirmLevel()">Confirmer</button>
    </div>
       <p id="previousResult"></p>
        <div style="display: flex; align-items: center; gap: 20px;">
             <div style="position: relative; width: 100%; height: 100vh;">
        <button class="btn-undo" onclick="undo()" style="position: absolute; top: 80px; right:20px;">Marche Arri√®re</button>
        
        <div class="feedback-buttons">
            <button class="btn-success" id="btnSuccess" onclick="giveFeedback(true)">Gagner ‚úÖ</button>
            <button class="btn-failure" id="btnFailure" onclick="giveFeedback(false)">Perte ‚ùå</button>
            <button class="btn-history" onclick="clearHistory()">Effacer l'Historique</button>
        </div>
        <div class="stats">
            <p id="successRate">Taux de r√©ussite : <span>0%</span></p>
            <p id="totalPredictions">Total des Pr√©dictions : <span>0</span></p>
            <p id="totalSuccesses">Total des R√©ussites : <span>0</span></p>
            <p id="totalFailures">Total des Pertes : <span>0</span></p>
            <!-- Mets √ßa juste apr√®s la ligne des points -->
            <p id="maxConsecutiveLosses">Plus grande s√©rie de pertes : <span>0</span></p>
            <p id="lionCoins">Lion Coins : <span>0</span> LC</p>
            <p id="points">Points : <span>0</span></p>
        </div>
        <canvas id="pieChart" width="400" height="400"></canvas>
        
    </div>
    <div class="level-info-popup" id="levelInfoPopup">
        <button class="close-btn" onclick="hideLevelInfo()">X</button>
        <h2>Information de Niveau</h2>

    </div>
    <script>
        // Variables pour la base de donn√©es externe
let externalPatterns = JSON.parse(localStorage.getItem('externalPatterns')) || [];

// Fonction pour basculer l'interface
function toggleExternalDBInterface() {
    const interface = document.getElementById('externalDBInterface');
    interface.style.display = interface.style.display === 'none' ? 'block' : 'none';
    if (interface.style.display === 'block') {
        loadExternalPatterns();
    }
}
function updateExternalStats() {
    externalStats.total = externalPatterns.length;
    externalStats.successes = externalPatterns.filter(p => p.result === 'Succ√®s').length;
    externalStats.failures = externalPatterns.filter(p => p.result === '√âchec').length;
    externalStats.successRate = externalStats.total > 0 ? 
        ((externalStats.successes / externalStats.total) * 100).toFixed(1) : 0;
    
    displayExternalStats();
}
// Fonction pour afficher les statistiques
function displayExternalStats() {
    const statsHtml = `
        <div style="background:#f8f9fa; padding:15px; border-radius:8px; margin:10px 0; border:1px solid #dee2e6;">
            <h4 style="margin:0 0 10px 0; color:#333;">üìä Statistiques de la Base</h4>
            <div style="display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; text-align:center;">
                <div>
                    <strong style="color:#007bff;">${externalStats.total}</strong>
                    <div style="font-size:12px; color:#666;">Total</div>
                </div>
                <div>
                    <strong style="color:#28a745;">${externalStats.successes}</strong>
                    <div style="font-size:12px; color:#666;">Succ√®s</div>
                </div>
                <div>
                    <strong style="color:#dc3545;">${externalStats.failures}</strong>
                    <div style="font-size:12px; color:#666;">√âchecs</div>
                </div>
                <div>
                    <strong style="color:#17a2b8;">${externalStats.successRate}%</strong>
                    <div style="font-size:12px; color:#666;">Taux de r√©ussite</div>
                </div>
            </div>
        </div>
    `;

    // Ins√©rer les stats avant la liste des motifs
    const container = document.getElementById('externalDBInterface');
    const patternsList = document.getElementById('externalPatternsList');
    
    // Supprimer les anciennes stats si elles existent
    const oldStats = container.querySelector('.external-stats');
    if (oldStats) {
        oldStats.remove();
    }

    // Cr√©er et ins√©rer les nouvelles stats
    const statsDiv = document.createElement('div');
    statsDiv.className = 'external-stats';
    statsDiv.innerHTML = statsHtml;
    container.insertBefore(statsDiv, patternsList);
}
// Fonction pour ajouter un motif
function loadExternalPatterns() {
    const container = document.getElementById('externalPatternsList');
    container.innerHTML = '';

    if (externalPatterns.length === 0) {
        container.innerHTML = '<p style="padding:15px;color:#666">Aucun motif externe enregistr√©</p>';
        return;
    }

    const table = document.createElement('table');
    table.className = 'external-patterns-table';
    table.innerHTML = `
        <thead>
            <tr>
                <th>N¬∞</th>
                <th>Date</th>
                <th>Couleurs</th>
                <th>Pr√©diction</th>
                <th>% Couleurs</th>
                <th>R√©sultat</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody></tbody>
    `;

    externalPatterns.forEach((pattern, index) => {
        const row = document.createElement('tr');
        
        // Formatage des couleurs pour l'affichage
        const colorsDisplay = pattern.colors.split(', ').map(c => 
            c === 'rouge' ? '<span class="red-dot">üî¥</span>' : 
            '<span class="green-dot">üü¢</span>'
        ).join(' ');
        
        row.innerHTML = `
            <td>${pattern.tradeNumber}</td>
            <td>${pattern.date}</td>
            <td>${colorsDisplay}</td>
            <td style="color:${pattern.prediction === 'rouge' ? '#dc3545' : '#28a745'};font-weight:bold">
                ${pattern.prediction.toUpperCase()}
            </td>
            <td>${pattern.frequentColor}</td>
            <td>${pattern.result ? 
                (pattern.result === 'Succ√®s' ? 
                    '<span style="color:#28a745">‚úÖ Succ√®s</span>' : 
                    '<span style="color:#dc3545">‚ùå √âchec</span>'
                ) : '‚è≥ En attente'}</td>
            <td style="display:flex; flex-direction:column; gap:5px; align-items:center; padding:8px;">
                <button onclick="editExternalPattern(${index})" class="btn-edit" style="margin-bottom:5px; width:100%;">
                    <i class="fas fa-edit"></i> Modifier
                </button>
                <button onclick="removeExternalPattern(${index})" class="btn-delete" style="width:100%;">
                    <i class="fas fa-trash"></i> Supprimer
                </button>
            </td>
        `;
        table.querySelector('tbody').appendChild(row);
    });

    container.appendChild(table);
    updateExternalStats();
}
function copyExternalDatabase() {
    const formattedData = externalPatterns.map(pattern => {
        return `${pattern.date} - ${pattern.colors} - ${pattern.prediction} - ${pattern.result}`;
    }).join('\n');

    navigator.clipboard.writeText(formattedData).then(() => {
        Swal.fire({
            title: 'Base de donn√©es copi√©e !',
            text: `${externalPatterns.length} entr√©es copi√©es dans le presse-papiers`,
            icon: 'success',
            timer: 2000,
            showConfirmButton: false
        });
    });
}
function addExternalPattern() {
    const input = document.getElementById('externalPatternInput').value.trim();
    if (!input) {
        Swal.fire({
            title: 'Erreur',
            text: 'Veuillez entrer un motif',
            icon: 'error'
        });
        return;
    }

    try {
        // S√©parer les lignes
        const patternLines = input.split('\n');
        const newPatterns = [];
        
        for (const line of patternLines) {
            if (!line.trim()) continue;
            
            // Extraire les parties selon le format
            const parts = line.split(' - ').map(p => p.trim());
            if (parts.length < 3) {
                throw new Error(`Format invalide pour la ligne: "${line}"`);
            }
            
            const date = parts[0];
            const colorsPart = parts[1];
            const predictionPart = parts[2];
            const resultPart = parts[3] || ''; // R√©sultat optionnel
            
            // Valider et convertir les couleurs
            const colors = colorsPart.split(', ').map(c => {
                if (!['rouge', 'vert', 'R', 'V'].includes(c)) {
                    throw new Error(`Couleur invalide: "${c}"`);
                }
                return c === 'rouge' || c === 'R' ? 'rouge' : 'vert';
            });
            
            if (colors.length !== 10) {
                throw new Error(`Doit avoir exactement 10 couleurs (${colors.length} fournies)`);
            }
            
            // Valider la pr√©diction
            const prediction = predictionPart === 'rouge' || predictionPart === 'R' ? 'rouge' : 
                             predictionPart === 'vert' || predictionPart === 'V' ? 'vert' : '';
            if (!prediction) {
                throw new Error(`Pr√©diction invalide: "${predictionPart}"`);
            }
            
            // Valider le r√©sultat si pr√©sent
            const result = resultPart ? 
                (resultPart === 'Succ√®s' || resultPart === '√âchec' ? resultPart : '') : '';
            
            // Calculer le pourcentage de couleur
            const redCount = colors.filter(c => c === 'rouge').length;
            const greenCount = colors.filter(c => c === 'vert').length;
            
            newPatterns.push({
                tradeNumber: externalPatterns.length + newPatterns.length + 1,
                date: date,
                colors: colors.join(', '),
                prediction: prediction,
                frequentColor: redCount >= greenCount ? 
                    `${(redCount/colors.length*100).toFixed(0)}% Rouge` : 
                    `${(greenCount/colors.length*100).toFixed(0)}% Vert`,
                result: result,
                method: 'external'
            });
        }

        // Ajouter tous les nouveaux motifs
        externalPatterns.push(...newPatterns);
        localStorage.setItem('externalPatterns', JSON.stringify(externalPatterns));
        
        loadExternalPatterns();
        document.getElementById('externalPatternInput').value = '';
        
        Swal.fire({
            title: 'Succ√®s',
            html: `${newPatterns.length} motif(s) ajout√©(s) au bon format`,
            icon: 'success'
        });

    } catch (error) {
        Swal.fire({
            title: 'Erreur de format',
            html: `
                <p>${error.message}</p>
                <p>Format attendu pour chaque ligne :</p>
                <p><strong>JJ/MM/AAAA - V,V,V,V,V,V,V,V,V,V - V - Succ√®s</strong></p>
                <p>Exemple :</p>
                <p>16/04/2025 - vert, vert, vert, vert, vert, vert, vert, vert, vert, vert - vert - Succ√®s</p>
            `,
            icon: 'error'
        });
    }
}
function sortPatterns(field) {
    if (currentSortField === field) {
        sortDirection *= -1; // Inverse la direction
    } else {
        currentSortField = field;
        sortDirection = 1;
    }

    externalPatterns.sort((a, b) => {
        // Pour les dates
        if (field === 'date') {
            return (new Date(a.date) - new Date(b.date)) * sortDirection;
        }
        // Pour les r√©sultats (Succ√®s avant √âchec)
        if (field === 'result') {
            return (a.result.localeCompare(b.result)) * sortDirection;
        }
        // Par d√©faut : tri alphab√©tique
        return (a[field].localeCompare(b[field])) * sortDirection;
    });

    loadExternalPatterns();
}

function filterPatterns() {
    const searchText = document.getElementById('patternSearch').value.toLowerCase();
    const filtered = externalPatterns.filter(pattern => 
        pattern.date.toLowerCase().includes(searchText) ||
        pattern.colors.toLowerCase().includes(searchText) ||
        pattern.prediction.toLowerCase().includes(searchText) ||
        pattern.result.toLowerCase().includes(searchText)
    );
    
    // Afficher les r√©sultats filtr√©s
    const rows = document.querySelectorAll('.external-patterns-table tbody tr');
    rows.forEach(row => {
        const rowText = row.textContent.toLowerCase();
        row.style.display = rowText.includes(searchText) ? '' : 'none';
    });
}

function editExternalPattern(index) {
    const pattern = externalPatterns[index];
    
    // Convertir les couleurs au format RV (ex: "vert, rouge" -> "V, R")
    const colorsToRV = pattern.colors.split(', ').map(c => 
        c === 'rouge' ? 'R' : 'V'
    ).join(', ');
    
    Swal.fire({
        title: 'Modifier le motif',
        html: `
            <div style="text-align:left;margin:15px 0">
                <div style="margin-bottom:10px">
                    <label>Date (JJ/MM/AAAA):</label>
                    <input id="editDate" value="${pattern.date}" class="swal2-input" placeholder="16/04/2025">
                </div>
                <div style="margin-bottom:10px">
                    <label>Couleurs (R,V,R,V...):</label>
                    <input id="editColors" value="${colorsToRV}" class="swal2-input" placeholder="V,V,V,V,V,V,V,V,V,V">
                </div>
                <div style="margin-bottom:10px">
                    <label>Pr√©diction:</label>
                    <select id="editPrediction" class="swal2-input">
                        <option value="R" ${pattern.prediction === 'rouge' ? 'selected' : ''}>Rouge (R)</option>
                        <option value="V" ${pattern.prediction === 'vert' ? 'selected' : ''}>Vert (V)</option>
                    </select>
                </div>
                <div>
                    <label>R√©sultat:</label>
                    <select id="editResult" class="swal2-input">
                        <option value="Succ√®s" ${pattern.result === 'Succ√®s' ? 'selected' : ''}>Succ√®s</option>
                        <option value="√âchec" ${pattern.result === '√âchec' ? 'selected' : ''}>√âchec</option>
                    </select>
                </div>
            </div>
        `,
        showCancelButton: true,
        confirmButtonText: 'Enregistrer',
        cancelButtonText: 'Annuler',
        preConfirm: () => {
            // Validation des donn√©es
            const dateInput = document.getElementById('editDate').value.trim();
            const colorsInput = document.getElementById('editColors').value.trim().toUpperCase();
            
            if (!dateInput || !colorsInput) {
                Swal.showValidationMessage('Tous les champs sont obligatoires');
                return false;
            }
            
            // Valider le format des couleurs
            if (!/^[RV](,[RV]){9}$/.test(colorsInput)) {
                Swal.showValidationMessage('Format couleurs invalide. Doit √™tre 10 couleurs s√©par√©es par des virgules (ex: V,V,V,R,V,V,R,V,V,V)');
                return false;
            }
            
            return {
                date: dateInput,
                colors: colorsInput.split(',').map(c => c.trim() === 'R' ? 'rouge' : 'vert').join(', '),
                prediction: document.getElementById('editPrediction').value === 'R' ? 'rouge' : 'vert',
                result: document.getElementById('editResult').value,
                tradeNumber: pattern.tradeNumber, // Conserver le num√©ro original
                timestamp: new Date().toISOString()
            };
        }
    }).then(result => {
        if (result.isConfirmed) {
            // Calculer le pourcentage de couleurs
            const colors = result.value.colors.split(', ');
            const redCount = colors.filter(c => c === 'rouge').length;
            const greenCount = colors.filter(c => c === 'vert').length;
            
            externalPatterns[index] = {
                ...result.value,
                frequentColor: redCount >= greenCount ? 
                    `${(redCount/colors.length*100).toFixed(0)}% Rouge` : 
                    `${(greenCount/colors.length*100).toFixed(0)}% Vert`
            };
            
            localStorage.setItem('externalPatterns', JSON.stringify(externalPatterns));
            loadExternalPatterns();
            Swal.fire('Succ√®s!', 'Motif mis √† jour avec le bon format', 'success');
        }
    });
}
function removeExternalPattern(index) {
    Swal.fire({
        title: 'Confirmer la suppression',
        html: `
            <p>Voulez-vous vraiment supprimer ce motif?</p>
            <div style="background:#f8f9fa;padding:10px;border-radius:5px;margin-top:10px">
                <p><strong>Date:</strong> ${externalPatterns[index].date}</p>
                <p><strong>Couleurs:</strong> ${externalPatterns[index].colors}</p>
                <p><strong>R√©sultat:</strong> ${externalPatterns[index].result}</p>
            </div>
        `,
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'Oui, supprimer',
        cancelButtonText: 'Annuler',
        confirmButtonColor: '#dc3545'
    }).then((result) => {
        if (result.isConfirmed) {
            externalPatterns.splice(index, 1);
            localStorage.setItem('externalPatterns', JSON.stringify(externalPatterns));
            loadExternalPatterns();
            updateExternalStats(); // Ajouter cette ligne
            Swal.fire('Supprim√©!', 'Le motif a √©t√© supprim√©.', 'success');
        }
    });
}
function clearExternalPatterns() {
    if (externalPatterns.length === 0) {
        Swal.fire('Info', 'La base est d√©j√† vide', 'info');
        return;
    }

    Swal.fire({
        title: 'Confirmer la suppression compl√®te',
        html: `
            <p>Voulez-vous vraiment supprimer <strong>TOUS</strong> les motifs (${externalPatterns.length})?</p>
            <p style="color:#dc3545">Cette action est irr√©versible!</p>
        `,
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'Oui, tout supprimer',
        cancelButtonText: 'Annuler',
        confirmButtonColor: '#dc3545',
        backdrop: `
            rgba(220,53,69,0.4)
            url("/images/delete.gif")
            left top
            no-repeat
        `
    }).then((result) => {
        if (result.isConfirmed) {
            externalPatterns = [];
            localStorage.removeItem('externalPatterns');
            loadExternalPatterns();
            Swal.fire(
                'Supprim√©!',
                'Tous les motifs ont √©t√© effac√©s.',
                'success'
            );
        }
    });
}
function forceStatisticalAnalysis() {
    const colorInput = document.getElementById('seriesInput').value.toUpperCase().replace(/[^RV]/g, '');
    
    // Validation
    if (colorInput.length < 5) {
        Swal.fire({
            title: 'Donn√©es insuffisantes',
            text: 'Entrez au moins 5 couleurs pour une analyse fiable',
            icon: 'warning',
            confirmButtonColor: '#ffc107'
        });
        return;
    }

    // Ex√©cution de l'analyse
    const analysis = analyzeAndRecommend(colorInput);
    
    // Affichage d√©taill√©
    Swal.fire({
        title: 'üìä Rapport Statistique Complet',
        html: `
            <div style="text-align: left; margin: 15px 0;">
                <p><strong>Recommandation :</strong> ${analysis.recommendation.message}</p>
                <p><strong>Pr√©diction prioritaire :</strong> ${analysis.recommendation.primary === 'rouge' ? 'üî¥ ROUGE' : 'üü¢ VERT'}</p>
                ${analysis.recommendation.secondary ? `<p><strong>Alternative :</strong> ${analysis.recommendation.secondary === 'rouge' ? 'üî¥ ROUGE' : 'üü¢ VERT'}</p>` : ''}
            </div>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 10px;">
                <h4 style="margin-top: 0;">D√©tails Techniques :</h4>
                <ul style="text-align: left;">
                    <li>üî¥ Rouge total : ${analysis.trends['üî¥'] || 0} (${Math.round((analysis.trends['üî¥']/colorInput.length)*100)}%)</li>
                    <li>üü¢ Vert total : ${analysis.trends['üü¢'] || 0} (${Math.round((analysis.trends['üü¢']/colorInput.length)*100)}%)</li>
                    <li>Plus longue s√©rie üî¥ : ${analysis.streaks['üî¥'] || 0}</li>
                    <li>Plus longue s√©rie üü¢ : ${analysis.streaks['üü¢'] || 0}</li>
                </ul>
            </div>
        `,
        showCancelButton: true,
        confirmButtonText: 'Appliquer cette pr√©diction',
        cancelButtonText: 'Fermer',
        confirmButtonColor: '#28a745',
        width: '650px'
    }).then((result) => {
        if (result.isConfirmed) {
            // Applique automatiquement la pr√©diction
            document.getElementById('seriesInput').value = colorInput.slice(-10); // Garde les 10 derniers
            document.getElementById('colorInput').value = colorInput.slice(-10);
            predictColor(); // D√©clenche le processus normal
        }
    });
}
let initialBankroll = 0;
let currentBankroll = 0;
let lastBetAmount = 0;

function setBankroll() {
    const bankrollInput = document.getElementById('initialBankroll').value;
    
    // Validation du montant saisi
    if (!bankrollInput || isNaN(bankrollInput) || parseFloat(bankrollInput) <= 0) {
        Swal.fire({
            title: 'Erreur',
            text: 'Veuillez entrer un montant valide pour votre capital',
            icon: 'error'
        });
        return;
    }
    
    initialBankroll = parseFloat(bankrollInput);
    currentBankroll = initialBankroll;
    updateBankrollDisplay();
    
    // Afficher l'alerte de succ√®s
    Swal.fire({
        title: 'Capital enregistr√©! üí∞',
        html: `
            <div style="font-size: 2.5rem;">‚úÖ</div>
            <p>Votre capital initial a √©t√© d√©fini √† :</p>
            <p style="font-size: 1.5rem; font-weight: bold; color: #28a745;">${initialBankroll.toFixed(2)} R</p>
            <p>Vous pouvez maintenant commencer √† trader.</p>
        `,
        icon: 'success',
        confirmButtonText: 'Commencer',
        confirmButtonColor: '#28a745',
        timer: 3000,
        timerProgressBar: true,
        background: '#f8f9fa',
        showClass: {
            popup: 'animate__animated animate__fadeInDown'
        },
        hideClass: {
            popup: 'animate__animated animate__fadeOutUp'
        }
    });
}
function updateBankrollDisplay() {
    document.getElementById('currentBankroll').textContent = currentBankroll.toFixed(2);
    document.getElementById('lastBet').textContent = lastBetAmount.toFixed(2);
}

let martingaleSequence = [1, 2, 4, 8, 16, 32];
let currentMartingaleIndex = 0;
function validateOdds() {
    const oddsInput = document.getElementById('oddsInput');
    const odds = parseFloat(oddsInput.value);
    
    // Validation stricte (entre 1 et 100)
    if (isNaN(odds) || odds < 1 || odds > 100) {
        oddsInput.value = 97; // Valeur par d√©faut si invalide
        Swal.fire({
            title: 'Erreur',
            text: 'Veuillez entrer une cotation valide entre 1% et 100%',
            icon: 'error'
        });
        return;
    }
    
    // Arrondir √† 2 d√©cimales
    const roundedOdds = Math.round(odds * 100) / 100;
    oddsInput.value = roundedOdds;
    
    Swal.fire({
        title: 'Cotation valid√©e!',
        html: `Nouvelle cotation : <strong>${roundedOdds}%</strong>`,
        icon: 'success',
        timer: 1500
    });
    
    updateMartingaleDisplay();
}
function validateMartingale() {
    const input = document.getElementById('martingaleInput').value;
    martingaleSequence = input.split(',').map(Number).filter(n => !isNaN(n));
    if (martingaleSequence.length === 0) martingaleSequence = [1];
    
    Swal.fire({
        title: 'Succ√®s!',
        text: `S√©quence martingale mise √† jour : ${martingaleSequence.join(', ')}`,
        icon: 'success'
    });
    
    updateMartingaleDisplay();
}

function updateMartingaleDisplay() {
    const nextBet = getCurrentBet();
    const odds = parseFloat(document.getElementById('oddsInput').value) || 97; // 97 par d√©faut
    
    document.getElementById('currentBetDisplay').textContent = nextBet.toFixed(2);
    document.getElementById('profitDisplay').textContent = (nextBet * (odds / 100)).toFixed(2);
    
    // Afficher le statut en temps r√©el
    document.getElementById('martingaleStatus').innerHTML = `
        <small>S√©quence: ${martingaleSequence.join(', ')} | Cote: ${odds}%</small>
    `;
}
function getCurrentBet() {
    return martingaleSequence[currentMartingaleIndex] || martingaleSequence[0];
}

// √Ä appeler quand le trade gagne
function onWin() {
    const profit = getCurrentBet() * (parseFloat(document.getElementById('oddsInput').value) / 100);
    currentBankroll += profit;
    currentMartingaleIndex = 0; // R√©initialiser la martingale
    updateBankrollDisplay();
    updateMartingaleDisplay();
    return profit;
}

// √Ä appeler quand le trade perd
function onLoss() {
    const loss = getCurrentBet();
    currentBankroll -= loss;
    lastBetAmount = loss;
    currentMartingaleIndex = Math.min(currentMartingaleIndex + 1, martingaleSequence.length - 1);
    updateBankrollDisplay();
    updateMartingaleDisplay();
    return -loss;
}
function applyMartingale() {
    const input = document.getElementById('martingaleSequence').value;
    martingaleSequence = input.split(',').map(Number).filter(n => !isNaN(n));
    if (martingaleSequence.length === 0) martingaleSequence = [1];
    updateDisplay();
    Swal.fire('Succ√®s!', 'S√©quence martingale mise √† jour', 'success');
}

function calculateProfit() {
    updateDisplay();
}

function updateDisplay() {
    const odds = (document.getElementById('simpleOdds').value || 97) / 100;
    const nextBet = martingaleSequence[currentMartingaleIndex] || martingaleSequence[0];
    document.getElementById('nextBet').textContent = nextBet;
    document.getElementById('potentialProfit').textContent = (nextBet * odds).toFixed(2);
}

function getCurrentBet() {
    return martingaleSequence[currentMartingaleIndex] || martingaleSequence[0];
}

// √Ä appeler quand le trade gagne
function onWin() {
    currentMartingaleIndex = 0;
    updateDisplay();
    return getCurrentBet() * (document.getElementById('simpleOdds').value / 100);
}

// √Ä appeler quand le trade perd
function onLoss() {
    currentMartingaleIndex = Math.min(currentMartingaleIndex + 1, martingaleSequence.length - 1);
    updateDisplay();
    return -getCurrentBet();
}
         function updateHaitiTime() {
    const options = {
        timeZone: 'America/Port-au-Prince', // Fuseau horaire d'Ha√Øti
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false // Format 24 heures
    };

    // Obtenir l'heure actuelle
    const now = new Date();

    // Ajouter 2 secondes pour compenser le d√©calage
    now.setSeconds(now.getSeconds() + 2);

    // Formater l'heure
    const formatter = new Intl.DateTimeFormat('fr-FR', options);
    const currentTime = formatter.format(now);

    // Afficher l'heure
    document.getElementById('currentTime').textContent = currentTime;
}

// Mettre √† jour l'heure toutes les secondes
setInterval(updateHaitiTime, 1000);

// Appeler la fonction une fois au chargement de la page
updateHaitiTime();
         function appendMultiple(color, count) {
    for (let i = 0; i < count; i++) {
        appendColor(color); // Utilise la fonction existante pour ajouter une couleur
    }
}
        // Fonction pour afficher la popup de notification
        function showNotificationPopup() {
            const savedName = localStorage.getItem('userName');
            const savedLevel = localStorage.getItem('userLevel');

            // V√©rifie si le nom et le niveau sont d√©j√† sauvegard√©s
            if (savedName && savedLevel) {
                // Affiche la popup de notification
                document.getElementById('notificationPopup').style.display = 'flex';
            }
        }

        // Fonction pour g√©rer la r√©ponse de l'utilisateur
        function handleNotificationResponse(isConfirmed) {
            if (isConfirmed) {
                // Si l'utilisateur confirme, on cache la popup
                document.getElementById('notificationPopup').style.display = 'none';
            } else {
                // Si l'utilisateur n'est pas satisfait, on lui permet de resaisir ses informations
                localStorage.removeItem('userName');
                localStorage.removeItem('userLevel');
                document.getElementById('notificationPopup').style.display = 'none';
                validateUserName(); // Redemande le nom
                showLevelPopup(); // Redemande le niveau
            }
        }

        // Fonction pour sauvegarder les statistiques dans le localStorage
        function saveStatsToLocalStorage() {
            localStorage.setItem('totalPredictions', history.length);
            localStorage.setItem('totalSuccesses', successes);
            localStorage.setItem('totalFailures', failures);
            localStorage.setItem('maxConsecutiveLosses', maxConsecutiveLosses);
             localStorage.setItem('totalPoints', points);

        }

        // Fonction pour charger les statistiques depuis le localStorage
        function loadStatsFromLocalStorage() {
            const storedTotalPredictions = localStorage.getItem('totalPredictions');
            const storedTotalSuccesses = localStorage.getItem('totalSuccesses');
            const storedTotalFailures = localStorage.getItem('totalFailures');
            maxConsecutiveLosses = parseInt(localStorage.getItem('maxConsecutiveLosses')) || 0;
            points = parseInt(localStorage.getItem('totalPoints')) || 0;

            if (storedTotalPredictions) {
                history.length = parseInt(storedTotalPredictions);
            }
            if (storedTotalSuccesses) {
                successes = parseInt(storedTotalSuccesses);
            }
            if (storedTotalFailures) {
                failures = parseInt(storedTotalFailures);
            }
        }

        // Appelle les fonctions de sauvegarde des statistiques avant de quitter la page
        window.addEventListener('beforeunload', (event) => {
            saveStatsToLocalStorage();

            // Affiche une confirmation pour quitter l'application
            event.preventDefault();
            event.returnValue = 'Voulez-vous vraiment quitter l\'application ?';
        });

        // Appelle la fonction showNotificationPopup() au chargement de la page
        document.addEventListener('DOMContentLoaded', () => {
            loadHistoryFromLocalStorage();
            loadStatsFromLocalStorage();
            showTutorial();
            validateUserName();
            showLevelPopup();
            updateLevelButtons();
            showNotificationPopup(); // Affiche la popup de notification
            updateStats();
            updateSuccessRate();
            updatePoints();
            updateLionCoins();
            document.getElementById('maxConsecutiveLosses').innerHTML = 
            `Plus grande s√©rie de pertes : <span>${maxConsecutiveLosses}</span>`;
        });

          // Variables globales existantes
let history = [];
let previousHistory = [];
let consecutiveLosses = 0; // D√©j√† d√©clar√© ici
let bannedPatterns = []; // Pour stocker les motifs temporairement interdits
let successes = 0;
let failures = 0;
let failedPatterns = {}; // Pour stocker les motifs ayant √©chou√©
let points = localStorage.getItem('totalPoints') ? parseInt(localStorage.getItem('totalPoints')) : 0;
let lastResultWasLoss = false;
let timerInterval;
let timerTime = 0;
let isTimerRunning = false;
let redSuccesses = 0;
let redFailures = 0;
let greenSuccesses = 0;
let greenFailures = 0;
let isForceModeActive = false;
let forcedColor = '';
// Variables globales
// Variables pour les pertes cons√©cutives
let maxConsecutiveLosses = parseInt(localStorage.getItem('maxConsecutiveLosses')) || 0;
let currentConsecutiveLosses = 0;
// Mets √ßa avec les autres variables (let history = [], etc.)
const LION_COIN_RATE = 0.1; // 10 points = 1 Lion Coin
let externalStats = {
    total: 0,
    successes: 0,
    failures: 0,
    successRate: 0
};




// Fonction pour d√©marrer le minuteur
function startTimer(minutes) {
    if (isTimerRunning) {
        Swal.fire({
            title: 'Minuteur d√©j√† en cours ‚è∞',
            text: 'Veuillez attendre que le minuteur actuel se termine.',
            icon: 'warning',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#ffc107',
            background: '#fff3cd',
            iconColor: '#ffc107',
        });
        return;
    }
    // Gestion des champs de mot de passe pour les niveaux
document.querySelectorAll('input[name="level"]').forEach(radio => {
    radio.addEventListener('change', function() {
        document.getElementById('intermediatePasswordContainer').style.display = 'none';
        document.getElementById('advancedPasswordContainer').style.display = 'none';
        
        if (this.value === 'interm√©diaire') {
            document.getElementById('intermediatePasswordContainer').style.display = 'block';
        } else if (this.value === 'avanc√©') {
            document.getElementById('advancedPasswordContainer').style.display = 'block';
        }
    });
});

function confirmLevel() {
    const level = document.querySelector('input[name="level"]:checked').value;
    
    if (level === "interm√©diaire" || level === "avanc√©") {
        Swal.fire({
            title: 'Mot de passe requis',
            input: 'password',
            showCancelButton: true,
            confirmButtonText: 'Valider',
            cancelButtonText: 'Annuler'
        }).then((result) => {
            if (result.isConfirmed) {
                alert("Mot de passe accept√© !");
            }
        });
    } else {
        alert("Niveau d√©butant s√©lectionn√©");
    }
}

function showPasswordPopup(level) {
    Swal.fire({
        title: `Acc√®s ${level} üîí`,
        html: `Veuillez entrer le mot de passe pour le niveau <strong>${level}</strong>`,
        input: 'password',
        inputPlaceholder: 'Mot de passe...',
        inputAttributes: {
            autocapitalize: 'off',
            autocorrect: 'off'
        },
        showCancelButton: true,
        confirmButtonText: 'Valider',
        cancelButtonText: 'Annuler',
        allowOutsideClick: false,
        preConfirm: (password) => {
            if (password !== LEVEL_PASSWORDS[level]) {
                Swal.showValidationMessage('Mot de passe incorrect');
                return false;
            }
            return true;
        }
    }).then((result) => {
        if (result.isConfirmed) {
            setUserLevel(level);
        } else {
            // Re-s√©lectionne le niveau d√©butant si annulation
            document.querySelector('input[value="d√©butant"]').checked = true;
        }
    });
}

// D√©finissez vos mots de passe (√† changer pour la production)
const LEVEL_PASSWORDS = {
    "interm√©diaire": "123",
    "avanc√©": "456"
};
function setUserLevel(level) {
    localStorage.setItem('userLevel', level);
    document.getElementById('userLevelSpan').textContent = level;
    document.getElementById('levelPopup').style.display = 'none';
    
    Swal.fire({
        title: 'Succ√®s !',
        text: `Vous √™tes maintenant niveau ${level}`,
        icon: 'success'
    });
    
    // Mettre √† jour l'interface selon le niveau
    updateInterfaceForLevel(level);
}
function updateInterfaceForLevel(level) {
    // D√©sactiver certaines fonctionnalit√©s pour les niveaux inf√©rieurs
    if (level === "d√©butant") {
        // D√©sactiver les boutons avanc√©s
        document.querySelector('.btn-analyze').style.display = 'none';
    } else {
        // Activer tous les boutons
        document.querySelector('.btn-analyze').style.display = 'inline-block';
    }
}
function showLevelPopup() {
    // S√©lection automatique du niveau d√©butant si aucun niveau n'est d√©fini
    if (!localStorage.getItem('userLevel')) {
        document.querySelector('input[value="d√©butant"]').checked = true;
    }
    document.getElementById('levelPopup').style.display = 'block';
}
// D√©marrer le minuteur
    timerTime = minutes * 60; // Convertir en secondes
    isTimerRunning = true;
  
    // D√©sactiver tous les boutons du bot
    document.querySelectorAll('button').forEach(button => button.disabled = true);

    // Afficher l'alerte SweetAlert pour bloquer l'acc√®s
    Swal.fire({
        title: 'Minuteur activ√© ‚è≥',
        html: `
            <p>Le bot est d√©sactiv√© pendant <strong>${minutes} minutes</strong>.</p>
            <p>Veuillez patienter jusqu'√† la fin du minuteur.</p>
            <p id="swalTimer">Temps restant : ${minutes}:00</p>
        `,
        icon: 'info',
        showConfirmButton: false,
        allowOutsideClick: false,
        allowEscapeKey: false,
        allowEnterKey: false,
        background: '#f0f8ff',
        iconColor: '#007bff',
    });

    // Mettre √† jour le minuteur dans l'alerte et dans l'interface
    timerInterval = setInterval(() => {
        timerTime--;
        if (timerTime <= 0) {
            clearInterval(timerInterval);
            isTimerRunning = false;

            // R√©activer tous les boutons du bot
            document.querySelectorAll('button').forEach(button => button.disabled = false);

            // Fermer l'alerte SweetAlert
            Swal.close();

            // Afficher un message de fin
            Swal.fire({
                title: 'Minuteur termin√© ‚è∞',
                text: 'Le bot est maintenant r√©activ√©. Vous pouvez continuer √† utiliser le bot.',
                icon: 'success',
                confirmButtonText: 'Compris',
                confirmButtonColor: '#28a745',
                background: '#f0f9f0',
                iconColor: '#28a745',
            });

            // R√©initialiser l'affichage du minuteur
            document.getElementById('timerDisplay').textContent = 'Temps restant : 00:00';
            return;
        }

        // Mettre √† jour l'affichage du minuteur dans l'alerte et dans l'interface
        const minutesLeft = Math.floor(timerTime / 60);
        const secondsLeft = timerTime % 60;
        const timerText = `Temps restant : ${minutesLeft.toString().padStart(2, '0')}:${secondsLeft.toString().padStart(2, '0')}`;
        document.getElementById('timerDisplay').textContent = timerText;

        if (Swal.isVisible()) {
            Swal.getHtmlContainer().querySelector('#swalTimer').textContent = timerText;
        }
    }, 1000);
}
function updateTimerDisplay() {
    const minutes = Math.floor(timerTime / 60);
    const seconds = timerTime % 60;
    document.getElementById('timerDisplay').textContent = `Temps restant : ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
           function validateUserName() {
            const savedUserName = localStorage.getItem('userName');
            if (!savedUserName) {
                const input = prompt("Veuillez entrer votre nom (minuscules uniquement) :");
                if (input) {
                    localStorage.setItem('userName', input.toLowerCase());
                    document.getElementById('userName').textContent = `Nom : ${input.toLowerCase()}`;
                }
            } else {
                document.getElementById('userName').textContent = `Nom : ${savedUserName}`;
            }
        }

        function validateInput() {
            const input = document.getElementById('colorInput');
            input.value = input.value.toUpperCase().replace(/[^RV]/g, '').slice(0, 3);
        }

        function appendColor(color) {
            const input = document.getElementById('seriesInput');
            if (input.value.length < 10) {
                input.value += color;
                autoFillColors();
            }
        }

        function autoFillColors() {
    const seriesInput = document.getElementById('seriesInput').value.toUpperCase();
    const validColors = ['R', 'V'];

    if (seriesInput.length === 10 && seriesInput.split('').every(char => validColors.includes(char))) {
        const colorCount = seriesInput.split('').reduce((count, char) => {
            count[char] = (count[char] || 0) + 1;
            return count;
        }, {});

        const redPercentage = (colorCount['R'] || 0) * 10;
        const greenPercentage = (colorCount['V'] || 0) * 10;

        const mostFrequentColor = redPercentage >= greenPercentage ? `${redPercentage}% Rouge` : `${greenPercentage}% Vert`;
        document.getElementById('colorPercentage').value = mostFrequentColor;
        document.getElementById('colorInput').value = seriesInput; // Utilise les 10 couleurs
    }
}
function analyzeLossReason(colorInput, prediction, result) {
    const colors = colorInput.split(', '); // Convertir la cha√Æne en tableau
    const lastThreeColors = colors.slice(-3); // Prend les 3 derni√®res couleurs
    const colorCount = lastThreeColors.reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    let reason = "";

    // Raison 1 : Tendance r√©cente non respect√©e
    if (colorCount['R'] > colorCount['V'] && prediction === 'vert') {
        reason = "La tendance r√©cente √©tait rouge, mais vous avez pr√©dit vert.";
    } else if (colorCount['V'] > colorCount['R'] && prediction === 'rouge') {
        reason = "La tendance r√©cente √©tait verte, mais vous avez pr√©dit rouge.";
    }

    // Raison 2 : S√©quence r√©p√©titive non d√©tect√©e
    if (isSimpleAlternate(colors) && !isSimpleAlternate(lastThreeColors)) {
        reason = "La s√©quence √©tait altern√©e, mais vous n'avez pas suivi cette tendance.";
    } else if (isSimpleDoubleAlternate(colors) && !isSimpleDoubleAlternate(lastThreeColors)) {
        reason = "La s√©quence √©tait doublement altern√©e, mais vous n'avez pas suivi cette tendance.";
    }

    // Raison 3 : Pourcentage de couleur dominant ignor√©
    const redPercentage = (colors.filter(c => c === 'R').length / colors.length) * 100;
    const greenPercentage = (colors.filter(c => c === 'V').length / colors.length) * 100;
    if (redPercentage >= 60 && prediction === 'vert') {
        reason = "Le rouge dominait √† 60% ou plus, mais vous avez pr√©dit vert.";
    } else if (greenPercentage >= 60 && prediction === 'rouge') {
        reason = "Le vert dominait √† 60% ou plus, mais vous avez pr√©dit rouge.";
    }

    // Raison 4 : Mode inversion activ√©
    if (invertedMode) {
        reason = "Le mode inversion √©tait activ√©, ce qui a invers√© la pr√©diction.";
    }

    // Si aucune raison sp√©cifique n'est trouv√©e
    if (!reason) {
        reason = "La perte est due √† une fluctuation al√©atoire du march√© ou √† une tendance non d√©tect√©e.";
    }

    return reason;
}
// Nouvelle fonction pour afficher la popup strat√©gie
function showStrategyPopup() {
    document.getElementById('strategyPopup').style.display = 'flex';
}

function closeStrategyPopup() {
    document.getElementById('strategyPopup').style.display = 'none';
    // Activer les fonctionnalit√©s du bot apr√®s fermeture
    document.querySelectorAll('button').forEach(btn => btn.disabled = false);
}
function getLossAdvice(reason) {
    switch (reason) {
        case "La tendance r√©cente √©tait rouge, mais vous avez pr√©dit vert.":
            return "Suivez la tendance dominante dans les prochains trades.";
        case "La tendance r√©cente √©tait verte, mais vous avez pr√©dit rouge.":
            return "Suivez la tendance dominante dans les prochains trades.";
        case "La s√©quence √©tait altern√©e, mais vous n'avez pas suivi cette tendance.":
            return "Identifiez les s√©quences altern√©es et ajustez vos pr√©dictions en cons√©quence.";
        case "Le rouge dominait √† 60% ou plus, mais vous avez pr√©dit vert.":
            return "Respectez le pourcentage de couleur dominant dans vos pr√©dictions.";
        case "Le vert dominait √† 60% ou plus, mais vous avez pr√©dit rouge.":
            return "Respectez le pourcentage de couleur dominant dans vos pr√©dictions.";
        case "Le mode inversion √©tait activ√©, ce qui a invers√© la pr√©diction.":
            return "V√©rifiez si le mode inversion est toujours n√©cessaire avant de miser.";
        default:
            return "Analysez les tendances r√©centes et ajustez votre strat√©gie.";
    }
}
const patterns = {
"RVRVRVRVRV": "rouge",
"VRVRVRVRVR": "vert",
"RRVVRRVVRR": "vert",
"RVVRRVVRRV": "vert",
"VVRRVVRRVV": "rouge",
"VRRVVRRVVR": "rouge",
"RRRVVVRRR": "vert",
"RRVVVRRRVV": "vert",
"VVVRRRVVVR": "rouge",
"VVRRRVVVRR": "rouge",
"RRRRVVVVRR": "rouge",
"RRRVVVVRRR": "rouge",
"RRVVVVRRRR": "vert",
"RVVVVRRRRV": "vert",
"VVVVRRRRVV": "vert",
"VVVRRRRVVV": "vert",
"VVRRRRVVVV": "rouge",
"VRRRRVVVVR": "rouge",
"RRRRVRRRRV": "rouge",
"RRRVRRRRVR": "rouge",
"RRVRRRRVRR": "rouge",
"RVRRRRVRRR": "rouge",
"VRRRRVRRRR": "vert",
"VVVVRVVVVR": "vert",
"VVVRVVVVRV": "vert",
"VVRVVVVRVV": "vert",
"VRVVVVRVVV": "vert",
"RVVVVRVVVV": "rouge",
"VVVVRRVVVV": "rouge",
"VVVRRVVVVR": "rouge",
"RRRRVVRRRR": "vert",
"RRRVVRRRRV": "vert",
"RRVVVRRRRV": "vert",
"RVVVRRRRVV": "vert",
"VVVVVRRRVVV": "vert",
"VVVRRRVVVV": "rouge",
"VVRRRVVVVR": "rouge",
"VRRRVVVVRR": "rouge",
"RRVRRVRRVR": "rouge",
"RVRRVRRVRR": "vert",
"VVRVVRVVRV": "vert",
"VRVVRVVRVV": "rouge",
"RRRVRRRVRR": "rouge",
"RRVRRRVRRR": "vert",
"VVVRVVVRVV": "vert",
"VVRVVVRVVV": "rouge",
"RRRVVRRRVV": "rouge",
"VVVRRVVVRR": "vert",
"RRRRRRRRRR": "rouge",
"VVVVVVVVVV": "vert",
"RRRRRRRRVR": "vert",
"RRRRRRRVRV": "rouge",
"RRRRRVRVRV": "vert",
"RRRVRVRVVV": "rouge",
"RRVRVRVVVR": "rouge",
"RVRVRVVVRR": "vert",
"VRVRVVVRRV": "vert",
"RVRVVVRRVV": "rouge",
"VRVVVRRVVR": "vert",
"RVVVRRVVRV": "vert",
"VVVRRVVRVV": "vert",
"VVRRVVRVVV": "rouge",
"VRRVVRVVVR": "vert",
"RRVVRVVVRV": "vert",
"RVVRVVVRVV": "vert",
"VRVVVRVVVV": "vert",
"RVVVRVVVVV": "vert",
"VVVRVVVVVV": "vert",
"VVRVVVVVVV": "vert",
"VRVVVVVVVV": "vert",
"RVVVVVVVVV": "vert",
"VVVVVVVVVR": "rouge",
"VVVVVVVRRR": "vert",
"VVVVVVRRRV": "rouge",
"VVVVVRRRVR": "vert",
"VVVVRRRVRV": "rouge",
"VVVRRRVRVR": "rouge",
"VVRRRVRVRR": "rouge",
"VRRRVRVRRR": "rouge",
"RRRVRVRRRR": "rouge",
"RRVRVRRRRR": "vert",
"RVRVRRRRRV": "rouge",
"VRVRRRRRVR": "vert",
"RVRRRRRVRV": "vert",
"VRRRRRVRVV": "rouge",
"RRRRRVRVVR": "vert",
"RRRRVRVVRV": "vert",
"RRRVRVVRVV": "vert",
"RRVRVVRVVV": "rouge",
"RVRVVRVVVR": "rouge",
"VRVVRVVVRR": "rouge",
"RVVRVVVRRR": "rouge",
"VVRVVVRRRR": "vert",
"VRVVVRRRRV": "rouge",
"RVVVRRRRVR": "vert",
"VVVRRRRVRV": "rouge",
"VVRRRRVRVR": "rouge",
"VRRRRVRVRR": "rouge",
"RRRRVRVRRR": "rouge",
"VRVRRRRRVV": "vert",
"RVRRRRRVVV": "vert",
"VRRRRRVVVV": "vert",
"RRRRRVVVVV": "vert",
"RRRRVVVVVV": "vert",
"RRRVVVVVVV": "vert",
"RRVVVVVVVV": "vert",
"VVVVVVVVRV": "vert",
"VVVVVVVRVV": "vert",
"VVVVVVRVVV": "rouge",
"VVVVVRVVVR": "vert",
"VVVVRVVVRV": "vert",
"VVRVVVRVVR": "rouge",
"VRVVVRVVRR": "vert",
"RVVVRVVRRV": "rouge",
"VVVRVVRRVR": "rouge",
"VVRVVRRVRR": "vert",
"VRVVRRVRRV": "rouge",
"RVVRRVRRVR": "rouge",
"VVRRVRRVRR": "vert",
"VRRVRRVRRV": "vert",
"RRVRRVRRVV": "rouge",
"RVRRVRRVVR": "vert",
"VRRVRRVVRV": "rouge",
"RRVRRVVRVR": "vert",
"RVRRVVRVRV": "rouge",
"VRRVVRVRVR": "rouge",
"RRVVRVRVRR": "rouge",
"RVVRVRVRRR": "vert",
"VVRVRVRRRV": "rouge",
"VRVRVRRRVR": "vert",
"RVRVRRRVRV": "vert",
"VRVRRRVRVV": "rouge",
"RVRRRVRVVR": "vert",
"VRRRVRVVRV": "vert",
"VRVVRVVVRV": "vert",
"VRVVVVVVVR": "rouge",
"RVVVVVVVRR": "vert",
"VVVVVVVRRV": "rouge",
"VVVVVVRRVR": "vert",
"VVVVVRRVRV": "rouge",
"VVVVRRVRVR": "vert",
"VVVRRVRVRV": "rouge",
"VVRRVRVRVR": "rouge",
"VRRVRVRVRR": "vert",
"RRVRVRVRRV": "rouge",
"RVRVRVRRVR": "rouge",
"VRVRVRRVRR": "rouge",
"RVRVRRVRRR": "rouge",
"VRVRRVRRRR": "vert",
"RVRRVRRRRV": "vert",
"VRRVRRRRVV": "rouge",
"RRVRRRRVVR": "vert",
"RVRRRRVVRV": "vert",
"VRRRRVVRVV": "vert",
"RRRRVVRVVV": "rouge",
"RRRVVRVVVR": "vert",
"VRVVVRVVRV": "rouge",
"RVVVRVVRVR": "vert",
"VVVRVVRVRV": "rouge",
"VVRVVRVRVR": "rouge",
"VRVVRVRVRR": "rouge",
"VRVRVRRRVV": "rouge",
"RVRVRRRVVR": "rouge",
"VRVRRRVVRR": "rouge",
"RVRRRVVRRR": "vert",
"VRRRVVRRRV": "vert",
"RRVVRRRVVR": "vert",
"RVVRRRVVRV": "vert",
"VVRRRVVRVV": "rouge",
"VRRRVVRVVR": "vert",
"RRRVVRVVRV": "vert",
"RRVVRVVRVV": "vert",
"RVVRVVRVVV": "vert",
"RRVRRRRRVR": "vert",
"RRRVRVVRVR": "vert",
"RRVRVVRVRV": "rouge",
"RVRVVRVRVR": "vert",
"VRVVRVRVRV": "vert",
"RVVRVRVRVV": "vert",
"VVRVRVRVVV": "rouge",
"VRVRVRVVVR": "vert",
"RVRVRVVVRV": "vert",
"VRVRVVVRVV": "rouge",
"VRVVRVRRRV": "rouge",
"RVVRVRRRVR": "vert",
"VVRVRRRVRV": "rouge",
"VRVRRRVRVR": "rouge",
"RVRRRVRVRR": "vert",
"VRRRVRVRRV": "vert",
"RRRVRVRRVV": "vert",
"RRVRVRRVVV": "rouge",
"RVRVRRVVVR": "rouge",
"VRVRRVVVRR": "rouge",
"RVRRVVVRRR": "rouge",
"VRRVVVRRRR": "vert",
"RVRRVVVVRR": "rouge",
"VRRVVVVRRR": "rouge",
"RVVVVRRRRR": "vert",
"VVVVRRRRRV": "vert",
"VVVRRRRRVV": "rouge",
"VVRRRRRVVR": "vert",
"VRRRRRVVRV": "rouge",
"RRRRRVVRVR": "vert",
"RRRRVVRVRV": "rouge",
"RRRVVRVRVR": "rouge",
"RVVRVRVRRV": "rouge",
"VVRVRVRRVR": "vert",
"VRVRVRRVRV": "vert",
"RVRVRRVRVV": "vert",
"VRVRRVRVVV": "rouge",
"RVRRVRVVVR": "vert",
"VRRVRVVVRV": "vert",
"RRVRVVVRVV": "rouge",
"RVRVVVRVVR": "vert",
"RVRVVVVRVV": "vert",
"VVVVVRRVRR": "vert",
"VVVVRRVRRV": "rouge",
"VVVRRVRRVR": "rouge",
"VRRVRRVRRR": "vert",
"RRVRRVRRRV": "rouge",
"RVRRVRRRVR": "vert",
"VRRVRRRVRV": "vert",
"RRVRRRVRVV": "vert",
"RVRRRVRVVV": "vert",
"VRRRVRVVVV": "rouge",
"RRRVRVVVVR": "vert",
"RRVRVVVVRV": "rouge",
"RVRVVVVRVR": "rouge",
"VRVVVVRVRV": "vert",
"RVVVVRVRVV": "rouge",
"VVVVRVRVVR": "rouge",
"VVVRVRVVRR": "rouge",
"VVRVRVVRRR": "rouge",
"VRVRVVRRRR": "vert",
"RVRVVRRRRV": "rouge",
"VRVRRRVVRV": "rouge",
"RVRRRVVRVR": "vert",
"VRRRVVRVRV": "vert",
"RRRVVRVRVV": "vert",
"RRVVRVRVVV": "rouge",
"RVVRVRVVVR": "vert",
"VRVRRRRVRV": "rouge",
"RVRRRRVRVR": "rouge",
"RVRVRRRRRR": "rouge",
"VRVRRRRRRR": "vert",
"RVRRRRRRRV": "vert",
"VRRRRRRRRV": "rouge",
"VRRRRRRRVV": "rouge",
"RRRRRRVVRR": "rouge",
"RRRRRVVRRR": "vert",
"RRRRVVRRRV": "vert",
"VVRRRVVRRR": "rouge",
"VRRRVVRRRR": "rouge",
"RRRVVRRRRR": "vert",
"RRVVRRRRRV": "rouge",
"RVVRRRRRVR": "vert",
"VVRRRRRVRV": "vert",
"RRRRVRVVRR": "vert",
"RRRVRVVRRV": "rouge",
"RRVRVVRRVR": "rouge",
"RVRVVRRVRR": "rouge",
"VRVVRRVRRR": "vert",
"RVVRRVRRRV": "vert",
"VVRRVRRRVV": "rouge",
"VRRVRRRVVR": "rouge",
"RRVRRRVVRR": "rouge",
"RRVVRVVRVR": "vert",
"RVVRVVRVRV": "vert",
"VVRVVRVRVV": "vert",
"VRVVRVRVVV": "rouge",
"VVRVRVVVRV": "vert",
"VVRVRVRVVR": "vert",
"VRVRVRVVRV": "rouge",
"RVRVRVVRVR": "rouge",
"VRVRVVRVRR": "vert",
"RVRVVRVRRV": "rouge",
"VRVVRVRRVR": "rouge",
"RVVRVRRVRR": "rouge",
"VVRVRRVRRR": "vert",
"VRVRRVRRRV": "rouge",
"VRRRVRRRVRR": "rouge",
"VRVRRVRVVR": "vert",
"RVRRVRVVRV": "vert",
"VRRVRVVRVV": "rouge",
"RRVRVVRVVR": "rouge",
"RVRVVRVVRR": "vert",
"VRVVRVVRRV": "rouge",
"RVVRVVRRVR": "rouge",
"RVVRRVRRRR": "vert",
"VVRRVRRRRV": "vert",
"RRVRRRRVVV": "rouge",
"RVRRRRVVVR": "rouge",
"VRRRRVVVRR": "rouge",
"RRRRVVVRRR": "rouge",
"RRRVVVRRRR": "rouge",
"RRVVVRRRRR": "rouge",
"RVVVRRRRRR": "rouge",
"VVVRRRRRRR": "rouge",
"VVRRRRRRRR": "vert",
"RRRRRRRRVV": "rouge",
"RRRRRRRVVR": "vert",
"RRRRRRVVRV": "rouge",
"VVRVRVRRRR": "vert",
"VRVRVRRRRV": "rouge",
"RVRVRRRRVR": "vert",
"RVRRRRVRVV": "rouge",
"VRRRRVRVVR": "vert",
"VVVRRVRRVV": "vert",
"VVRRVRRVVV": "rouge",
"RVRRVVVRVV": "rouge",
"VRRVVVRVVR": "vert",
"RRVVVRVVRV": "rouge",
"RVRVRRRVRR": "vert",
"VRVRRRVRRV": "vert",
"RRVVVRVVVR": "vert",
"RVVVRVVVRV": "rouge",
"VVVRVVVRVR": "vert",
"VVRVVVRVRV": "rouge",
"VRVVVRVRVR": "rouge",
"RVVVRVRVRR": "vert",
"VVRVRVRRVV": "vert",
"VRVRRRVVVV": "rouge",
"RVVVRRRRRV": "vert",
"VVRRRRRVVV": "rouge",
"VRRRRRVVVR": "rouge",
"RRRRRVVVRV": "rouge",
"RRRRVVVRVR": "vert",
"RRRVVVRVRV": "vert",
"RRVVVRVRVV": "rouge",
"RVVVRVRVVR": "vert",
"VVVRVRVVRV": "vert",
"VVRVRVVRVV": "rouge",
"VRVRVVRVVR": "vert",
"RVRVVRVVRV": "vert",
"RVVRVVRVVR": "vert",
"VRVVRVVRVR": "vert",
"RVVRVRVVVV": "rouge",
"VVRVRVVVVR": "rouge",
"VRVRVVVVRR": "vert",
"RVRVVVVRRV": "vert",
"VRVVVVRRVV": "rouge",
"VVRVVVVRVR": "rouge",
"VRVVVVRVRR": "vert",
"RVVVVRVRRV": "vert",
"VVVVRVRRVV": "rouge",
"VVVRVRRVVR": "vert",
"VVRVRRVVRV": "vert",
"VRVRRVVRVV": "rouge",
"RVRRVVRVVR": "rouge",
"VRRVVRVVRR": "rouge",
"RRVVRVVRRR": "rouge",
"RVVRVVRRRR": "rouge",
"VVRVVRRRRV": "rouge",
"VRVVRRRRVR": "rouge",
"RVVRRRRVRR": "vert",
"VVRRRRVRRV": "rouge",
"VRRRRVRRVR": "rouge",
"RRRRVRRVRR": "rouge",
"RRRVRRVRRR": "vert",
"RVRRVRRRVV": "rouge",
"RRVRRRVVRV": "vert",
"RVRRRVVRVV": "vert",
"VRRRVVRVVV": "rouge",
"RRVVRVVVRR": "rouge",
"VRVVVRRRRR": "vert",
"RRRRRVRVVV": "vert",
"RRRRVRVVVV": "rouge",
"RVRRRVRRRR": "rouge",
"VRRRVRRRRR": "rouge",
"RRRVRRRRRR": "rouge",
"RRVRRRRRRR": "vert",
"VRRRRRRRVR": "vert",
"RRRRRRVRVV": "vert",
"RRRVRVVVVV": "vert",
"RRVRVVVVVV": "vert",
"RVRVVVVVVV": "rouge",
"VVRRRVRVRV": "vert",
"VRRRVRVRVV": "vert",
"RVRVVVRVVV": "rouge",
"VRVVVRVVVR": "rouge",
"RVVVRVVVRR": "vert",
"VVVRVVVRRV": "rouge",
"VVRVVVRRVR": "vert",
"VRVVVRRVRV": "rouge",
"RVVVRRVRVR": "rouge",
"VVVRRVRVRR": "rouge",
"VVRRVRVRRR": "rouge",
"VRRVRVRRRR": "rouge",
"VRRRRRVRVR": "rouge",
"RRRRRVRVRR": "rouge",
"RRVRVRRRRV": "vert",
"RVRVRRRRVV": "vert",
"VRVRRRRVVV": "rouge",
"RRRRVVVRRV": "rouge",
"RRRVVVRRVR": "rouge",
"RRVVVRRVRR": "vert",
"RVVVRRVRRV": "rouge",
"VVRRVRRVRV": "rouge",
"RRRVRRVVVR": "vert",
"VRRVVVRVRR": "vert",
"RRVVVRVRRV": "vert",
"RVVVRVRRVV": "rouge",
"RVVRVVRVRR": "rouge",
"VVRVVRVRRR": "vert",
"VVRVRRRVRR": "vert",
"VRRRVRRVRR": "vert",
"RRRVRRVRRV": "vert",
"RVRRVRRVVV": "rouge",
"VRRVRRVVVR": "vert",
"VVVRVRVRRV": "rouge",
"VRVRRVRVRR": "rouge",
"RVRRVRVRRR": "rouge",
"RRRVVVVRRV": "rouge",
"VVVVRRVRVV": "rouge",
"VVVRRVRVVR": "rouge",
"VVRRVRVVRR": "vert",
"VRRVRVVRRV": "vert",
"VVRVRVRVRR": "rouge",
"VRVRVRVRRR": "rouge",
"RVRVRVRRRR": "vert",
"VRVRRRRVRR": "vert",
"RVRRRRVRRV": "vert",
"RRRVRVRRRV": "vert",
"RRVRVRRRVV": "vert",
"RVRVRRRVVV": "rouge",
"VRVRRRVVVR": "vert",
"VRRRVVVRVV": "rouge",
"RRRVVVRVVR": "rouge",
"RRVVVRVVRR": "rouge",
"RVVVRVVRRR": "vert",
"VVVRVVRRRV": "rouge",
"RVVRRRVRVV": "vert",
"VVRRRVRVVV": "vert",
"RRVRVVVVVR": "rouge",
"RVRVVVVVRR": "rouge",
"VRVVVVVRRR": "vert",
"RVVVVVRRRV": "rouge",
"VVVVRRRVRR": "rouge",
"VVVRRRRVVR": "rouge",
"VVRRRRVVRR": "vert",
"VRRRRVVRRV": "vert",
"RRRRVVRRVV": "vert",
"RRRVVRRVVV": "vert",
"RRVVRRVVVV": "vert",
"RVVRRVVVVV": "vert",
"VVRRVVVVVV": "rouge",
"VRRVVVVVVR": "vert",
"VVVVVRVRVV": "vert",
"RVVVVRVVVR": "vert",
"VVVRVVRVRR": "rouge",
"VRVRRVRRVV": "rouge",
"RRVRRVVRVV": "rouge",
"RRVVRVVRRV": "vert",
"RVVRVVRRVV": "vert",
"VRVVRRVVVR": "vert",
"VRVVVRRVRR": "vert",
"VRVVRVVVVV": "vert",
"VRVVVVVVRR": "vert",
"RVVVVVVRRV": "vert",
"VVVVVVRRVV": "rouge",
"VVVVVRRVVR": "vert",
"RVVVRRRVVR": "rouge",
"VVVRRRVVRR": "rouge",
"RRRRVVRVRR": "rouge",
"RRRRRRRVRR": "vert",
"RRRRRRVRRV": "vert",
"RRRRRVRRVV": "rouge",
"RRRRVRRVVR": "vert",
"VRRVVRVVVV": "rouge",
"RVVRRRRRRV": "vert",
"VRRRRRRVVR": "rouge",
"RRRRRVVVRR": "rouge",
"VRRRVRRRRV": "vert",
"RVVVRVRRRV": "rouge",
"VRVRRRVRRR": "vert",
"RVRRRVRRRV": "vert",
"VVRRRRVRVV": "rouge",
"VVVRVRVRRR": "vert",
"RVRVVVRRRV": "vert",
"VVVVRVVVRR": "vert",
"RRRVRRRRVV": "rouge",
"RRVVRVVVVV": "vert",
"VVRVVVVVVR": "vert",
"VVVVVVRVRR": "vert",
"VVVVVRVRRV": "vert",
"VVVVVRRRVV": "vert",
"RRRRVVVVVR": "rouge",
"RRRVVVVVRR": "rouge",
"RRVVVVVRRR": "vert",
"VRRRVRVVRR": "vert",
"RVVRRVRRVV": "vert",
"RRVRRVVVRR": "rouge",
"VVRRRRRRRV": "vert",
"RVVRRRVVVR": "rouge",
"VRRRVVVRRV": "vert",
"RRRVVVRRVV": "vert",
"RRVVVRRVVV": "rouge",
"RVVVRRVVVR": "vert",
"VVRRVVVRVV": "rouge",
"RVVRVRRRRV": "vert",
"VVRVRRRRVV": "rouge",
"VRVRRRRVVR": "vert",
"RRRVVRVRRV": "rouge",
"VVRVRRVRRV": "vert",
"VRRVRRVVRR": "vert",
"RRVRRVVRRV": "rouge",
"VRRVVRRVRR": "vert",
"RRVVRRVRRV": "rouge",
"VRRVRRVRVV": "rouge",
"RRVRRVRVVR": "rouge",
"RVRRVRVVRR": "rouge",
"VRVVRRRRRV": "rouge",
"VVRRRRRVRR": "vert",
"VRRRRRVRRV": "rouge",
"RRVRRRRRRV": "rouge",
"RRRRVRRVVV": "vert",
"VRRVRRVVVV": "rouge",
"RRVRRVVVVR": "rouge",
"VRRVVVVRRV": "rouge",
"VRRRVVRVRR": "rouge",
"RRRVVRVRRR": "rouge",
"RRVVRVRRRR": "vert",
"RVRVRRVVRR": "vert",
"VRVRRVVRRV": "rouge",
"VRVRVRVRVV": "rouge",
"RVRVRVRVVR": "rouge",
"VRVRVRVVRR": "vert",
"RVRVRVVRRV": "vert",
"VRVVRRRRVV": "rouge",
"RVVRRRRVVR": "vert",
"VRVRVRVVVV": "rouge",
"RVRVRVVVVR": "rouge",
"RVVVVRRVVR": "vert",
"VRRVVRVRVV": "rouge",
"RRVVRVRVVR": "vert",
"VRVRVVRVVV": "vert",
"RVRVVRVVVV": "rouge",
"VRVVRVVVVR": "rouge",
"RVVRVVVVRR": "vert",
"VVRVVVVRRV": "rouge",
"VVRVVRVRRV": "vert",
"VRVVRVRRVV": "rouge",
"RVVRVRRVVR": "rouge",
"RRVVRRVRVV": "vert",
"RVRVVVVVVR": "rouge",
"VVVVRRVRRR": "vert",
"VVVRRVRRRV": "rouge",
"RRVRVRVRVV": "vert",
"RVRVRVRVVV": "rouge",
"VRVVVRRRVV": "vert",
"RRVVVRRVVR": "rouge",
"RVVVRRVVRR": "vert",
"VVVRRVVRRV": "vert",
"VVRRVVRRRV": "rouge",
"RRVVRRRVRR": "rouge",
"RVVRRRVRRR": "vert",
"VVRRRVRRRV": "rouge",
"RVRRRVVVVR": "rouge",
"RVRVVRVRVV": "vert",
"RVRRRRRRRR": "vert",
"RRRRRRRVVV": "rouge",
"RRRRRRVVVR": "vert",
"RRRRVVVRVV": "rouge",
"RVVVRVVVVR": "vert",
"VVVRVRVRVV": "vert",
"VVVRRVRVVV": "rouge",
"VVRRVRVVVR": "vert",
"RVRVVVRVRR": "vert",
"VRVVVRVRRV": "vert",
"VVRVRRVVRR": "vert",
"RVRRVVRRVV": "rouge",
"RVVRVRVVRR": "rouge",
"VRVRVVRRRV": "vert",
"RVRVVRRRVV": "vert",
"VRVVRRRVVV": "rouge",
"RRRVVVRVRR": "vert",
"VVRVRRVRVV": "vert",
"RVRRVRVVVV": "rouge",
"VRRVRVVVVR": "vert",
"VRRVRVVVVV": "rouge",
"VVVVRVRVVV": "vert",
"VVVRVRVVVV": "rouge",
"VVRVRVVVRR": "rouge",
"VRVRVVVRRR": "vert",
"RVVVRRRVVV": "rouge",
"RVVVRVVRVV": "rouge",
"VVVRVVRVVR": "vert",
"RVRVRRVRRV": "rouge",
"VRRVRVVRRR": "vert",
"RRVRVVRRRV": "vert",
"VRVVRRRVVR": "vert",
"VRRRRVRRRV": "rouge",
"RRVRRRVRRV": "rouge",
"RVRVVVRRRR": "vert",
"RRVRVVRVRR": "rouge",
"RVRVVRVRRR": "rouge",
"VRVVRVRRRR": "vert",
"RVRRRRVVVV": "vert",
"VRRRRVVVVV": "vert",
"RRRVVVVVVR": "rouge",
"RRVVVVVVRR": "vert",
"VVVVVRRVVV": "rouge",
"VVVVRRVVVR": "rouge",
"VVRRVVVRRR": "rouge",
"VRRRRVRVVV": "rouge",
"RRRRVRVVVR": "rouge",
"RRRVRVVVRR": "rouge",
"RRVRVVVRRR": "vert",
"VVRRRVVVVV": "vert",
"VRRRVVVVVV": "vert",
"RRVVVVVVVR": "rouge",
"VVVRRRVRRV": "rouge",
"RRRVRRVRVV": "rouge",
"VRVRVRRVVR": "rouge",
"VRRVVRRVVV": "rouge",
"RRVVRRVVVR": "vert",
"VVRVRVVVVV": "vert",
"VRVRVVVVVV": "vert",
"RVVRVVVVVR": "rouge",
"VVRVVVVVRR": "rouge",
"VRRRVVVVVR": "rouge",
"RRVVVVVRRV": "rouge",
"VVRRVVRVRR": "rouge",
"VRRVVRVRRR": "rouge",
"RVVVRRVVVV": "rouge",
"VRRVVVVRVV": "rouge",
"RRVVVVRVVR": "vert",
"VVVRVRVVVR": "rouge",
"RVVVRRRVRR": "rouge",
"VRRRVRRRVV": "rouge",
"RRRVRRRVVR": "vert",
"VRVRVRRRRR": "rouge",
"VRVRRRRRRV": "rouge",
"VRRRRRRVRR": "rouge",
"RRRRRRVRRR": "rouge",
"RRRRRVRRRR": "rouge",
"RRRRVRRRRR": "rouge",
"VRRRRRRRRR": "vert",
"RRRRRRRRRV": "rouge",
"RRVRVVRRVV": "rouge",
"RVRVVRRVVR": "rouge",
"RRVVRRRRVV": "vert",
"RVVRRRRVVV": "vert",
"RRVVVVRVRR": "vert",
"VRVRRVVVVR": "rouge",
"RRVVVVRRVV": "vert",
"VVVVRRVVRR": "vert",
"RVVRRVRVVR": "vert",
"VRVRVVRRVV": "vert",
"RVVRRVRVVV": "vert",
"VVRVVRVVRR": "vert",
"VRVRRVVVRV": "rouge",
};
function analyzeAndRecommend(sequence) {
    // Convertir la s√©quence en emojis üî¥/üü¢ pour l'analyse
    const colors = sequence.split('').map(c => c === 'R' ? 'üî¥' : 'üü¢');
    
    // Initialisation des donn√©es
    const trends = {};
    const streaks = {};
    let currentStreak = 0;
    let currentColor = null;

    // Analyse des tendances et s√©ries cons√©cutives
    colors.forEach((color, index) => {
        // Compter les occurrences
        trends[color] = (trends[color] || 0) + 1;

        // Calculer les s√©ries cons√©cutives
        if (color === currentColor) {
            currentStreak++;
        } else {
            if (currentColor !== null) {
                streaks[currentColor] = Math.max(streaks[currentColor] || 0, currentStreak);
            }
            currentColor = color;
            currentStreak = 1;
        }

        // Derni√®re position
        if (index === colors.length - 1) {
            streaks[currentColor] = Math.max(streaks[currentColor] || 0, currentStreak);
        }
    });

    // Identifier la couleur dominante (celle qui appara√Æt le plus)
    const dominantColor = Object.keys(trends).reduce((a, b) => trends[a] > trends[b] ? a : b);

    // Identifier la plus longue s√©rie cons√©cutive
    const longestStreakColor = Object.keys(streaks).reduce((a, b) => streaks[a] > streaks[b] ? a : b, Object.keys(streaks)[0]);

    // D√©cider des recommandations
    const recommendation = {
        primary: null,
        secondary: null,
        message: ""
    };

    if (streaks[longestStreakColor] >= 3) {
        recommendation.primary = longestStreakColor === 'üî¥' ? 'rouge' : 'vert';
        recommendation.message = `La couleur ${longestStreakColor} montre une s√©rie forte (${streaks[longestStreakColor]} fois), privil√©giez-la.`;
    } else {
        recommendation.primary = dominantColor === 'üî¥' ? 'rouge' : 'vert';
        recommendation.secondary = longestStreakColor === 'üî¥' ? 'rouge' : 'vert';
        recommendation.message = `La couleur ${dominantColor} domine (${trends[dominantColor]}/10), mais surveillez ${longestStreakColor} pour une possible inversion.`;
    }

    return {
        trends,
        streaks,
        recommendation
    };
}
// Modifiez la fonction predictColor pour √™tre async
async function predictColor() {
    const colorInput = document.getElementById('colorInput').value.toUpperCase();
    const validColors = ['R', 'V'];

    // 1. V√©rification du mode forc√© (prioritaire)
    if (isForceModeActive) {
        completeForcedPrediction();
        return;
    }

    // 2. V√©rification des restrictions
    if (!checkPredictionRestrictions(colorInput)) return;

    // Nouvelle v√©rification : Pr√©diction bas√©e sur les motifs
    let predictedColor = predictBasedOnSimilarity(colorInput);
    
    // Si nous sommes en phase de perte, v√©rifier la premi√®re couleur
    if (lastResultWasLoss) {
        const shouldContinue = await checkFirstColorWarning(colorInput, predictedColor);
        if (!shouldContinue) {
            clearFields();
            return;
        }
    }

    // 3. Validation du format
    if (colorInput.length !== 10 || !colorInput.split('').every(char => validColors.includes(char))) {
        showColorFormatAlert();
        return;
    }

    // 4. Calcul des pourcentages et v√©rification des ratios interdits
    const colorCount = colorInput.split('').reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    const redCount = colorCount['R'] || 0;
    const greenCount = colorCount['V'] || 0;
    
    const frequentColor = redCount * 10 >= greenCount * 10 
        ? `${redCount * 10}% Rouge` 
        : `${greenCount * 10}% Vert`;

    // 5. V√©rification du feedback manquant
    if (history.length > 0 && !history[history.length - 1].result) {
        showMissingFeedbackAlert();
        return;
    }

    // 6. Conversion au format lisible
    const lastColors = colorInput.split('').map(char => char === 'R' ? 'rouge' : 'vert');

    // 7. V√©rification des doublons
    const previousResult = history.find(record => record.colors === lastColors.join(', '));
    if (previousResult) {
        handleDuplicatePrediction(previousResult, colorInput, lastColors, frequentColor);
        return;
    }

    // 8. Nouvelle strat√©gie apr√®s une perte
    if (lastResultWasLoss) {
        const lastThree = colorInput.slice(-3);
        const threeColorPatterns = {
            'RVV': 'rouge',
            'VRR': 'vert',
            'VVR': 'vert',
            'RRV': 'rouge',
            'RRR': 'vert',
            'VVV': 'rouge'
        };  


        if (threeColorPatterns[lastThree]) {
            const nextColor = threeColorPatterns[lastThree];
            
            // Cr√©ation de l'entr√©e historique
            const newRecord = {
                tradeNumber: history.length + 1,
                colors: lastColors.join(', '),
                prediction: nextColor,
                frequentColor: frequentColor,
                result: '',
                date: document.getElementById('dateInput').value || new Date().toLocaleDateString(),
                method: '3-color-pattern',
                patternUsed: lastThree
            };

            // Ajout √† l'historique
            history.push(newRecord);
            
            // Mise √† jour IMM√âDIATE de l'affichage
            updateHistory();
            saveHistoryToLocalStorage();

            // Affichage de la pr√©diction
            const predictionResult = document.getElementById('predictionResult');
            predictionResult.className = `prediction-container prediction-${nextColor === 'rouge' ? 'red' : 'green'}`;
            predictionResult.innerHTML = `
                <span class="prediction-icon">${nextColor === 'rouge' ? 'üî¥' : 'üü¢'}</span>
                <span>PR√âDICTION: <strong>${nextColor.toUpperCase()}</strong> (Strat√©gie ${lastThree})</span>
                <span class="prediction-icon">${nextColor === 'rouge' ? 'üî¥' : 'üü¢'}</span>
                <div class="alert alert-info" style="margin-top:10px;padding:5px;">
                    Strat√©gie anti-perte activ√©e
                </div>
            `;

            // Alertes SweetAlert conserv√©es
            Swal.fire({
                title: 'Strat√©gie sp√©ciale activ√©e',
                html: `Apr√®s une perte, d√©tection du motif <strong>${lastThree}</strong><br>
                       Pr√©diction: <strong style="color:${nextColor === 'rouge' ? '#dc3545' : '#28a745'}">${nextColor.toUpperCase()}</strong>`,
                icon: 'info',
                confirmButtonText: 'Compris'
            });

            document.getElementById('colorInput').value = '';
            enableFeedbackButtons();
            return;
        }
    }

    // 9. Ex√©cution normale
    completePrediction(colorInput, lastColors, frequentColor);
}
function completePrediction(colorInput, lastColors, frequentColor) {
    // 1. D'abord essayer avec les motifs r√©p√©t√©s
    let nextColor = predictBasedOnRepeatedPatterns(colorInput);

    // 2. Si aucun motif r√©p√©t√©, essayer avec les motifs pr√©d√©finis
    if (!nextColor) {
        nextColor = predictBasedOnSimilarity(colorInput);
        
        // 3. Si aucun motif pr√©d√©fini trouv√©, utiliser la nouvelle r√®gle par d√©faut
        if (!nextColor) {
            const lastColor = colorInput.slice(-1); // Prendre la derni√®re couleur
            nextColor = lastColor === 'R' ? 'rouge' : 'vert';
        }
    }

    // Enregistrement de la pr√©diction
    history.push({
        tradeNumber: history.length + 1,
        colors: lastColors.join(', '),
        prediction: nextColor,
        frequentColor: frequentColor,
        result: '',
        date: document.getElementById('dateInput').value || new Date().toLocaleDateString(),
        method: nextColor ? 'pattern' : 'statistical'
    });

    // Affichage du r√©sultat
    const predictionResult = document.getElementById('predictionResult');
    predictionResult.className = `prediction-container prediction-${nextColor === 'rouge' ? 'red' : 'green'}`;
    predictionResult.innerHTML = `
        <span class="prediction-icon">${nextColor === 'rouge' ? 'üî¥' : 'üü¢'}</span>
        <span>PR√âDICTION : MISER SUR <strong>${nextColor.toUpperCase()}</strong></span>
        <span class="prediction-icon">${nextColor === 'rouge' ? 'üî¥' : 'üü¢'}</span>
    `;

    document.getElementById('colorInput').value = '';
    updateHistory();
    enableFeedbackButtons();
    
    Swal.fire({
        title: 'Pr√©diction Enregistr√©e!',
        html: `
            <p>Mise recommand√©e: <strong>${nextColor.toUpperCase()}</strong></p>
            <p>${frequentColor}</p>
        `,
        icon: 'success',
        confirmButtonText: 'Continuer'
    });
    
    updateStats();
    saveHistoryToLocalStorage();
    return true;
}
// Nouvelle fonction pour les pr√©dictions forc√©es
function completeForcedPrediction() {
    const colorInput = document.getElementById('colorInput').value.toUpperCase();
    
    // 1. V√©rification IMP√âRATIVE de toutes les restrictions avant toute pr√©diction forc√©e
    if (!checkPredictionRestrictions(colorInput)) {
        Swal.fire({
            title: 'Pr√©diction Forc√©e Impossible ‚ö†Ô∏è',
            html: `
                <p>Le mode forc√© ne peut pas contourner les r√®gles de s√©curit√© :</p>
                <p style="color:#dc3545;font-weight:bold;">
                    ${getActiveRestrictions(colorInput).join('<br>')}
                </p>
                <p>Veuillez attendre un nouveau signal.</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris'
        });
        return;
    }

    const lastColors = colorInput.split('').map(char => char === 'R' ? 'rouge' : 'vert');
    
    // Calcul du pourcentage de couleur (inchang√©)
    const colorCount = colorInput.split('').reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    const frequentColor = (colorCount['R'] || 0) * 10 >= (colorCount['V'] || 0) * 10 
        ? `${(colorCount['R'] || 0) * 10}% Rouge` 
        : `${(colorCount['V'] || 0) * 10}% Vert`;

    // Enregistrement de la pr√©diction forc√©e (inchang√©)
    history.push({
        tradeNumber: history.length + 1,
        colors: lastColors.join(', '),
        prediction: forcedColor,
        frequentColor: frequentColor,
        result: '',
        date: document.getElementById('dateInput').value || new Date().toLocaleDateString(),
        method: 'forced',
        forced: true,
        restrictionsChecked: true // Nouveau champ pour tracer le respect des r√®gles
    });

    // Affichage du r√©sultat (inchang√©)
    const predictionResult = document.getElementById('predictionResult');
    predictionResult.className = `prediction-container prediction-${forcedColor === 'rouge' ? 'red' : 'green'}`;
    predictionResult.innerHTML = `
        <span class="prediction-icon">${forcedColor === 'rouge' ? 'üî¥' : 'üü¢'}</span>
        <span>PR√âDICTION FORC√âE : MISER SUR <strong>${forcedColor.toUpperCase()}</strong></span>
        <span class="prediction-icon">${forcedColor === 'rouge' ? 'üî¥' : 'üü¢'}</span>
        <div class="warning-alert">‚ö†Ô∏è Mode forc√© activ√© (2 pertes cons√©cutives)</div>
    `;

    document.getElementById('colorInput').value = '';
    updateHistory();
    enableFeedbackButtons();
    
    // Notification (inchang√©e mais avec mention des r√®gles respect√©es)
    Swal.fire({
        title: 'Pr√©diction Forc√©e Valid√©e!',
        html: `
            <p>Mise forc√©e sur: <strong style="color:${forcedColor === 'rouge' ? '#dc3545' : '#28a745'}">${forcedColor.toUpperCase()}</strong></p>
            <p>‚úÖ Toutes les r√®gles de s√©curit√© sont respect√©es :</p>
            <ul style="text-align:left;margin-left:20px;">
                ${getRespectedRules(colorInput).map(r => `<li>${r}</li>`).join('')}
            </ul>
            <p>${frequentColor}</p>
        `,
        icon: 'success',
        confirmButtonText: 'Continuer'
    });
}

// Fonctions helper (√† ajouter dans votre code)
function getActiveRestrictions(colorInput) {
    const restrictions = [];
    const lastThree = colorInput.slice(-3);
    
    if (lastThree === 'RVR' || lastThree === 'VRV') {
        restrictions.push('‚Ä¢ S√©quence RVR/VRV interdite');
    }
    
    const redCount = (colorInput.match(/R/g) || []).length;
    const greenCount = (colorInput.match(/V/g) || []).length;
    if ((redCount === 6 && greenCount === 4) || (redCount === 4 && greenCount === 6)) {
        restrictions.push(`‚Ä¢ Ratio ${redCount}R/${greenCount}V interdit`);
    }
    
    if (bannedPatterns.includes(lastThree)) {
        restrictions.push(`‚Ä¢ Motif ${lastThree} temporairement bloqu√©`);
    }
    
    return restrictions.length ? restrictions : ['Aucune restriction active'];
}

function getRespectedRules(colorInput) {
    return [
        'Aucune s√©quence RVR/VRV d√©tect√©e',
        'Ratios 6/4 absents',
        bannedPatterns.length ? `Motifs ${bannedPatterns.join(', ')} √©vit√©s` : 'Aucun motif temporaire bloqu√©'
    ];
}
// Fonctions extraites pour plus de clart√© :
function showColorFormatAlert() {
    Swal.fire({
        title: 'S√©quence de couleurs üî¥üü¢',
        html: `
            <p>Veuillez entrer une s√©quence de <strong>10 couleurs</strong>, utilisant uniquement :</p>
            <ul>
                <li><strong>"R"</strong> pour Rouge üî¥</li>
                <li><strong>"V"</strong> pour Vert üü¢</li>
            </ul>
        `,
        icon: 'info',
        confirmButtonText: 'Compris'
    });
}

function showMissingFeedbackAlert() {
    Swal.fire({
        title: 'Action requise ‚ö†Ô∏è',
        html: `
            <p>Veuillez marquer la derni√®re pr√©diction comme <strong>gagn√©e</strong> ou <strong>perdue</strong> avant d'effectuer une nouvelle pr√©diction.</p>
        `,
        icon: 'warning',
        confirmButtonText: 'Compris'
    });
}

function handleDuplicatePrediction(previousResult, colorInput, lastColors, frequentColor) {
    Swal.fire({
        title: 'Pr√©diction existante ‚ö†Ô∏è',
        html: `
            <p>Cette s√©quence existe d√©j√† dans l'historique :</p>
            <p><strong>Pr√©diction :</strong> ${previousResult.prediction}</p>
            <p><strong>R√©sultat :</strong> ${previousResult.result === '√âchec' ? '‚ùå √âchec' : '‚úÖ Succ√®s'}</p>
            ${previousResult.result === '√âchec' ? '<p>Conseil : Essayez de miser la couleur contraire.</p>' : ''}
        `,
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'Continuer quand m√™me',
        cancelButtonText: 'Annuler'
    }).then((result) => {
        if (result.isConfirmed) {
            completePrediction(colorInput, lastColors, frequentColor);
        } else {
            clearFields();
        }
    });
}
// Nouvelle fonction pour la partie finale de la pr√©diction (identique √† votre code original)
function completePrediction(colorInput, lastColors, frequentColor) {
    // 1. D'abord essayer avec les motifs r√©p√©t√©s
    let nextColor = predictBasedOnRepeatedPatterns(colorInput);

    // 2. Si aucun motif r√©p√©t√©, essayer avec les motifs pr√©d√©finis
    if (!nextColor) {
        nextColor = predictBasedOnSimilarity(colorInput);
        
        // 3. Si aucun motif pr√©d√©fini trouv√©, utiliser l'analyse statistique
        if (!nextColor) {
            const analysis = analyzeAndRecommend(colorInput);
            nextColor = analysis.recommendation.primary;
            
            // Ajouter un message d'information
            Swal.fire({
                title: 'Analyse Statistique Activ√©e üìä',
                html: `
                    <p>${analysis.recommendation.message}</p>
                    <p><strong>D√©tails :</strong></p>
                    <ul>
                        <li>üî¥ Rouge: ${analysis.trends['üî¥'] || 0} occurrences</li>
                        <li>üü¢ Vert: ${analysis.trends['üü¢'] || 0} occurrences</li>
                        <li>Plus longue s√©rie: ${analysis.streaks[analysis.recommendation.primary === 'rouge' ? 'üî¥' : 'üü¢'] || 0}</li>
                    </ul>
                `,
                icon: 'info',
                confirmButtonText: 'Compris',
                confirmButtonColor: '#17a2b8',
                background: '#f0f8ff',
                iconColor: '#17a2b8'
            });
        }
    }

    // Enregistrement de la pr√©diction
    history.push({
        tradeNumber: history.length + 1,
        colors: lastColors.join(', '),
        prediction: nextColor,
        frequentColor: frequentColor,
        result: '',
        date: document.getElementById('dateInput').value || new Date().toLocaleDateString(),
        method: nextColor ? 'pattern' : 'statistical' // Nouveau champ pour tracker la m√©thode
    });

    // Affichage du r√©sultat
    const predictionResult = document.getElementById('predictionResult');
    predictionResult.className = `prediction-container prediction-${nextColor === 'rouge' ? 'red' : 'green'}`;
    predictionResult.innerHTML = `
        <span class="prediction-icon">${nextColor === 'rouge' ? 'üî¥' : 'üü¢'}</span>
        <span>PR√âDICTION : MISER SUR <strong>${nextColor.toUpperCase()}</strong></span>
        <span class="prediction-icon">${nextColor === 'rouge' ? 'üî¥' : 'üü¢'}</span>
        ${!nextColor ? '<div class="warning-alert">‚ö†Ô∏è Pr√©diction bas√©e sur l\'analyse statistique</div>' : ''}
    `;

    document.getElementById('colorInput').value = '';
    updateHistory();
    enableFeedbackButtons();
    
    Swal.fire({
        title: 'Pr√©diction Enregistr√©e!',
        html: `
            <p>Mise recommand√©e: <strong>${nextColor.toUpperCase()}</strong></p>
            <p>M√©thode: ${nextColor ? 'Motif reconnu' : 'Analyse statistique'}</p>
            <p>${frequentColor}</p>
        `,
        icon: 'success',
        confirmButtonText: 'Continuer'
    });
    
    updateStats();
    saveHistoryToLocalStorage();
    return true;
}
// NOUVELLE FONCTION: Analyse des motifs r√©p√©t√©s
function predictBasedOnRepeatedPatterns(colorInput) {
    // Recherche des motifs de 3 couleurs r√©p√©t√©s
    const patternMap = {};
    
    // Enregistrer toutes les occurrences de chaque motif de 3 couleurs
    for (let i = 0; i <= colorInput.length - 3; i++) {
        const pattern = colorInput.substr(i, 3);
        if (!patternMap[pattern]) {
            patternMap[pattern] = [];
        }
        patternMap[pattern].push(i);
    }

    // Trouver le motif le plus fr√©quent (au moins 2 occurrences)
    let mostFrequentPattern = null;
    let maxOccurrences = 1;
    
    for (const pattern in patternMap) {
        if (patternMap[pattern].length > maxOccurrences) {
            mostFrequentPattern = pattern;
            maxOccurrences = patternMap[pattern].length;
        }
    }

    // Si on a trouv√© un motif r√©p√©t√©, pr√©dire la couleur suivante
    if (mostFrequentPattern && maxOccurrences >= 2) {
        const lastOccurrenceIndex = Math.max(...patternMap[mostFrequentPattern]);
        if (lastOccurrenceIndex + 3 < colorInput.length) {
            const nextColorChar = colorInput[lastOccurrenceIndex + 3];
            return nextColorChar === 'R' ? 'rouge' : 'vert';
        }
    }

    return null; // Aucun motif r√©p√©t√© trouv√©
}

// FONCTION EXISTANTE (√† conserver)
function predictBasedOnSimilarity(colorInput) {
    const mostSimilarPattern = findMostSimilarPattern(colorInput);
    if (mostSimilarPattern) {
        return patterns[mostSimilarPattern];
    }
    return null;
}

// FONCTION EXISTANTE (√† conserver)
function findMostSimilarPattern(inputPattern) {
    let mostSimilarPattern = '';
    let highestSimilarity = 0;

    for (const pattern in patterns) {
        let similarity = 0;
        for (let i = 0; i < inputPattern.length; i++) {
            if (inputPattern[i] === pattern[i]) {
                similarity++;
            }
        }
        if (similarity > highestSimilarity) {
            highestSimilarity = similarity;
            mostSimilarPattern = pattern;
        }
    }

    return mostSimilarPattern;
}

// FONCTION EXISTANTE (√† conserver)
function predictBasedOnTrends(colorInput) {
    const lastThreeColors = colorInput.slice(-3);
    const colorCount = lastThreeColors.split('').reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    if (colorCount['R'] > colorCount['V']) {
        return 'rouge';
    } else if (colorCount['V'] > colorCount['R']) {
        return 'vert';
    } else {
        const globalRed = (colorInput.split('R').length - 1) * 10;
        const globalGreen = (colorInput.split('V').length - 1) * 10;
        return globalRed >= globalGreen ? 'rouge' : 'vert';
    }
}

function displayPreviousResult(previousResult) {
    const lastPrediction = history.length > 1 ? history[history.length - 2] : null; // R√©cup√©rer la derni√®re pr√©diction avant la plus r√©cente

    // V√©rifier si la pr√©diction pr√©c√©dente a √©chou√© et si la pr√©diction actuelle est diff√©rente
    if (lastPrediction && lastPrediction.result === '√âchec' && lastPrediction.prediction !== previousResult.prediction) {
        document.getElementById('previousResult').textContent = 'Cette pr√©diction a √©chou√© auparavant. Vous avez mis√© la couleur contraire.';
    } else if (previousResult.result === '√âchec' && previousResult.prediction === lastPrediction.prediction) {
        document.getElementById('previousResult').textContent = 'Cette situation a √©chou√© auparavant avec la m√™me pr√©diction. Essayez de miser la couleur contraire.';
    } else {
        const resultMessage = `Cette pr√©diction existe d√©j√† dans l'historique. Pr√©diction : ${previousResult.prediction}, R√©sultat : ${previousResult.result}, Pourcentage de Couleur : ${previousResult.frequentColor}`;
        document.getElementById('previousResult').textContent = resultMessage;
    }
    console.log("S√©quence de couleurs :", colorInput);
    console.log("Pr√©diction associ√©e :", nextColor);
}



        function clearFields() {
            document.getElementById('colorInput').value = '';
            document.getElementById('seriesInput').value = '';
            document.getElementById('colorPercentage').value = '';
            document.getElementById('predictionResult').textContent = '';
            document.getElementById('previousResult').textContent = '';
            enableFeedbackButtons();
        }
        function checkLastThreePattern(colorInput) {
    const lastThree = colorInput.slice(-3); // Prend les 3 derni√®res couleurs
    
    // Liste des motifs et leurs pr√©dictions associ√©es
    const threeColorPatterns = {
        'RVV': 'rouge',
        'VRR': 'vert',
        'VVR': 'vert',
        'RRV': 'rouge'
        // Ajoute d'autres motifs ici si n√©cessaire
    };
    
    return threeColorPatterns[lastThree] || null;
}

function giveFeedback(correct) {
    const lastHistoryItem = history[history.length - 1];
    
// V√©rification si le feedback a d√©j√† √©t√© donn√©
    if (lastHistoryItem.result !== '') {
        Swal.fire({
            title: 'D√©j√† √©valu√© ‚ö†Ô∏è',
            text: 'Cette pr√©diction a d√©j√† re√ßu un feedback.',
            icon: 'info',
            confirmButtonText: 'OK',
            confirmButtonColor: '#007bff'
        });
        return;
    }

    // Configuration du trading
    const odds = parseFloat(document.getElementById('oddsInput').value) || 97;
    const currentBet = getCurrentBet();
    const nextBet = martingaleSequence[Math.min(currentMartingaleIndex + 1, martingaleSequence.length - 1)] || martingaleSequence[0];

    // V√©rification de la bankroll
    if (!correct && currentBankroll < currentBet) {
        Swal.fire({
            title: 'Fonds insuffisants ‚õî',
            html: `<strong>${currentBankroll.toFixed(2)} R</strong> disponibles<br>
                   <strong>${currentBet.toFixed(2)} R</strong> requis`,
            icon: 'error',
            willClose: () => {
                currentMartingaleIndex = 0;
                updateMartingaleDisplay();
            }
        });
        return;
    }
     
    // Mise √† jour des statistiques par couleur
    if (correct) {
        if (lastHistoryItem.prediction === 'rouge') {
            redSuccesses++;
        } else {
            greenSuccesses++;
        }
    } else {
        if (lastHistoryItem.prediction === 'rouge') {
            redFailures++;
        } else {
            greenFailures++;
        }
    }

    if (correct) {
        // ===== R√âINITIALISATION COMPL√àTE APR√àS GAIN =====
        const profit = currentBet * (odds / 100);
        currentBankroll = parseFloat((currentBankroll + profit).toFixed(2));
        
        // R√©initialisation des compteurs et strat√©gies
        consecutiveLosses = 0;
        currentMartingaleIndex = 0;
        bannedPatterns = [];
        lastResultWasLoss = false;
        
        // R√©initialisation des tendances forc√©es
        if (isForceModeActive) {
            isForceModeActive = false;
            forcedColor = '';
            document.getElementById('forceModeAlert').style.display = 'none';
            document.getElementById('redStats').classList.remove('force-mode-active');
            document.getElementById('greenStats').classList.remove('force-mode-active');
            
            Swal.fire({
                title: 'R√©initialisation compl√®te',
                text: 'Mode forc√© d√©sactiv√© apr√®s gain',
                icon: 'success',
                timer: 1500
            });
        }

        lastHistoryItem.result = 'Succ√®s';
        successes++;
        points += 10;
        currentConsecutiveLosses = 0; // Reset compteur
        updateLionCoins(+1);
        pertesConsecutivesActuelles = 0; // R√©initialise le compteur actuel
        Swal.fire({
    title: 'Victoire Imp√©riale ü¶Å‚ú®',
    html: `
        <div style="position:relative; margin:20px 0;">
            <!-- √âl√©ment central lion + argent -->
            <div style="display:flex; flex-direction:column; align-items:center; margin-bottom:15px;">
                <div style="font-size:3rem; line-height:1;">
                    <span style="color:#FFD700;">ü¶Å</span><span style="color:#4CAF50; margin:0 5px;">‚Üí</span><span style="color:#28a745;">üí∞</span>
                </div>
                <div style="font-size:1.8rem; font-weight:bold; color:#2E7D32; margin:5px 0;">
                    +${profit.toFixed(2)} R
                </div>
                <div style="font-size:0.85rem; color:#78909C; background:#f5f5f5; padding:2px 8px; border-radius:10px;">
                    ${odds}% de chance
                </div>
            </div>

            <!-- R√©compense Lion Coin - version compacte -->
            <div style="background:#FFF9C4; border-radius:8px; padding:8px; margin:0 auto 15px; width:fit-content;">
                <p style="margin:0; font-size:0.95rem;">
                    <span style="font-weight:bold; color:#FF6D00;">+1 Lion Coin</span> <span style="font-size:0.8rem; color:#616161;">(r√©compense exclusive)</span>
                </p>
            </div>

            <!-- Bankroll + Mise suivante - version compacte -->
            <div style="display:flex; justify-content:center; gap:20px; text-align:center; background:#f8f9fa; padding:10px; border-radius:8px;">
                <div>
                    <p style="margin:0 0 3px 0; font-size:0.75rem; color:#607d8b;">Bankroll</p>
                    <p style="margin:0; font-weight:bold; font-size:0.95rem;">${currentBankroll.toFixed(2)} R</p>
                </div>
                <div style="border-left:1px solid #e0e0e0;"></div>
                <div>
                    <p style="margin:0 0 3px 0; font-size:0.75rem; color:#607d8b;">Mise suivante</p>
                    <p style="margin:0; font-weight:bold; font-size:0.95rem;">${nextBet.toFixed(2)} R</p>
                </div>
            </div>
        </div>
    `,
    icon: false,
    background: '#ffffff',
    showConfirmButton: true,
    showClass: {
        popup: 'animate__animated animate__fadeIn animate__faster'
    },
    customClass: {
        popup: 'custom-swal-popup',
        title: 'custom-swal-title'
    }
});
    } else {
        // ===== TRAITEMENT PERTE =====
        currentBankroll = parseFloat((currentBankroll - currentBet).toFixed(2));
        consecutiveLosses++;
        
        currentMartingaleIndex = Math.min(currentMartingaleIndex + 1, martingaleSequence.length - 1);

        lastResultWasLoss = true;
        currentConsecutiveLosses++;
        localStorage.setItem('currentConsecutiveLosses', currentConsecutiveLosses);
        if (currentConsecutiveLosses > maxConsecutiveLosses) {
            maxConsecutiveLosses = currentConsecutiveLosses;
        }

        document.getElementById('maxConsecutiveLosses').innerHTML = 
            `Record de pertes cons√©cutives : <span>${maxConsecutiveLosses}</span>`;

        // ===== FIN DE L'AJOUT =====
        lastHistoryItem.result = '√âchec';
        failures++;
         let warningMessage = '';
         if (consecutiveLosses >= 1,2,3,4,5,6,7,8,9) {
            warningMessage = `
               <div style="background:#ffebee;padding:10px;border-radius:5px;margin:10px 0;">
               <p style="color:#d32f2f">üö® PHASE DE PERTES - Restrictions Actives</p>
               <p><strong>S√©quences √† √©viter :</strong></p>
               <ul style="margin: 5px 0; color: #d32f2f;">
               <li>Les s√©quences de 10 couleurs se terminant par RRR</li>
               <li>Les s√©quences de 10 couleurs se terminant par VVV</li>
               </ul>
               <p style="font-size: 0.9em; margin-top: 8px;">
            ‚ö†Ô∏è Ces restrictions sont en place pour √©viter les s√©ries de pertes cons√©cutives
            </p>
            </div>
            `;
        }

        // Gestion du mode forc√©
        if (consecutiveLosses >= 4 && !isForceModeActive) {
            isForceModeActive = true;
            
            const redTotal = redSuccesses + redFailures;
            const greenTotal = greenSuccesses + greenFailures;
            
            const redRate = redTotal > 0 ? redSuccesses / redTotal : 0;
            const greenRate = greenTotal > 0 ? greenSuccesses / greenTotal : 0;
            
            forcedColor = redRate >= greenRate ? 'rouge' : 'vert';
            
            document.getElementById('forceModeAlert').style.display = 'block';
            document.getElementById('forcedColorText').textContent = forcedColor;
            document.getElementById('forcedColorText').style.color = forcedColor === 'rouge' ? '#dc3545' : '#28a745';
            
            if (forcedColor === 'rouge') {
                document.getElementById('redStats').classList.add('force-mode-active');
            } else {
                document.getElementById('greenStats').classList.add('force-mode-active');
            }
            
            warningMessage += `
                <div style="margin-top:10px; background:#fff3cd; padding:10px; border-radius:5px;">
                    <p style="color:#856404;">‚ö†Ô∏è Mode forc√© activ√© (5 pertes): Pr√©dictions sur <strong>${forcedColor}</strong></p>
                </div>
            `;
        }
        
        Swal.fire({
            title: 'Perdu ‚ùå',
            html: `
                <div style="font-size: 2rem;">üìâ</div>
                <p><strong>-${currentBet.toFixed(2)} R</strong></p>
                <hr>
                <p>Bankroll: <strong>${currentBankroll.toFixed(2)} R</strong></p>
                <p>Prochaine mise: <strong>${nextBet.toFixed(2)} R</strong></p>
                ${warningMessage}
            `,
            icon: 'error',
            background: 'linear-gradient(135deg, #fff0f0 0%, #ffe6e6 100%)',
            showClass: {
                popup: 'animate__animated animate__headShake'
            }
        });

       
    }

    // ===== MISE √Ä JOUR DE L'INTERFACE =====
    updateBankrollDisplay();
    updateMartingaleDisplay();
    updateHistory();
    updateSuccessRate();
    updatePoints();
    updateLevelButtons();
    updatePieChart();
    updateColorStatsDisplay();
    saveHistoryToLocalStorage();
    
    document.getElementById('seriesInput').value = '';
    document.getElementById('colorPercentage').value = '';
    document.getElementById('predictionResult').textContent = '';
     // Mettre √† jour l'affichage
     document.getElementById('maxConsecutiveLosses').innerHTML = 
        `Plus grande s√©rie de pertes : <span>${maxConsecutiveLosses}</span>`;
}
function checkPredictionRestrictions(colorSeries) {
    const lastThree = colorSeries.slice(-3); // R√©cup√®re les 3 derni√®res couleurs
    const redCount = (colorSeries.match(/R/g) || []).length;
    const greenCount = (colorSeries.match(/V/g) || []).length;
    // 1. V√©rification des s√©quences RRR et VVV apr√®s une perte
    if (consecutiveLosses > 0 && isBlockedAfterLoss(colorSeries)) {
        Swal.fire({
            title: 'S√âQUENCE BLOQU√âE APR√àS PERTE ‚õî',
            html: `
                <div style="font-size: 2rem;">üö´</div>
                <p>La s√©quence se termine par <strong>${lastThree}</strong></p>
                <p>Les s√©quences se terminant par RRR ou VVV sont bloqu√©es apr√®s une perte.</p>
                <p style="color: #dc3545;">Veuillez attendre une nouvelle s√©quence.</p>
                <p>Pertes cons√©cutives actuelles : ${consecutiveLosses}</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#dc3545'
        });
        return false;
    }
    // 2. V√©rification permanente (valable en tout temps) - RVR et VRV
    if (lastThree === 'RVR' || lastThree === 'VRV') {
        Swal.fire({
            title: 'PR√âDICTION INTERDITE ‚õî',
            html: `
                <div style="font-size: 2rem;">üö®</div>
                <p>La s√©quence <strong>${lastThree}</strong> est strictement interdite.</p>
                <p>Motif : Tendance trop volatile et impr√©visible.</p>
                <p style="color: #dc3545;">Veuillez attendre le prochain tour.</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#dc3545'
        });
        return false;
    }
    // 3. V√©rification des ratios interdits EN PHASE DE PERTES SEULEMENT
if (consecutiveLosses > 0) {
    const redCount = (colorSeries.match(/R/g) || []).length;
    const greenCount = (colorSeries.match(/V/g) || []).length;
    
    // Liste des ratios interdits
    const bannedRatios = [
        {r:7, v:3}, {r:3, v:7},
        {r:8, v:2}, {r:2, v:8},
        {r:9, v:1}, {r:1, v:9},
        {r:10, v:0}, {r:0, v:10}
    ];

    // V√©rifier si le ratio actuel est interdit
    const isBannedRatio = bannedRatios.some(ratio => 
        (redCount === ratio.r && greenCount === ratio.v) ||
        (redCount === ratio.v && greenCount === ratio.r)
    );

    if (isBannedRatio) {
        Swal.fire({
            title: 'RATIO INTERDIT EN PHASE DE PERTES ‚õî',
            html: `
                <div style="font-size: 2rem;">üö´</div>
                <p>Le ratio <strong>${redCount}R/${greenCount}V</strong> est interdit pendant les phases de pertes.</p>
                <p>Motif : Ces ratios extr√™mes sont trop risqu√©s apr√®s une perte.</p>
                <p style="color: #dc3545;">Veuillez entrer une nouvelle s√©quence.</p>
                <p>Pertes cons√©cutives : ${consecutiveLosses}</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#dc3545'
        });
        return false;
    }
}

    // 4. V√©rification des ratios interdits (6R/4V et 6V/4R)
   /* if ((redCount === 6 && greenCount === 4) || (redCount === 4 && greenCount === 6)) {
        Swal.fire({
            title: 'RATIO INTERDIT ‚õî',
            html: `
                <div style="font-size: 2rem;">üö´</div>
                <p>Le ratio <strong>${redCount}R/${greenCount}V</strong> est interdit.</p>
                <p>Motif : Ces ratios montrent une instabilit√© statistique trop importante.</p>
                <p style="color: #dc3545;">Veuillez entrer une nouvelle s√©quence.</p>
            `,
            icon: 'error',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#dc3545'
        });
        return false;
    }*/
     
    // 3. V√©rification des motifs bloqu√©s apr√®s une perte (s'applique m√™me en mode forc√©)
    if (bannedPatterns.includes(lastThree)) {
        Swal.fire({
            title: 'PR√âDICTION TEMPORAIREMENT BLOQU√âE ‚ö†Ô∏è',
            html: `
                <div style="font-size: 2rem;">üîí</div>
                <p>La s√©quence <strong>${lastThree}</strong> est temporairement bloqu√©e.</p>
                <p>Motif : Cette s√©quence a r√©cemment entra√Æn√© une perte.</p>
                <p style="color: #ffc107;">Attendez un gain pour d√©bloquer ce motif.</p>
                ${consecutiveLosses >= 0 ? `<p style="margin-top:10px;">üö® Vous avez ${consecutiveLosses} pertes cons√©cutives - Soyez prudent!</p>` : ''}
            `,
            icon: 'warning',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#ffc107',
            background: '#fff3cd'
        });
        return false;
    }

    return true; // Tout est OK - Aucune restriction ne s'applique
}
// Fonction pour analyser les raisons de l'√©chec (exemple)
function analyzeLossReason(colorInput, prediction, result) {
    const colors = colorInput.split('');
    const lastThree = colors.slice(-3).join('');
    
    if (failedPatterns[lastThree] && failedPatterns[lastThree] === prediction) {
        return "Ce motif avait d√©j√† √©chou√© avec la m√™me pr√©diction.";
    }
    
    const redCount = colors.filter(c => c === 'R').length;
    const greenCount = colors.filter(c => c === 'V').length;
    
    if ((redCount > greenCount && prediction === 'vert') || 
        (greenCount > redCount && prediction === 'rouge')) {
        return "La pr√©diction allait √† l'encontre de la tendance dominante.";
    }
    
    return "Fluctuation al√©atoire du march√©.";
}

// Fonction pour obtenir des conseils (exemple)
function getLossAdvice(reason) {
   
    if (reason.includes("tendance dominante")) {
        return "Suivez la tendance dominante dans vos prochaines pr√©dictions.";
    }
    return "Maintenez votre strat√©gie, ce type de perte est statistiquement normal.";
}

// Nouvelle fonction pour sauvegarder les stats par couleur
function saveColorStats() {
    localStorage.setItem('redStats', JSON.stringify({
        successes: redSuccesses,
        failures: redFailures
    }));
    
    localStorage.setItem('greenStats', JSON.stringify({
        successes: greenSuccesses,
        failures: greenFailures
    }));
}

// Nouvelle fonction pour sauvegarder l'√©tat du mode forc√©
function saveForceModeState() {
    localStorage.setItem('forceMode', JSON.stringify({
        isActive: isForceModeActive,
        color: forcedColor,
        consecutiveLosses: consecutiveLosses
    }));
}
function gererPertesConsecutives(estPerte) {
    if (estPerte) {
        // Si c'est une perte, on incr√©mente le compteur
        pertesConsecutivesActuelles++;
        
        // On met √† jour le record si n√©cessaire
        if (pertesConsecutivesActuelles > plusGrandNombrePertesDAffilees) {
            plusGrandNombrePertesDAffilees = pertesConsecutivesActuelles;
            // Sauvegarde dans le localStorage
            localStorage.setItem('maxConsecutiveLosses', plusGrandNombrePertesDAffilees);
            
            // Mise √† jour de l'affichage
            document.getElementById('maxConsecutiveLosses').innerHTML = 
                `Plus grande s√©rie de pertes : <span>${plusGrandNombrePertesDAffilees}</span>`;
        }
    } else {
        // Si c'est un gain, on r√©initialise le compteur
        pertesConsecutivesActuelles = 0;
    }
}
// Modifier la fonction saveHistoryToLocalStorage() pour inclure les nouvelles donn√©es
function saveHistoryToLocalStorage() {
    try {
        // Filtrer les entr√©es invalides avant sauvegarde
        const validHistory = history.filter(entry => 
            entry && entry.date && entry.colors && entry.prediction
        );
        
        localStorage.setItem('predictionHistory', JSON.stringify(validHistory));
        console.log("Historique sauvegard√©:", validHistory.length, "entr√©es");
    } catch (error) {
        console.error("Erreur de sauvegarde:", error);
    }
}
function checkDataIntegrity() {
    const problems = [];
    
    history.forEach((record, index) => {
        if (!record.date) problems.push(`Entr√©e ${index}: date manquante`);
        if (!record.colors) problems.push(`Entr√©e ${index}: couleurs manquantes`);
        // Ajoutez d'autres v√©rifications...
    });
    
    if (problems.length > 0) {
        console.warn("Probl√®mes d√©tect√©s:", problems);
        Swal.fire({
            title: 'Probl√®me de donn√©es',
            html: `${problems.length} anomalies d√©tect√©es.<br>Voir la console pour les d√©tails.`,
            icon: 'warning'
        });
    } else {
        console.log("Aucun probl√®me d'int√©grit√© d√©tect√©");
    }
}
function analyzeAllLosses() {
    const losses = history.filter(record => record.result === '√âchec'); // Filtrer les pertes
    if (losses.length === 0) {
        Swal.fire({
            title: 'Aucune Perte Trouv√©e ‚úÖ',
            text: 'F√©licitations ! Vous n\'avez subi aucune perte jusqu\'√† pr√©sent.',
            icon: 'success',
            confirmButtonText: 'Continuer',
        });
        return;
    }

    let analysisReport = "<h3>Analyse des Pertes</h3><ul>";
    losses.forEach((loss, index) => {
        const lossReason = analyzeLossReason(loss.colors, loss.prediction, loss.result);
        analysisReport += `
            <li>
                <strong>Trade ${loss.tradeNumber} :</strong>
                <p>Pr√©diction : ${loss.prediction}</p>
                <p>Couleurs : ${loss.colors}</p>
                <p>Raison de la perte : ${lossReason}</p>
                <p>Conseil : ${getLossAdvice(lossReason)}</p>
            </li>
        `;
    });
    analysisReport += "</ul>";

    Swal.fire({
        title: 'Rapport d\'Analyse des Pertes üìä',
        html: analysisReport,
        icon: 'info',
        confirmButtonText: 'Compris',
        width: '800px',
    });
}
function updateHistory() {
    const historyElement = document.getElementById('history');
    
    // Cr√©er un fragment de document pour une meilleure performance
    const fragment = document.createDocumentFragment();
    
    // Cr√©er l'en-t√™te du tableau
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `
        <th style="background-color:#f0f0f0; text-align: center;">N¬∞</th>
        <th style="background-color:#f0f0f0; text-align: center;">Date</th>
        <th style="background-color:#f0f0f0; text-align: center;">Couleurs</th>
        <th style="background-color:#f0f0f0; text-align: center;">Pr√©diction</th>
        <th style="background-color:#f0f0f0; text-align: center;">Pourcentage</th>
        <th style="background-color:#f0f0f0; text-align: center;">R√©sultat</th>
    `;
    fragment.appendChild(headerRow);

    // Parcourir l'historique en commen√ßant par le plus r√©cent
    history.slice().reverse().forEach((record, index) => {
        const tr = document.createElement('tr');
        
        // Mise en forme conditionnelle bas√©e sur le r√©sultat
        const resultClass = record.result === 'Succ√®s' ? 'success-row' : 
                          record.result === '√âchec' ? 'failure-row' : 'pending-row';
        
        tr.className = resultClass;
        
        // Formatage du texte de pr√©diction
        const predictionText = record.modified ? 
                             `${record.prediction} (modifi√©)` : 
                             record.prediction;
        
        // Formatage de la date
        const formattedDate = formatDate(record.date);
        
        tr.innerHTML = `
            <td style="text-align: center;">${history.length - index}</td>
            <td style="text-align: center;">${formattedDate}</td>
            <td>${formatColors(record.colors)}</td>
          <td style="text-align: center; font-size: 20px;">${record.prediction === 'rouge' ? 'üî¥' : 'üü¢'}</td>
            <td style="text-align: center;">${record.frequentColor}</td>
            <td style="text-align: center;">${formatResult(record.result)}</td>
        `;
        
        fragment.appendChild(tr);
    });

    // Effacer et reconstruire le tableau
    historyElement.innerHTML = '';
    historyElement.appendChild(fragment);
    
    // Sauvegarder et mettre √† jour les stats
    saveHistoryToLocalStorage();
    updateStats();
    
    // Ajouter un effet visuel pour la derni√®re entr√©e
    highlightLatestEntry();
}

// Fonctions helper
function formatDate(dateString) {
    if (!dateString) return 'N/A';
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    return new Date(dateString).toLocaleDateString('fr-FR', options);
}
// Modifiez la fonction formatColors dans votre code existant
function formatColors(colors) {
    const colorArray = colors.split(',');
    return colorArray.map((c, index) => {
        const color = c.trim();
        // Ajoute la classe d'animation seulement √† la premi√®re couleur
        const animationClass = index === 0 ? 'prediction-icon' : '';
        return color === 'rouge' ? 
            `<span class="${animationClass}">üî¥</span>` : 
            `<span class="${animationClass}">üü¢</span>`;
    }).join(' ');
}
function formatResult(result) {
    if (!result) return 'En attente';
    return result === 'Succ√®s' ? `<span class="success-result">‚úÖ ${result}</span>` :
           `<span class="failure-result">‚ùå ${result}</span>`;
}

function highlightLatestEntry() {
    const rows = document.querySelectorAll('#history tr');
    if (rows.length > 1) { // Skip header row
        rows[1].classList.add('latest-entry');
    }
}    
           function clearHistory() {
            previousHistory = [...history];
            history = [];
            successes = 0;
            failures = 0;
            points = 0;
            updateHistory();
            updateSuccessRate();
            updateStats();
            updatePoints();
            enableFeedbackButtons();
            updatePieChart(); // Mettre √† jour le diagramme
            updateLionCoins();
            maxConsecutiveLosses = 0;
    currentConsecutiveLosses = 0;
    localStorage.setItem('maxConsecutiveLosses', 0);
    document.getElementById('maxConsecutiveLosses').innerHTML = 
        `Plus grande s√©rie de pertes : <span>0</span>`;
        
        // Mise √† jour du record si n√©cessaire
        if (currentConsecutiveLosses > maxConsecutiveLosses) {
            maxConsecutiveLosses = currentConsecutiveLosses;
            localStorage.setItem('maxConsecutiveLosses', maxConsecutiveLosses);
            
            // Mise √† jour de l'affichage
            document.getElementById('maxConsecutiveLosses').innerHTML = 
                `Plus grande s√©rie de pertes : <span>${maxConsecutiveLosses}</span>`;
        
    }
            Swal.fire({
            title: 'Succ√®s ! üéâ',
            text: 'Historique effac√© avec succ√®s !',
            icon: 'success',
            confirmButtonText: 'Continuer',
            confirmButtonColor: '#28a745',
             background: '#f0f9f0',
             iconColor: '#28a745',
             });
        }

        function undo() {
    if (previousHistory.length === 0) {
        Swal.fire({
            title: 'Information ‚ÑπÔ∏è',
            text: 'Aucune action √† restaurer.',
            icon: 'info',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#007bff',
            background: '#f0f8ff',
            iconColor: '#007bff',
        });
        return;
    }

    // Demander confirmation avant de restaurer
    Swal.fire({
        title: 'Confirmer la restauration ? üîÑ',
        html: `
            <p>Voulez-vous vraiment restaurer l'historique pr√©c√©dent ?</p>
            <div style="font-size: 0.9em; color: #666; margin-top: 10px;">
                Cette action remplacera l'historique actuel.
            </div>
        `,
        icon: 'question',
        showCancelButton: true,
        confirmButtonText: 'Oui, restaurer',
        cancelButtonText: 'Annuler',
        confirmButtonColor: '#28a745',
        cancelButtonColor: '#dc3545',
        background: '#f8f9fa',
    }).then((result) => {
        if (result.isConfirmed) {
            // Restaurer l'historique pr√©c√©dent
            history = [...previousHistory];

            // Recalculer les statistiques
            successes = 0;
            failures = 0;
            points = 0;

            history.forEach(record => {
                if (record.result === 'Succ√®s') {
                    successes += 1;
                    points += 10;
                } else if (record.result === '√âchec') {
                    failures += 1;
                }
            });

            // Mettre √† jour l'interface
            updateHistory();
            updateSuccessRate();
            updatePoints();
            updateProgressBar(successes);
            updatePieChart();

            // Effacer les champs
            document.getElementById('colorInput').value = '';
            document.getElementById('seriesInput').value = '';
            document.getElementById('colorPercentage').value = '';
            document.getElementById('predictionResult').textContent = '';
            document.getElementById('previousResult').textContent = '';

            // R√©activer les boutons de feedback
            enableFeedbackButtons();

            // Confirmer la restauration
            Swal.fire({
                title: 'Restauration r√©ussie ! üéâ',
                text: 'L\'historique a √©t√© restaur√© avec succ√®s.',
                icon: 'success',
                confirmButtonText: 'Continuer',
                confirmButtonColor: '#28a745',
                background: '#f0f9f0',
                iconColor: '#28a745',
                timer: 2000,
                timerProgressBar: true
            });
        }
    });
}
function undoLastPrediction() {
    // 1. V√©rification initiale
    if (history.length === 0) {
        Swal.fire({
            title: 'Information ‚ÑπÔ∏è',
            text: 'Aucune pr√©diction √† annuler.',
            icon: 'info',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#007bff'
        });
        return;
    }

    // 2. R√©cup√©rer la derni√®re pr√©diction
    const lastPrediction = history[history.length - 1];

    // 3. V√©rifier si la pr√©diction peut √™tre annul√©e
    if (lastPrediction.result !== '') {
        Swal.fire({
            title: 'Impossible d\'annuler ‚ö†Ô∏è',
            text: 'Cette pr√©diction a d√©j√† un r√©sultat et ne peut pas √™tre annul√©e.',
            icon: 'warning',
            confirmButtonText: 'Compris'
        });
        return;
    }

    // 4. Demander confirmation
    Swal.fire({
        title: 'Confirmer l\'annulation ?',
        html: `
            <div style="text-align:left">
                <p><strong>Pr√©diction √† annuler :</strong></p>
                <ul>
                    <li>Date : ${lastPrediction.date}</li>
                    <li>Couleurs : ${lastPrediction.colors}</li>
                    <li>Pr√©diction : ${lastPrediction.prediction}</li>
                </ul>
            </div>
        `,
        icon: 'question',
        showCancelButton: true,
        confirmButtonText: 'Oui, annuler',
        cancelButtonText: 'Non, garder',
        confirmButtonColor: '#dc3545'
    }).then((result) => {
        if (result.isConfirmed) {
            // 5. Supprimer la derni√®re pr√©diction
            history.pop();

            // 6. R√©initialiser les √©tats si n√©cessaire
            if (isForceModeActive && lastPrediction.method === 'forced') {
                isForceModeActive = false;
                forcedColor = '';
                document.getElementById('forceModeAlert').style.display = 'none';
                document.getElementById('redStats').classList.remove('force-mode-active');
                document.getElementById('greenStats').classList.remove('force-mode-active');
            }

            // 7. Mettre √† jour l'interface
            updateHistory();
            updateStats();
            updateSuccessRate();
            updatePieChart();
            updateColorStatsDisplay();
            saveHistoryToLocalStorage();

            // 8. R√©initialiser les champs
            document.getElementById('colorInput').value = '';
            document.getElementById('seriesInput').value = '';
            document.getElementById('colorPercentage').value = '';
            document.getElementById('predictionResult').textContent = '';

            // 9. Notification de succ√®s
            Swal.fire({
                title: 'Pr√©diction annul√©e',
                text: 'La derni√®re pr√©diction a √©t√© supprim√©e avec succ√®s.',
                icon: 'success',
                timer: 2000,
                showConfirmButton: false
            });
        }
    });
}
function updateSuccessRate() {
            const successRate = (successes / (successes + failures)) * 100;
            document.getElementById('successRate').textContent = `Taux de r√©ussite : ${successRate.toFixed(2)}%`;
        }

        function updatePoints() {
            document.getElementById('points').textContent = `Points : ${points}`;
            localStorage.setItem('totalPoints', points);
        }

        function saveHistoryToLocalStorage() {
            localStorage.setItem('predictionHistory', JSON.stringify(history));
        }

        function loadHistoryFromLocalStorage() {
            const storedHistory = localStorage.getItem('predictionHistory');
            if (storedHistory) {
                history = JSON.parse(storedHistory);
                updateHistory();
                updateSuccessRate();
                updateStats();
                updatePoints();
            }
        }

        function updateStats() {
            document.getElementById('successRate').textContent = `Taux de r√©ussite : ${(successes / (successes + failures) * 100).toFixed(2)}%`;
            document.getElementById('totalPredictions').textContent = `Total des Pr√©dictions : ${history.length}`;
            document.getElementById('totalSuccesses').textContent = `Total des R√©ussites : ${successes}`;
            document.getElementById('totalFailures').textContent = `Total des Pertes : ${failures}`;
        }
        let pieChart;

function createPieChart() {
    const ctx = document.getElementById('pieChart').getContext('2d');
    pieChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: ['R√©ussites', 'Pertes'],
            datasets: [{
                data: [successes, failures],
                backgroundColor: ['#28a745', '#dc3545'],
                borderColor: ['#218838', '#c82333'],
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                },
                tooltip: {
                    enabled: true
                }
            }
        }
    });
}

function updatePieChart() {
    if (pieChart) {
        pieChart.data.datasets[0].data = [successes, failures];
        pieChart.update();
    } else {
        createPieChart();
    }
}

        function enableFeedbackButtons() {
            document.getElementById('btnSuccess').disabled = false;
            document.getElementById('btnFailure').disabled = false;
        }

        function showOverlay() {
            document.getElementById('overlay').style.display = 'flex';
            document.querySelectorAll('button').forEach(button => button.disabled = true);
            document.getElementById('predictButton').disabled = true;
        }

        function hideOverlay() {
            document.getElementById('overlay').style.display = 'none';
            document.querySelectorAll('button').forEach(button => button.disabled = false);
        }

        function copyHistory() {
            const historyText = history.map(record => `${record.date} - ${record.colors} - ${record.prediction} - ${record.frequentColor} - ${record.result}`).join('\n');
            const el = document.createElement('textarea');
            el.value = historyText;
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            Swal.fire({
  title: 'Succ√®s ! üìã',
  text: 'Historique copi√© dans le presse-papiers !',
  icon: 'success',
  confirmButtonText: 'Continuer',
  confirmButtonColor: '#28a745',
  background: '#f0f9f0',
  iconColor: '#28a745',
});
        }

        

        function showTutorial() {
    Swal.fire({
        title: 'Bienvenue sur Signal Bot 97 TRX ! ü§ñ',
        html: `
            <p>Pour maximiser vos profits, suivez ces √©tapes :</p>
            <ol>
                <li>Entrez une s√©rie de <strong>10 couleurs</strong> (rouge ou vert).</li>
                <li>Le bot analysera les tendances et appliquera les r√®gles de pr√©diction pour optimiser vos gains.</li>
                <li>Suivez les instructions du bot pour miser intelligemment.</li>
            </ol>
            <p><strong>Conseils :</strong></p>
            <ul>
                <li>Restez calme et suivez la strat√©gie.</li>
                <li>Ne misez pas plus que ce que vous pouvez vous permettre de perdre.</li>
                <li>Gardez un ≈ìil sur les tendances et ajustez vos mises si n√©cessaire.</li>
            </ul>
            <p><strong>Bonne chance et que les gains soient avec vous !</strong> üöÄ</p>
            <br>
            <label>
                <input type="checkbox" id="hideTutorial"> Ne plus afficher ce message
            </label>
        `,
        icon: 'info',
        confirmButtonText: 'Commencer',
        confirmButtonColor: '#007bff',
        background: '#f0f8ff',
        iconColor: '#007bff',
        showClass: {
            popup: 'animate__animated animate__fadeIn'
        },
        hideClass: {
            popup: 'animate__animated animate__fadeOut'
        },
        didOpen: () => {
            const hideTutorialCheckbox = document.getElementById('hideTutorial');
            hideTutorialCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    localStorage.setItem('hideTutorial', true);
                } else {
                    localStorage.removeItem('hideTutorial');
                }
            });
        }
    }).then(() => {
        // Afficher la popup strat√©gie apr√®s fermeture du tutoriel
        showStrategyPopup();
    });
}



        function showLevelPopup() {
            const savedLevel = localStorage.getItem('userLevel');
            if (!savedLevel) {
                document.getElementById('levelPopup').style.display = 'block';
            } else {
                document.getElementById('userLevelSpan').textContent = `${savedLevel}`;
            }
        }

        function confirmLevel() {
    const selectedLevel = document.querySelector('input[name="level"]:checked').value;
    localStorage.setItem('userLevel', selectedLevel);
    document.getElementById('userLevelSpan').textContent = selectedLevel.charAt(0).toUpperCase() + selectedLevel.slice(1);
    document.getElementById('levelPopup').style.display = 'none';
    
    Swal.fire({
        title: 'Niveau chang√© !',
        text: `Vous √™tes maintenant niveau ${selectedLevel}`,
        icon: 'success'
    });
}

        function showLevelInfo() {
            document.getElementById('levelInfoPopup').style.display = 'block';
            document.getElementById('currentPoints').textContent = `Points actuels : ${points}`;
        }

        function hideLevelInfo() {
            document.getElementById('levelInfoPopup').style.display = 'none';
        }

        function updateLevelButtons() {
    const intermediateButton = document.querySelector('input[value="interm√©diaire"]');
    const advancedButton = document.querySelector('input[value="avanc√©"]');
    
    // D√©bloque TOUJOURS les boutons, quel que soit le nombre de points
    intermediateButton.disabled = false;
    advancedButton.disabled = false;
    
    // Optionnel : supprime aussi l'apparence visuelle "d√©sactiv√©"
    intermediateButton.classList.remove('disabled');
    advancedButton.classList.remove('disabled');
}
        document.addEventListener('DOMContentLoaded', () => {
    loadHistoryFromLocalStorage();
    loadStatsFromLocalStorage();
    validateUserName();
    showLevelPopup();
    updateLevelButtons();
    showNotificationPopup();
    checkConsecutiveLosses();
    
    // Gestion unique de l'affichage du tutoriel
    if (!localStorage.getItem('hideTutorial')) {
        showTutorial();
    } else {
        // Si l'utilisateur a choisi de masquer le tutoriel
        document.querySelectorAll('button').forEach(btn => btn.disabled = false);
    }
});

// Gestion de l'input pour les s√©ries de couleurs
document.getElementById('seriesInput').addEventListener('input', function (e) {
    const originalValue = this.value;
    // Convertir en majuscules et ne garder que R ou V
    this.value = this.value.toUpperCase().replace(/[^RV]/g, '');

    // Limiter √† 10 caract√®res
    if (this.value.length > 10) {
        this.value = this.value.slice(0, 10);
    }

    // Si la valeur a chang√©, afficher une alerte
    if (originalValue !== this.value) {
        Swal.fire({
            title: 'Caract√®re non autoris√© ‚ö†Ô∏è',
            text: 'Veuillez entrer uniquement "R" ou "V" (max 10 caract√®res).',
            icon: 'warning',
            confirmButtonText: 'Compris',
            confirmButtonColor: '#ffc107',
            background: '#fff3cd',
            iconColor: '#ffc107',
        });
    }
});
     function findMostSimilarPattern(inputPattern) {
    let mostSimilarPattern = '';
    let highestSimilarity = 0;

    // Parcourir tous les motifs existants
    for (const pattern in patterns) {
        let similarity = 0;
        for (let i = 0; i < inputPattern.length; i++) {
            if (inputPattern[i] === pattern[i]) {
                similarity++;
            }
        }
        // Si ce motif est plus similaire que le pr√©c√©dent, on le garde
        if (similarity > highestSimilarity) {
            highestSimilarity = similarity;
            mostSimilarPattern = pattern;
        }
    }

    return mostSimilarPattern;
}
function predictBasedOnSimilarity(inputPattern) {
    const mostSimilarPattern = findMostSimilarPattern(inputPattern);
    if (mostSimilarPattern) {
        return patterns[mostSimilarPattern]; // Retourne la pr√©diction associ√©e au motif le plus similaire
    } else {
        return predictBasedOnTrends(inputPattern); // Si aucun motif similaire n'est trouv√©, utilise la pr√©diction bas√©e sur les tendances
    }
}

function predictBasedOnTrends(colorInput) {
    const lastThreeColors = colorInput.slice(-3); // Prend les 3 derni√®res couleurs
    const colorCount = lastThreeColors.split('').reduce((count, char) => {
        count[char] = (count[char] || 0) + 1;
        return count;
    }, {});

    // Si une couleur domine dans les 3 derni√®res, pr√©dire cette couleur
    if (colorCount['R'] > colorCount['V']) {
        return 'rouge';
    } else if (colorCount['V'] > colorCount['R']) {
        return 'vert';
    } else {
        // Si √©galit√©, pr√©dire en fonction du pourcentage global
        const globalRed = (colorInput.split('R').length - 1) * 10;
        const globalGreen = (colorInput.split('V').length - 1) * 10;
        return globalRed >= globalGreen ? 'rouge' : 'vert';
    }
}
function isSimpleAlternate(colors) {
    for (let i = 1; i < colors.length; i++) {
        if (colors[i] === colors[i - 1]) {
            return false;
        }
    }
    return true;
}

function isSimpleDoubleAlternate(colors) {
    for (let i = 2; i < colors.length; i += 2) {
        if (colors[i] !== colors[i - 1] || colors[i] === colors[i - 2]) {
            return false;
        }
    }
    return true;
}
function isSimpleTripleAlternate(colors) {
    for (let i = 3; i < colors.length; i += 3) {
        // V√©rifie si les 3 couleurs suivantes sont identiques aux 3 pr√©c√©dentes
        if (colors[i] !== colors[i - 1] || colors[i] !== colors[i - 2] || colors[i] === colors[i - 3]) {
            return false;
        }
    }
    return true;
}
function predictBasedOnTrend(colorInput) {
    const colors = colorInput.split('');

    if (isSimpleAlternate(colors)) {
        return colors[colors.length - 1] === 'R' ? 'vert' : 'rouge';
    } else if (isSimpleDoubleAlternate(colors)) {
        return colors[colors.length - 1] === 'R' ? 'vert' : 'rouge';
    } else if (isSimpleTripleAlternate(colors)) {
        return colors[colors.length - 1] === 'R' ? 'vert' : 'rouge';
    } else {
        return predictBasedOnTrends(colorInput); // Utilise la fonction existante
    }
}
function checkColorRatioBan(colorInput) {
    const redCount = (colorInput.match(/R/g) || []).length;
    const greenCount = (colorInput.match(/V/g) || []).length;
    
    // Bloquer les ratios 6R/4V et 6V/4R
    if ((redCount === 6 && greenCount === 4) || (redCount === 4 && greenCount === 6)) {
        return true; // Ratio banni
    }
    return false; // Ratio acceptable
}
// Fonction pour calculer les statistiques par couleur
function calculateColorStats() {
    // R√©initialiser les compteurs
    redSuccesses = 0;
    redFailures = 0;
    greenSuccesses = 0;
    greenFailures = 0;

    // Parcourir l'historique pour compter les succ√®s/√©checs par couleur
    history.forEach(record => {
        if (record.result === 'Succ√®s' || record.result === '√âchec') {
            if (record.prediction === 'rouge') {
                if (record.result === 'Succ√®s') redSuccesses++;
                else redFailures++;
            } else if (record.prediction === 'vert') {
                if (record.result === 'Succ√®s') greenSuccesses++;
                else greenFailures++;
            }
        }
    });

    // Mettre √† jour l'affichage
    updateColorStatsDisplay();
    
    // V√©rifier si on doit activer le mode forc√©
    checkForceMode();
}

// Fonction pour mettre √† jour l'affichage des statistiques
function updateColorStatsDisplay() {
    // Calcul des pourcentages
    const redTotal = redSuccesses + redFailures;
    const greenTotal = greenSuccesses + greenFailures;
    
    const redSuccessRate = redTotal > 0 ? (redSuccesses / redTotal * 100).toFixed(1) : 0;
    const greenSuccessRate = greenTotal > 0 ? (greenSuccesses / greenTotal * 100).toFixed(1) : 0;

    // Mise √† jour des √©l√©ments HTML
    document.getElementById('redSuccessCount').textContent = `${redSuccesses} succ√®s`;
    document.getElementById('redFailureCount').textContent = `${redFailures} √©checs`;
    document.getElementById('redSuccessRate').textContent = `${redSuccessRate}% de r√©ussite`;
    
    document.getElementById('greenSuccessCount').textContent = `${greenSuccesses} succ√®s`;
    document.getElementById('greenFailureCount').textContent = `${greenFailures} √©checs`;
    document.getElementById('greenSuccessRate').textContent = `${greenSuccessRate}% de r√©ussite`;

    // Ajouter des indicateurs de tendance
    updateTrendIndicators(redSuccessRate, greenSuccessRate);
}
// Mets √ßa avec les autres fonctions (updateHistory(), etc.)
function updateConsecutiveLosses(isLoss) {
    if (isLoss) {
        currentConsecutiveLosses++;
        if (currentConsecutiveLosses > maxConsecutiveLosses) {
            maxConsecutiveLosses = currentConsecutiveLosses;
            document.getElementById('maxConsecutiveLosses').innerHTML = 
                `Plus grande s√©rie de pertes : <span>${maxConsecutiveLosses}</span>`;
        }
    } else {
        currentConsecutiveLosses = 0; // R√©initialise si gain
    }
}

function updateLionCoins() {
    const lionCoins = (points * LION_COIN_RATE).toFixed(2);
    document.getElementById('lionCoins').innerHTML = 
        `Lion Coins : <span>${lionCoins} LC</span>`;
}
// Fonction pour mettre √† jour les indicateurs de tendance
function updateTrendIndicators(redRate, greenRate) {
    const redTrendElement = document.getElementById('redTrend');
    const greenTrendElement = document.getElementById('greenTrend');
    
    // Effacer les anciens indicateurs
    redTrendElement.innerHTML = '';
    greenTrendElement.innerHTML = '';
    
    // Ajouter des indicateurs visuels
    if (redRate > greenRate) {
        redTrendElement.innerHTML = '<span style="color:#28a745">‚Üë Meilleure performance</span>';
        greenTrendElement.innerHTML = '<span style="color:#6c757d">‚Üò Plus faible performance</span>';
    } else if (greenRate > redRate) {
        greenTrendElement.innerHTML = '<span style="color:#28a745">‚Üë Meilleure performance</span>';
        redTrendElement.innerHTML = '<span style="color:#6c757d">‚Üò Plus faible performance</span>';
    } else {
        redTrendElement.innerHTML = '<span style="color:#6c757d">= Performance √©gale</span>';
        greenTrendElement.innerHTML = '<span style="color:#6c757d">= Performance √©gale</span>';
    }
}

// Fonction pour v√©rifier si on doit activer le mode forc√©
function checkForceMode() {
    // D√©sactiver le mode forc√© si on a un gain (inchang√©)
    if (history.length > 0 && history[history.length - 1].result === 'Succ√®s') {
        if (isForceModeActive) {
            isForceModeActive = false;
            document.getElementById('forceModeAlert').style.display = 'none';
            document.getElementById('redStats').classList.remove('force-mode-active');
            document.getElementById('greenStats').classList.remove('force-mode-active');
            
            Swal.fire({
                title: 'Mode Forc√© D√©sactiv√©',
                text: 'Un gain a √©t√© enregistr√©, retour au mode normal.',
                icon: 'success',
                timer: 2000
            });
        }
        return;
    }
    
    // MODIFICATION PRINCIPALE : Activation apr√®s 5 pertes au lieu de 2
    if (consecutiveLosses >= 5 && !isForceModeActive) {
        isForceModeActive = true;
        
        // D√©terminer quelle couleur forcer (inchang√©)
        const redTotal = redSuccesses + redFailures;
        const greenTotal = greenSuccesses + greenFailures;
        
        const redRate = redTotal > 0 ? redSuccesses / redTotal : 0;
        const greenRate = greenTotal > 0 ? greenSuccesses / greenTotal : 0;
        
        forcedColor = redRate >= greenRate ? 'rouge' : 'vert';
        
        // Mettre √† jour l'interface (inchang√©)
        document.getElementById('forceModeAlert').style.display = 'block';
        document.getElementById('forcedColorText').textContent = forcedColor;
        document.getElementById('forcedColorText').style.color = forcedColor === 'rouge' ? '#dc3545' : '#28a745';
        
        if (forcedColor === 'rouge') {
            document.getElementById('redStats').classList.add('force-mode-active');
        } else {
            document.getElementById('greenStats').classList.add('force-mode-active');
        }
        
        // Message d'alerte mis √† jour pour refl√©ter 5 pertes
        Swal.fire({
            title: 'Mode Forc√© Activ√©!',
            html: `5 pertes cons√©cutives d√©tect√©es. Le bot forcera maintenant les pr√©dictions sur <strong style="color:${forcedColor === 'rouge' ? '#dc3545' : '#28a745'}">${forcedColor}</strong> jusqu'au prochain gain.`,
            icon: 'warning',
            confirmButtonText: 'Compris'
        });
    }
}
function predictBasedOnSimilarity(inputPattern) {
    // 1. D'abord essayer avec les motifs connus
    const mostSimilarPattern = findMostSimilarPattern(inputPattern);
    if (mostSimilarPattern && patterns[mostSimilarPattern]) {
        return patterns[mostSimilarPattern];
    }
    
    // 2. Si aucun motif connu, utiliser la r√®gle par d√©faut
    const lastColor = inputPattern.slice(-1); // Prendre la derni√®re couleur
    return lastColor === 'R' ? 'rouge' : 'vert';
}
// Gestion du mot de passe
function showPasswordPopup() {
    document.getElementById('passwordPopup').style.display = 'flex';
    document.getElementById('passwordInput').focus();
}

// Afficher le popup au chargement
document.addEventListener('DOMContentLoaded', function() {
    // Affiche le popup apr√®s un court d√©lai (1 seconde)
    setTimeout(showPasswordPopup, 1000);
});
function closePasswordPopup() {
    document.getElementById('passwordPopup').style.display = 'none';
}

document.addEventListener('DOMContentLoaded', function() {
    const passwordInput = document.getElementById('passwordInput');
    const dots = document.querySelectorAll('.code-dot');
    const keypadBtns = document.querySelectorAll('.keypad-btn');
    const passwordPopup = document.getElementById('passwordPopup');
    
    // Focus automatique
    passwordInput.focus();
    
    // Gestion des touches du clavier
    keypadBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const value = this.getAttribute('data-value');
            const action = this.getAttribute('data-action');
            
            if (action === 'clear') {
                passwordInput.value = '';
                updateDots();
            } else if (action === 'confirm') {
                validatePassword();
            } else if (value && passwordInput.value.length < 6) {
                passwordInput.value += value;
                updateDots();
            }
        });
    });
    
    // Mise √† jour des points visuels
    function updateDots() {
        const code = passwordInput.value;
        dots.forEach((dot, index) => {
            dot.classList.toggle('filled', index < code.length);
        });
    }
    
    // Validation du mot de passe
    function validatePassword() {
    if (passwordInput.value === '123456') {
        closePasswordPopup();
        if (!localStorage.getItem('hideTutorial')) {
            showTutorial();
               // Ajoutez ici votre logique apr√®s validation r√©ussie
               Swal.fire({
                    title: 'Acc√®s refus√©',
                    text: 'Code incorrect',
                    icon: 'error',
                    timer: 1500
                });
            } else {
                passwordPopup.classList.add('shake');
                setTimeout(() => passwordPopup.classList.remove('shake'), 400);
                
                Swal.fire({
                    title: 'Acc√®s autoris√©',
                    text: 'Mot de passe correct',
                    icon: 'success',
                    timer: 1500
                });
                
                passwordInput.value = '';
                updateDots();
            }
        } else {
            passwordPopup.classList.add('shake');
            setTimeout(() => passwordPopup.classList.remove('shake'), 400);
        }
    }
    
    // Emp√™cher la saisie directe autre que num√©rique
    passwordInput.addEventListener('input', function(e) {
        this.value = this.value.replace(/\D/g, '').slice(0, 6);
        updateDots();
    });
    
    // Emp√™cher le copier-coller
    passwordInput.addEventListener('paste', function(e) {
        e.preventDefault();
    });
    
    // Gestion de la touche Entr√©e
    passwordInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            validatePassword();
        }
    });
});
// Gestion du profil WhatsApp
document.getElementById('profileUpload').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
            document.getElementById('profileImage').src = event.target.result;
            
            // Sauvegarder dans le localStorage
            localStorage.setItem('whatsappProfileImage', event.target.result);
            
            Swal.fire({
                title: 'Photo mise √† jour!',
                text: 'Votre photo de profil WhatsApp a √©t√© chang√©e.',
                icon: 'success',
                timer: 1500
            });
        }
        reader.readAsDataURL(file);
    }
});

// Charger l'image sauvegard√©e au d√©marrage
document.addEventListener('DOMContentLoaded', function() {
    const savedImage = localStorage.getItem('whatsappProfileImage');
    if (savedImage) {
        document.getElementById('profileImage').src = savedImage;
    }
});
function exportToTxt() {
    // Cr√©ation de l'en-t√™te
    let content = "=".repeat(80) + "\n";
    content += "HISTORIQUE DES PR√âDICTIONS TRX BOT\n";
    content += "=".repeat(80) + "\n\n";

    // Statistiques globales
    content += "STATISTIQUES GLOBALES\n";
    content += "-".repeat(50) + "\n";
    const total = successes + failures;
    const successRate = total > 0 ? (successes / total * 100).toFixed(1) : 0;
    
    content += `Total des pr√©dictions    : ${total}\n`;
    content += `R√©ussites               : ${successes} (${successRate}%)\n`;
    content += `√âchecs                  : ${failures}\n`;
    content += `S√©rie max. de pertes    : ${maxConsecutiveLosses}\n\n`;

    // Statistiques par couleur
    content += "STATISTIQUES PAR COULEUR\n";
    content += "-".repeat(50) + "\n";
    
    const redTotal = redSuccesses + redFailures;
    const greenTotal = greenSuccesses + greenFailures;
    const redRate = redTotal > 0 ? (redSuccesses / redTotal * 100).toFixed(1) : 0;
    const greenRate = greenTotal > 0 ? (greenSuccesses / greenTotal * 100).toFixed(1) : 0;

    content += `ROUGE : ${redSuccesses} gains / ${redFailures} pertes (${redRate}% r√©ussite)\n`;
    content += `VERT  : ${greenSuccesses} gains / ${greenFailures} pertes (${greenRate}% r√©ussite)\n\n`;

    // En-t√™te du tableau d'historique
    content += "HISTORIQUE D√âTAILL√â\n";
    content += "-".repeat(80) + "\n";
    content += "N¬∞    | Date       | Couleurs           | Pr√©diction  | % Couleur   | R√©sultat\n";
    content += "-".repeat(80) + "\n";

    // Donn√©es de l'historique
    history.forEach((record, index) => {
        const num = (index + 1).toString().padEnd(5);
        const date = record.date.padEnd(11);
        const colors = record.colors.replace(/rouge/g, 'üî¥').replace(/vert/g, 'üü¢').padEnd(18);
        const prediction = record.prediction.toUpperCase().padEnd(11);
        const freqColor = record.frequentColor.padEnd(12);
        const result = record.result === 'Succ√®s' ? '‚úÖ Gain' : 
                      record.result === '√âchec' ? '‚ùå Perte' : '‚è≥ Attente';

        content += `${num}| ${date}| ${colors}| ${prediction}| ${freqColor}| ${result}\n`;
    });

    // Pied de page
    content += "-".repeat(80) + "\n";
    content += `\nExport√© le : ${new Date().toLocaleString('fr-FR')}\n`;
    content += "G√©n√©r√© par Signal Bot 97 TRX\n";

    // Cr√©ation et t√©l√©chargement du fichier
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `Historique_TRX_${new Date().toISOString().slice(0, 10)}.txt`;
    link.click();

    // Notification de succ√®s
    Swal.fire({
        title: 'Export TXT R√©ussi! üìÑ',
        html: `
            <p>Le fichier a √©t√© g√©n√©r√© avec succ√®s.</p>
            <p>Contient:</p>
            <ul style="text-align: left;">
                <li>${total} pr√©dictions</li>
                <li>Statistiques globales</li>
                <li>Statistiques par couleur</li>
                <li>Historique d√©taill√©</li>
            </ul>
        `,
        icon: 'success',
        confirmButtonText: 'OK'
    });
}
function copyHistoryInDBFormat() {
    if (history.length === 0) {
        Swal.fire({
            title: 'Historique vide',
            text: 'Aucune donn√©e √† copier',
            icon: 'warning'
        });
        return;
    }

    // Cr√©er le texte au m√™me format que la base externe
    let historyText = history.map(record => {
        // Convertir les couleurs au format R,V
        const colorsFormatted = record.colors.split(', ')
            .map(c => c === 'rouge' ? 'R' : 'V')
            .join(', ');
        
        // Formater la date (JJ/MM/AAAA)
        const dateParts = record.date.split('-');
        const formattedDate = dateParts.length === 3 ? 
            `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}` : record.date;
        
        return `${formattedDate} - ${colorsFormatted} - ${record.prediction === 'rouge' ? 'R' : 'V'} - ${record.result || 'En attente'}`;
    }).join('\n');

    // Copier dans le presse-papiers
    navigator.clipboard.writeText(historyText).then(() => {
        Swal.fire({
            title: 'Copi√©!',
            html: `
                <p>${history.length} entr√©es copi√©es au format base de donn√©es</p>
                <textarea style="width:100%; height:100px; margin-top:10px;" readonly>${historyText}</textarea>
            `,
            icon: 'success',
            confirmButtonText: 'OK',
            width: 600
        });
    }).catch(err => {
        Swal.fire({
            title: 'Erreur',
            text: '√âchec de la copie: ' + err,
            icon: 'error'
        });
    });
}
function analyzeCorrelation(colorInput) {
    const colors = colorInput.split('');
    let correlation = 0;
    
    for (let i = 1; i < colors.length; i++) {
        if (colors[i] === colors[i-1]) {
            correlation++;
        }
    }
    
    return correlation / (colors.length - 1);
}
function detectCycle(colorInput) {
    const colors = colorInput.split('');
    for (let length = 2; length <= colors.length / 2; length++) {
        let isCycle = true;
        for (let i = 0; i < length; i++) {
            if (colors[i] !== colors[i + length]) {
                isCycle = false;
                break;
            }
        }
        if (isCycle) {
            return length;
        }
    }
    return 0;
}
function hybridPrediction(colorInput) {
    const patternPrediction = predictBasedOnRepeatedPatterns(colorInput);
    const trendPrediction = predictBasedOnTrends(colorInput);
    const similarityPrediction = predictBasedOnSimilarity(colorInput);
    
    // Pond√©ration des pr√©dictions
    if (patternPrediction) return patternPrediction;  // Priorit√© aux motifs r√©p√©t√©s
    if (similarityPrediction) return similarityPrediction;  // Ensuite aux motifs similaires
    return trendPrediction;  // Par d√©faut, utiliser la tendance
}
// ====== CITATIONS PUISSANTES ====== //
const TRX_QUOTES = [
    "Vos gains sont la somme de nos calculs et de votre discipline.",
    "Derri√®re chaque fortune crypto, il y a un bot qui n'a pas dormi.",
    "Nous automatisons la chance pour que vous h√©ritiez du futur."
];

function rotateQuote() {
    const quoteElement = document.getElementById('quote-text');
    let currentIndex = 0;
    
    setInterval(() => {
        quoteElement.style.opacity = 0;
        setTimeout(() => {
            currentIndex = (currentIndex + 1) % TRX_QUOTES.length;
            quoteElement.textContent = `"${TRX_QUOTES[currentIndex]}"`;
            quoteElement.style.opacity = 1;
        }, 500);
    }, 10000); // Change toutes les 10 secondes
}

rotateQuote(); // Lance le syst√®me
function isBlockedAfterLoss(colorInput) {
    // V√©rifie si la s√©quence se termine par RRR ou VVV
    const lastThree = colorInput.slice(-3);
    return lastThree === 'RRR' || lastThree === 'VVV';
}
// Ajoutez cette fonction helper
function checkFirstColorWarning(colorInput, prediction) {
    const firstColor = colorInput[0];
    const predictionColor = prediction === 'rouge' ? 'R' : 'V';
    
    if (firstColor !== predictionColor && lastResultWasLoss) {
        return Swal.fire({
            title: '‚ö†Ô∏è Attention - Risque D√©tect√©!',
            html: `
                <div style="background:#fff3cd; padding:15px; border-radius:8px; margin:10px 0;">
                    <p><strong>Premi√®re couleur :</strong> ${firstColor === 'R' ? 'üî¥ Rouge' : 'üü¢ Vert'}</p>
                    <p><strong>Pr√©diction :</strong> ${prediction === 'rouge' ? 'üî¥ Rouge' : 'üü¢ Vert'}</p>
                    <p style="color:#856404; margin-top:10px;">
                        ‚ö†Ô∏è La premi√®re couleur ne correspond pas √† la pr√©diction!
                    </p>
                </div>
                <p style="margin-top:15px;">En phase de perte, il est recommand√© d'avoir une correspondance.</p>
            `,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Continuer quand m√™me',
            cancelButtonText: 'Annuler la pr√©diction',
            confirmButtonColor: '#ffc107',
            cancelButtonColor: '#dc3545',
            reverseButtons: true
        }).then((result) => {
            return result.isConfirmed;
        });
    }
    return Promise.resolve(true);
}
</script>
</body>
</html>
